import{r as t,o,c as i,b as n,d as a,e as l,w as c,a as e}from"./index-eb65bd0c.js";const r={class:"md-content__inner md-typeset"},d={class:"hint"},m={class:"note"},f={class:"admonition note"},u={class:"admonition tip"},_={__name:"StrategyCustomization",setup(h){return(g,s)=>{const p=t("router-link");return o(),i("article",r,[s[66]||(s[66]=n("h1",{id:"strategy-customization"},[a(" 전략 커스터마이징 "),n("a",{class:"headerlink",href:"#strategy-customization",title:"영구 링크"}," ¶ ")],-1)),s[67]||(s[67]=n("p",null,"이 페이지는 전략을 커스터마이징하고, 새로운 지표를 추가하며, 거래 규칙을 설정하는 방법을 설명합니다.",-1)),s[68]||(s[68]=n("p",null,"아직 익숙하지 않다면, 다음을 먼저 확인하세요:",-1)),n("ul",null,[n("li",null,[l(p,{to:"strategy-101"},{default:c(()=>s[0]||(s[0]=[a(" Freqtrade 전략 101 ")])),_:1}),s[1]||(s[1]=a(" - 전략 개발을 빠르게 시작할 수 있는 가이드 "))]),n("li",null,[l(p,{to:"bot-basics"},{default:c(()=>s[2]||(s[2]=[a(" Freqtrade 봇 기본 ")])),_:1}),s[3]||(s[3]=a(" - 봇이 작동하는 방식에 대한 전반적인 정보 제공 "))])]),s[69]||(s[69]=e(`<h2 id="develop-your-own-strategy"> 자신만의 전략 개발 <a class="headerlink" href="#develop-your-own-strategy" title="영구 링크"> ¶ </a></h2><p>봇에는 기본 전략 파일이 포함되어 있습니다.</p><p> 또한, 여러 다른 전략들이 <a href="https://github.com/freqtrade/freqtrade-strategies"> 전략 저장소 </a> 에서 제공됩니다. </p><p>그러나 대부분의 경우 자신만의 전략 아이디어를 가지고 있을 것입니다.</p><p>이 문서는 아이디어를 작동하는 전략으로 변환하는 데 도움을 주기 위해 작성되었습니다.</p><h3 id="generating-a-strategy-template"> 전략 템플릿 생성 <a class="headerlink" href="#generating-a-strategy-template" title="영구 링크"> ¶ </a></h3><p>시작하려면 다음 명령어를 사용할 수 있습니다:</p><div class="highlight"><pre><code>freqtrade new-strategy --strategy AwesomeStrategy
</code></pre></div><p> 이 명령어는 <code> AwesomeStrategy </code> 라는 새로운 전략을 템플릿에서 생성하며, 파일명은 <code> user_data/strategies/AwesomeStrategy.py </code> 로 저장됩니다. </p><div class="admonition note"><p class="admonition-title">참고</p><p> 전략의 <em> 이름 </em> 과 파일명은 다릅니다. 대부분의 명령어에서 Freqtrade는 <em> 파일명 </em> 이 아닌 <em> 이름 </em> 을 사용합니다. </p></div><div class="admonition note"><p class="admonition-title">참고</p><p><code> new-strategy </code> 명령어는 기본적으로 수익성이 없는 예제를 생성합니다. </p></div><details class="hint"><summary>다양한 템플릿 수준</summary><p><code> freqtrade new-strategy </code> 명령어에는 추가 매개변수 <code> --template </code> 이 있으며, 생성된 전략에 포함된 사전 정의된 정보의 양을 제어합니다. <code> --template minimal </code> 을 사용하면 지표 예제가 없는 빈 전략을 생성하고, <code> --template advanced </code> 를 사용하면 더 복잡한 기능이 정의된 템플릿을 생성합니다. </p></details><h3 id="anatomy-of-a-strategy"> 전략의 구조 <a class="headerlink" href="#anatomy-of-a-strategy" title="영구 링크"> ¶ </a></h3><p>전략 파일에는 전략 로직을 구성하는 데 필요한 모든 정보가 포함되어 있습니다:</p><ul><li>OHLCV 형식의 캔들 데이터</li><li>지표</li><li> 진입 로직 <ul><li>신호</li></ul></li><li> 청산 로직 <ul><li>신호</li><li>최소 ROI</li><li>콜백(&quot;사용자 정의 함수&quot;)</li></ul></li><li> 손절매 <ul><li>고정/절대값</li><li>트레일링</li><li>콜백(&quot;사용자 정의 함수&quot;)</li></ul></li><li>가격 책정 [선택 사항]</li><li>포지션 조정 [선택 사항]</li></ul><p> 봇에는 <code> SampleStrategy </code> 라는 샘플 전략이 포함되어 있으며, 이를 기반으로 사용할 수 있습니다: <code> user_data/strategies/sample_strategy.py </code> . 다음 매개변수를 사용하여 테스트할 수 있습니다: <code> --strategy SampleStrategy </code> . 전략 클래스 이름을 사용하며 파일명을 사용하지 않는 것을 기억하세요. </p><p> 또한 <code> INTERFACE_VERSION </code> 이라는 속성이 있으며, 봇이 사용할 전략 인터페이스의 버전을 정의합니다. 현재 버전은 3이며, 명시적으로 설정되지 않은 경우 기본값으로 사용됩니다. </p><p>이전 버전의 전략은 인터페이스 버전 2로 설정되어 있을 수 있으며, 향후 버전에서는 이를 v3 용어로 업데이트해야 합니다.</p><p> 봇을 드라이 모드 또는 라이브 모드로 시작하려면 <code> trade </code> 명령어를 사용합니다: </p><div class="highlight"><pre><code>freqtrade trade --strategy AwesomeStrategy
</code></pre></div><h3 id="bot-modes"> 봇 모드 <a class="headerlink" href="#bot-modes" title="영구 링크"> ¶ </a></h3><p>Freqtrade 전략은 Freqtrade 봇에 의해 5가지 주요 모드로 처리될 수 있습니다:</p><ul><li>백테스팅</li><li>하이퍼옵팅</li><li>드라이 (&quot;포워드 테스팅&quot;)</li><li>라이브</li><li>FreqAI (여기서는 다루지 않음)</li></ul>`,23)),n("p",null,[s[5]||(s[5]=a(" 봇을 드라이 모드 또는 라이브 모드로 설정하는 방법에 대한 자세한 내용은 ")),l(p,{to:"configuration"},{default:c(()=>s[4]||(s[4]=[a(" 구성 문서 ")])),_:1}),s[6]||(s[6]=a(" 를 확인하세요. "))]),s[70]||(s[70]=e('<p><strong> 항상 드라이 모드를 사용하여 테스트하세요. 이는 자본을 위험에 빠뜨리지 않고 전략이 실제로 어떻게 작동할지에 대한 아이디어를 제공합니다. </strong></p><h2 id="diving-in-deeper"> 더 깊이 들어가기 <a class="headerlink" href="#diving-in-deeper" title="영구 링크"> ¶ </a></h2><p><strong> 다음 섹션에서는 <a href="https://github.com/freqtrade/freqtrade/blob/develop/freqtrade/templates/sample_strategy.py"> user_data/strategies/sample_strategy.py </a> 파일을 참조로 사용합니다. </strong></p><div class="admonition note"><p class="admonition-title">전략 및 백테스팅</p><p> 백테스팅과 드라이/라이브 모드 간의 문제와 예상치 못한 차이를 피하기 위해, 백테스팅 중에는 전체 시간 범위가 <code> populate_*() </code> 메서드에 한 번에 전달된다는 점을 유의하세요. 따라서 데이터프레임 전체에 걸쳐 벡터화된 연산(루프가 아닌)을 사용하는 것이 좋으며, 인덱스 참조( <code> df.iloc[-1] </code> )를 피하고 대신 <code> df.shift() </code> 를 사용하여 이전 캔들로 이동하세요. </p></div><div class="admonition warning"><p class="admonition-title">경고: 미래 데이터 사용</p><p> 백테스팅은 전체 시간 범위를 <code> populate_*() </code> 메서드에 전달하므로, 전략 작성자는 전략이 미래의 데이터를 사용하지 않도록 주의해야 합니다. 이러한 일반적인 패턴은 이 문서의 <a href="#common-mistakes-when-developing-strategies"> 일반적인 실수 </a> 섹션에 나열되어 있습니다. </p></div>',5)),n("details",d,[s[12]||(s[12]=n("summary",null,"Lookahead 및 재귀 분석",-1)),n("p",null,[s[9]||(s[9]=a(" Freqtrade에는 일반적인 lookahead(미래 데이터 사용) 및 재귀 바이어스(지표 값의 분산) 문제를 평가하는 데 도움이 되는 두 가지 유용한 명령어가 포함되어 있습니다. 전략을 드라이 또는 라이브 모드로 실행하기 전에 항상 이 명령어를 먼저 사용해야 합니다. 자세한 내용은 관련 문서를 확인하세요. ")),l(p,{to:"lookahead-analysis"},{default:c(()=>s[7]||(s[7]=[a(" lookahead ")])),_:1}),s[10]||(s[10]=a(" 및 ")),l(p,{to:"recursive-analysis"},{default:c(()=>s[8]||(s[8]=[a(" 재귀 ")])),_:1}),s[11]||(s[11]=a(" 분석. "))])]),s[71]||(s[71]=e(`<h3 id="dataframe"> 데이터프레임 <a class="headerlink" href="#dataframe" title="영구 링크"> ¶ </a></h3><p> Freqtrade는 캔들스틱(OHLCV) 데이터를 저장/제공하기 위해 <a href="https://pandas.pydata.org/"> pandas </a> 를 사용합니다. Pandas는 표 형식의 대량 데이터를 처리하기 위해 개발된 훌륭한 라이브러리입니다. </p><p>데이터프레임의 각 행은 차트의 하나의 캔들에 해당하며, 최신 완료된 캔들은 항상 데이터프레임의 마지막에 위치합니다(날짜별로 정렬됨).</p><p> Pandas <code> head() </code> 함수를 사용하여 주요 데이터프레임의 처음 몇 행을 살펴보면 다음과 같습니다: </p><div class="highlight"><pre><code><span class="go">&gt; dataframe.head()</span>
<span class="go">                       date      open      high       low     close     volume</span>
<span class="go">0 2021-11-09 23:25:00+00:00  67279.67  67321.84  67255.01  67300.97   44.62253</span>
<span class="go">1 2021-11-09 23:30:00+00:00  67300.97  67301.34  67183.03  67187.01   61.38076</span>
<span class="go">2 2021-11-09 23:35:00+00:00  67187.02  67187.02  67031.93  67123.81  113.42728</span>
<span class="go">3 2021-11-09 23:40:00+00:00  67123.80  67222.40  67080.33  67160.48   78.96008</span>
<span class="go">4 2021-11-09 23:45:00+00:00  67160.48  67160.48  66901.26  66943.37  111.39292</span>
</code></pre></div><p>데이터프레임은 열이 단일 값이 아닌 일련의 데이터 값인 테이블입니다. 따라서 다음과 같은 간단한 파이썬 비교는 작동하지 않습니다:</p><div class="highlight"><pre><code>    <span class="k">if</span> <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;rsi&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">30</span><span class="p">:</span>
        <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;enter_long&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div><p> 위의 섹션은 <code> The truth value of a Series is ambiguous [...] </code> 오류와 함께 실패할 것입니다. </p><p> 이 대신, 연산이 전체 데이터프레임에 걸쳐 수행되도록 pandas 호환 방식으로 작성해야 합니다, 즉 <code> 벡터화 </code> . </p><div class="highlight"><pre><code>    <span class="n">dataframe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
        <span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;rsi&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">30</span><span class="p">)</span>
    <span class="p">,</span> <span class="s1">&#39;enter_long&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div><p> 이 섹션을 통해 데이터프레임에 새로운 열이 추가되며, RSI가 30 이상일 때마다 <code> 1 </code> 이 할당됩니다. </p><p>Freqtrade는 이 새로운 열을 진입 신호로 사용하며, 거래는 다음 오픈 캔들에서 열릴 것으로 가정합니다.</p><p>Pandas는 지표를 계산하는 빠른 방법을 제공하며, 즉 &quot;벡터화&quot;입니다. 이 속도를 활용하려면 루프를 사용하지 말고 벡터화된 메서드를 사용하는 것이 좋습니다.</p><p>벡터화된 연산은 데이터의 전체 범위에 걸쳐 계산을 수행하므로, 각 행을 반복하는 것보다 지표를 계산할 때 훨씬 빠릅니다.</p><details class="hint"><summary>신호와 거래</summary><ul><li>신호는 캔들 종료 시 지표에서 생성되며, 거래 진입 의도를 나타냅니다.</li><li>거래는 주문이 실행된 후(라이브 모드에서 거래소에서) 다음 캔들 오픈에 최대한 가깝게 열립니다.</li></ul></details><div class="admonition warning"><p class="admonition-title">거래 주문 가정</p><p>백테스팅에서는 신호가 캔들 종료 시 생성됩니다. 거래는 다음 캔들 오픈에서 즉시 시작됩니다.</p><p>드라이 및 라이브 모드에서는 모든 페어 데이터프레임을 먼저 분석해야 하므로 지연될 수 있습니다. 그런 다음 각 페어에 대한 거래 처리가 이루어집니다. 따라서 드라이/라이브 모드에서는 가능한 한 낮은 계산 지연을 유지해야 하며, 일반적으로 적은 수의 페어를 실행하고 클럭 속도가 좋은 CPU를 사용하는 것이 좋습니다.</p></div><h4 id="why-cant-i-see-real-time-candle-data"> &quot;실시간&quot; 캔들 데이터를 볼 수 없는 이유는 무엇인가요? <a class="headerlink" href="#why-cant-i-see-real-time-candle-data" title="영구 링크"> ¶ </a></h4><p>Freqtrade는 완료되지 않은/미완성 캔들을 데이터프레임에 저장하지 않습니다.</p><p>전략 결정을 내리기 위해 미완성 데이터를 사용하는 것을 &quot;리페인팅&quot;이라고 하며, 다른 플랫폼에서는 이를 허용할 수 있습니다.</p><p>Freqtrade는 이를 허용하지 않습니다. 데이터프레임에는 완료된/완성된 캔들 데이터만 포함됩니다.</p><h3 id="customize-indicators"> 지표 커스터마이징 <a class="headerlink" href="#customize-indicators" title="영구 링크"> ¶ </a></h3><p> 진입 및 청산 신호에는 지표가 필요합니다. 전략 파일의 <code> populate_indicators() </code> 메서드에 포함된 목록을 확장하여 더 많은 지표를 추가할 수 있습니다. </p><p><code> populate_entry_trend() </code> , <code> populate_exit_trend() </code> 또는 다른 지표를 채우기 위해 사용되지 않는 지표는 추가하지 않는 것이 좋습니다. 그렇지 않으면 성능이 저하될 수 있습니다. </p><p> 이 세 가지 함수에서 데이터프레임을 반환할 때 <code> &quot;open&quot;, &quot;high&quot;, &quot;low&quot;, &quot;close&quot;, &quot;volume&quot; </code> 열을 제거하거나 수정하지 않는 것이 중요합니다. 그렇지 않으면 이러한 필드에 예상치 못한 값이 포함될 수 있습니다. </p><p>샘플:</p><div class="highlight"><pre><code><span class="k">def</span><span class="w"> </span><span class="nf">populate_indicators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">metadata</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds several different TA indicators to the given DataFrame</span>

<span class="sd">    Performance Note: For the best performance be frugal on the number of indicators</span>
<span class="sd">    you are using. Let uncomment only the indicator you are using in your strategies</span>
<span class="sd">    or your hyperopt configuration, otherwise you will waste your memory and CPU usage.</span>
<span class="sd">    :param dataframe: Dataframe with data from the exchange</span>
<span class="sd">    :param metadata: Additional information, like the currently traded pair</span>
<span class="sd">    :return: a Dataframe with all mandatory indicators for the strategies</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;sar&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">SAR</span><span class="p">(</span><span class="n">dataframe</span><span class="p">)</span>
    <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;adx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">ADX</span><span class="p">(</span><span class="n">dataframe</span><span class="p">)</span>
    <span class="n">stoch</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">STOCHF</span><span class="p">(</span><span class="n">dataframe</span><span class="p">)</span>
    <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;fastd&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stoch</span><span class="p">[</span><span class="s1">&#39;fastd&#39;</span><span class="p">]</span>
    <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;fastk&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stoch</span><span class="p">[</span><span class="s1">&#39;fastk&#39;</span><span class="p">]</span>
    <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;bb_lower&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">BBANDS</span><span class="p">(</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">nbdevup</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">nbdevdn</span><span class="o">=</span><span class="mi">2</span><span class="p">)[</span><span class="s1">&#39;lowerband&#39;</span><span class="p">]</span>
    <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;sma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">SMA</span><span class="p">(</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">timeperiod</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>
    <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;tema&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">TEMA</span><span class="p">(</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">timeperiod</span><span class="o">=</span><span class="mi">9</span><span class="p">)</span>
    <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;mfi&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">MFI</span><span class="p">(</span><span class="n">dataframe</span><span class="p">)</span>
    <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;rsi&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">RSI</span><span class="p">(</span><span class="n">dataframe</span><span class="p">)</span>
    <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;ema5&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">EMA</span><span class="p">(</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">timeperiod</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;ema10&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">EMA</span><span class="p">(</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">timeperiod</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;ema50&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">EMA</span><span class="p">(</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">timeperiod</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
    <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;ema100&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">EMA</span><span class="p">(</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">timeperiod</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
    <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;ao&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">awesome_oscillator</span><span class="p">(</span><span class="n">dataframe</span><span class="p">)</span>
    <span class="n">macd</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">MACD</span><span class="p">(</span><span class="n">dataframe</span><span class="p">)</span>
    <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;macd&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">macd</span><span class="p">[</span><span class="s1">&#39;macd&#39;</span><span class="p">]</span>
    <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;macdsignal&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">macd</span><span class="p">[</span><span class="s1">&#39;macdsignal&#39;</span><span class="p">]</span>
    <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;macdhist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">macd</span><span class="p">[</span><span class="s1">&#39;macdhist&#39;</span><span class="p">]</span>
    <span class="n">hilbert</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">HT_SINE</span><span class="p">(</span><span class="n">dataframe</span><span class="p">)</span>
    <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;htsine&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hilbert</span><span class="p">[</span><span class="s1">&#39;sine&#39;</span><span class="p">]</span>
    <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;htleadsine&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hilbert</span><span class="p">[</span><span class="s1">&#39;leadsine&#39;</span><span class="p">]</span>
    <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;plus_dm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">PLUS_DM</span><span class="p">(</span><span class="n">dataframe</span><span class="p">)</span>
    <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;plus_di&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">PLUS_DI</span><span class="p">(</span><span class="n">dataframe</span><span class="p">)</span>
    <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;minus_dm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">MINUS_DM</span><span class="p">(</span><span class="n">dataframe</span><span class="p">)</span>
    <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;minus_di&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">MINUS_DI</span><span class="p">(</span><span class="n">dataframe</span><span class="p">)</span>

    <span class="c1"># remember to always return the dataframe</span>
    <span class="k">return</span> <span class="n">dataframe</span>
</code></pre></div><div class="admonition note"><p class="admonition-title">더 많은 지표 예제가 필요하신가요?</p><p><a href="https://github.com/freqtrade/freqtrade/blob/develop/freqtrade/templates/sample_strategy.py"> user_data/strategies/sample_strategy.py </a> 를 확인하세요. 필요한 지표를 주석 해제하세요. </p></div><h4 id="indicator-libraries"> 지표 라이브러리 <a class="headerlink" href="#indicator-libraries" title="영구 링크"> ¶ </a></h4><p>기본적으로 freqtrade는 다음 기술 라이브러리를 설치합니다:</p><ul><li><a href="https://ta-lib.github.io/ta-lib-python/"> ta-lib </a></li><li><a href="https://twopirllc.github.io/pandas-ta/"> pandas-ta </a></li><li><a href="https://technical.freqtrade.io"> technical </a></li></ul><p>필요에 따라 추가 기술 라이브러리를 설치하거나 전략 작성자가 작성/발명한 사용자 정의 지표를 사용할 수 있습니다.</p><h3 id="strategy-startup-period"> 전략 시작 기간 <a class="headerlink" href="#strategy-startup-period" title="영구 링크"> ¶ </a></h3><p>일부 지표는 불안정한 시작 기간이 있으며, 이 기간 동안 충분한 캔들 데이터가 없어 값을 계산할 수 없거나 계산이 잘못될 수 있습니다. 이는 일관성 문제를 일으킬 수 있으며, Freqtrade는 이 불안정한 기간이 얼마나 되는지 알 수 없으므로 데이터프레임에 있는 지표 값을 사용합니다.</p><p> 이를 해결하기 위해 전략에 <code> startup_candle_count </code> 속성을 할당할 수 있습니다. </p><p> 이 값은 안정적인 지표를 계산하는 데 필요한 최대 캔들 수로 설정해야 합니다. 사용자가 정보 제공 페어와 함께 더 높은 시간 프레임을 포함하는 경우, <code> startup_candle_count </code> 는 반드시 변경되지 않습니다. 이 값은 안정적인 지표를 계산하는 데 필요한 최대 기간(캔들 수)입니다. </p>`,35)),n("p",null,[l(p,{to:"recursive-analysis"},{default:c(()=>s[13]||(s[13]=[a(" recursive-analysis ")])),_:1}),s[14]||(s[14]=a(" 를 사용하여 사용할 ")),s[15]||(s[15]=n("code",null," startup_candle_count ",-1)),s[16]||(s[16]=a(" 를 확인할 수 있습니다. 재귀 분석이 0%의 분산을 보여줄 때, 충분한 시작 캔들 데이터를 가지고 있음을 확신할 수 있습니다. "))]),s[72]||(s[72]=e(`<p> 이 예제 전략에서는 <code> startup_candle_count = 400 </code> 으로 설정해야 합니다. 이는 ema100 계산을 위해 필요한 최소 히스토리가 400 캔들이기 때문입니다. </p><div class="highlight"><pre><code>    <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;ema100&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">EMA</span><span class="p">(</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">timeperiod</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
</code></pre></div><p>봇이 필요한 히스토리를 알 수 있도록 하면, 백테스트 거래는 백테스팅 및 하이퍼옵트 중에 지정된 시간 범위에서 시작할 수 있습니다.</p><div class="admonition warning"><p class="admonition-title">x 호출을 사용하여 OHLCV 가져오기</p><p> 다음과 같은 경고를 받으면 <code> WARNING - Using 3 calls to get OHLCV. This can result in slower operations for the bot. Please check if you really need 1500 candles for your strategy </code> - 신호에 정말로 이 많은 히스토리 데이터를 필요로 하는지 고려해야 합니다. 이렇게 하면 Freqtrade가 동일한 페어에 대해 여러 번 호출하게 되어 하나의 네트워크 요청보다 당연히 느려집니다. 결과적으로 Freqtrade는 캔들을 새로 고치는 데 더 오래 걸리므로 가능한 한 피해야 합니다. 이는 거래소를 과부하시키거나 Freqtrade를 너무 느리게 만드는 것을 방지하기 위해 총 5번의 호출로 제한됩니다. </p></div><div class="admonition warning"><p class="admonition-title">경고</p><p><code> startup_candle_count </code> 는 <code> ohlcv_candle_limit * 5 </code> (대부분의 거래소에서 500 * 5) 이하로 설정해야 합니다. 이는 드라이런/라이브 거래 작업 중에 이 양의 캔들만 사용할 수 있기 때문입니다. </p></div><h4 id="example"> 예제 <a class="headerlink" href="#example" title="영구 링크"> ¶ </a></h4><p>EMA100을 사용하는 예제 전략을 사용하여 5m 캔들의 1개월(2019년 1월)을 백테스트해 보겠습니다.</p><div class="highlight"><pre><code>freqtrade backtesting --timerange 20190101-20190201 --timeframe 5m
</code></pre></div><p><code> startup_candle_count </code> 가 400으로 설정되어 있다고 가정하면, 백테스팅은 유효한 진입 신호를 생성하기 위해 400개의 캔들이 필요하다는 것을 알고 있습니다. 데이터는 <code> 20190101 - (400 * 5m) </code> 에서 로드됩니다. 이는 약 2018-12-30 11:40:00입니다. </p><p>이 데이터가 사용 가능하면, 지표는 이 확장된 시간 범위로 계산됩니다. 불안정한 시작 기간(2019-01-01 00:00:00까지)은 백테스팅이 수행되기 전에 제거됩니다.</p><div class="admonition note"><p class="admonition-title">사용할 수 없는 시작 캔들 데이터</p><p>시작 기간의 데이터가 사용 가능하지 않은 경우, 시간 범위는 이 시작 기간을 고려하여 조정됩니다. 예를 들어, 백테스팅은 2019-01-02 09:20:00부터 시작됩니다.</p></div><h3 id="entry-signal-rules"> 진입 신호 규칙 <a class="headerlink" href="#entry-signal-rules" title="영구 링크"> ¶ </a></h3><p> 전략 파일의 <code> populate_entry_trend() </code> 메서드를 편집하여 진입 전략을 업데이트하세요. </p><p> 데이터프레임을 반환할 때 <code> &quot;open&quot;, &quot;high&quot;, &quot;low&quot;, &quot;close&quot;, &quot;volume&quot; </code> 열을 제거하거나 수정하지 않는 것이 중요합니다. 그렇지 않으면 이러한 필드에 예상치 못한 값이 포함될 수 있습니다. 전략이 잘못된 값을 생성하거나 완전히 작동하지 않을 수 있습니다. </p><p> 이 메서드는 또한 새로운 열 <code> &quot;enter_long&quot; </code> ( <code> &quot;enter_short&quot; </code> 는 숏에 해당)을 정의해야 하며, 진입 시 <code> 1 </code> 을, &quot;아무 작업도 하지 않음&quot; 시 <code> 0 </code> 을 포함해야 합니다. <code> enter_long </code> 은 필수 열이며 전략이 숏 전용인 경우에도 설정해야 합니다. </p><p> 진입 신호를 <code> &quot;enter_tag&quot; </code> 열을 사용하여 이름을 지정할 수 있으며, 이는 나중에 전략을 디버그하고 평가하는 데 도움이 됩니다. </p><p><code> user_data/strategies/sample_strategy.py </code> 에서 가져온 샘플: </p><div class="highlight"><pre><code><span class="k">def</span><span class="w"> </span><span class="nf">populate_entry_trend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">metadata</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Based on TA indicators, populates the buy signal for the given dataframe</span>
<span class="sd">    :param dataframe: DataFrame populated with indicators</span>
<span class="sd">    :param metadata: Additional information, like the currently traded pair</span>
<span class="sd">    :return: DataFrame with buy column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dataframe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
        <span class="p">(</span>
            <span class="p">(</span><span class="n">qtpylib</span><span class="o">.</span><span class="n">crossed_above</span><span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;rsi&#39;</span><span class="p">],</span> <span class="mi">30</span><span class="p">))</span> <span class="o">&amp;</span>  <span class="c1"># Signal: RSI crosses above 30</span>
            <span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;tema&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;bb_middleband&#39;</span><span class="p">])</span> <span class="o">&amp;</span>  <span class="c1"># Guard</span>
            <span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;tema&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;tema&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span>  <span class="c1"># Guard</span>
            <span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;volume&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># Make sure Volume is not 0</span>
        <span class="p">),</span>
        <span class="p">[</span><span class="s1">&#39;enter_long&#39;</span><span class="p">,</span> <span class="s1">&#39;enter_tag&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;rsi_cross&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dataframe</span>
</code></pre></div><details class="note"><summary>숏 거래 진입</summary><p> 숏 진입은 <code> enter_short </code> 를 설정하여 생성할 수 있습니다(롱 거래의 <code> enter_long </code> 에 해당). 열 <code> enter_tag </code> 는 동일하게 유지됩니다. 숏 거래는 거래소 및 시장 구성에서 지원되어야 합니다! 또한 숏을 하려는 경우 전략에서 <a href="#can-short"><code> can_short </code></a> 을 적절히 설정해야 합니다. </p><div class="highlight"><pre><code><span class="c1"># 롱 및 숏 거래 모두 허용</span>
<span class="n">can_short</span> <span class="o">=</span> <span class="kc">True</span>

<span class="k">def</span><span class="w"> </span><span class="nf">populate_entry_trend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">metadata</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
    <span class="n">dataframe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
        <span class="p">(</span>
            <span class="p">(</span><span class="n">qtpylib</span><span class="o">.</span><span class="n">crossed_above</span><span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;rsi&#39;</span><span class="p">],</span> <span class="mi">30</span><span class="p">))</span> <span class="o">&amp;</span>  <span class="c1"># Signal: RSI crosses above 30</span>
            <span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;tema&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;bb_middleband&#39;</span><span class="p">])</span> <span class="o">&amp;</span>  <span class="c1"># Guard</span>
            <span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;tema&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;tema&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span>  <span class="c1"># Guard</span>
            <span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;volume&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># Make sure Volume is not 0</span>
        <span class="p">),</span>
        <span class="p">[</span><span class="s1">&#39;enter_long&#39;</span><span class="p">,</span> <span class="s1">&#39;enter_tag&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;rsi_cross&#39;</span><span class="p">)</span>

    <span class="n">dataframe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
        <span class="p">(</span>
            <span class="p">(</span><span class="n">qtpylib</span><span class="o">.</span><span class="n">crossed_below</span><span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;rsi&#39;</span><span class="p">],</span> <span class="mi">70</span><span class="p">))</span> <span class="o">&amp;</span>  <span class="c1"># Signal: RSI crosses below 70</span>
            <span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;tema&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;bb_middleband&#39;</span><span class="p">])</span> <span class="o">&amp;</span>  <span class="c1"># Guard</span>
            <span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;tema&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;tema&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span>  <span class="c1"># Guard</span>
            <span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;volume&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># Make sure Volume is not 0</span>
        <span class="p">),</span>
        <span class="p">[</span><span class="s1">&#39;enter_short&#39;</span><span class="p">,</span> <span class="s1">&#39;enter_tag&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;rsi_cross&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dataframe</span>
</code></pre></div></details><div class="admonition note"><p class="admonition-title">참고</p><p> 구매하려면 판매자가 필요합니다. 따라서 거래량이 0이 아닌지 확인해야 합니다( <code> dataframe[&#39;volume&#39;] &gt; 0 </code> ) 봇이 활동이 없는 기간에 매수/매도하지 않도록 합니다. </p></div><h3 id="exit-signal-rules"> 청산 신호 규칙 <a class="headerlink" href="#exit-signal-rules" title="영구 링크"> ¶ </a></h3><p> 전략 파일의 <code> populate_exit_trend() </code> 메서드를 편집하여 청산 전략을 업데이트하세요. </p><p> 청산 신호는 구성 또는 전략에서 <code> use_exit_signal </code> 을 false로 설정하여 억제할 수 있습니다. </p><p><code> use_exit_signal </code> 은 <a href="#colliding-signals"> 신호 충돌 규칙 </a> 에 영향을 미치지 않으며, 여전히 적용되어 진입을 방지할 수 있습니다. </p><p> 데이터프레임을 반환할 때 <code> &quot;open&quot;, &quot;high&quot;, &quot;low&quot;, &quot;close&quot;, &quot;volume&quot; </code> 열을 제거하거나 수정하지 않는 것이 중요합니다. 그렇지 않으면 이러한 필드에 예상치 못한 값이 포함될 수 있습니다. 전략이 잘못된 값을 생성하거나 완전히 작동하지 않을 수 있습니다. </p><p> 이 메서드는 또한 새로운 열 <code> &quot;exit_long&quot; </code> ( <code> &quot;exit_short&quot; </code> 는 숏에 해당)을 정의해야 하며, 청산 시 <code> 1 </code> 을, &quot;아무 작업도 하지 않음&quot; 시 <code> 0 </code> 을 포함해야 합니다. </p><p> 청산 신호를 <code> &quot;exit_tag&quot; </code> 열을 사용하여 이름을 지정할 수 있으며, 이는 나중에 전략을 디버그하고 평가하는 데 도움이 됩니다. </p><p><code> user_data/strategies/sample_strategy.py </code> 에서 가져온 샘플: </p><div class="highlight"><pre><code><span class="k">def</span><span class="w"> </span><span class="nf">populate_exit_trend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">metadata</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Based on TA indicators, populates the exit signal for the given dataframe</span>
<span class="sd">    :param dataframe: DataFrame populated with indicators</span>
<span class="sd">    :param metadata: Additional information, like the currently traded pair</span>
<span class="sd">    :return: DataFrame with buy column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dataframe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
        <span class="p">(</span>
            <span class="p">(</span><span class="n">qtpylib</span><span class="o">.</span><span class="n">crossed_above</span><span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;rsi&#39;</span><span class="p">],</span> <span class="mi">70</span><span class="p">))</span> <span class="o">&amp;</span>  <span class="c1"># Signal: RSI crosses above 70</span>
            <span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;tema&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;bb_middleband&#39;</span><span class="p">])</span> <span class="o">&amp;</span>  <span class="c1"># Guard</span>
            <span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;tema&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;tema&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span>  <span class="c1"># Guard</span>
            <span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;volume&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># Make sure Volume is not 0</span>
        <span class="p">),</span>
        <span class="p">[</span><span class="s1">&#39;exit_long&#39;</span><span class="p">,</span> <span class="s1">&#39;exit_tag&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;rsi_too_high&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dataframe</span>
</code></pre></div><details class="note"><summary>숏 거래 청산</summary><p> 숏 청산은 <code> exit_short </code> 를 설정하여 생성할 수 있습니다(롱 거래의 <code> exit_long </code> 에 해당). 열 <code> exit_tag </code> 는 동일하게 유지됩니다. 숏 거래는 거래소 및 시장 구성에서 지원되어야 합니다! 또한 숏을 하려는 경우 전략에서 <a href="#can-short"><code> can_short </code></a> 을 적절히 설정해야 합니다. </p><div class="highlight"><pre><code><span class="c1"># 롱 및 숏 거래 모두 허용</span>
<span class="n">can_short</span> <span class="o">=</span> <span class="kc">True</span>

<span class="k">def</span><span class="w"> </span><span class="nf">populate_exit_trend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">metadata</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
    <span class="n">dataframe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
        <span class="p">(</span>
            <span class="p">(</span><span class="n">qtpylib</span><span class="o">.</span><span class="n">crossed_above</span><span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;rsi&#39;</span><span class="p">],</span> <span class="mi">70</span><span class="p">))</span> <span class="o">&amp;</span>  <span class="c1"># Signal: RSI crosses above 70</span>
            <span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;tema&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;bb_middleband&#39;</span><span class="p">])</span> <span class="o">&amp;</span>  <span class="c1"># Guard</span>
            <span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;tema&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;tema&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span>  <span class="c1"># Guard</span>
            <span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;volume&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># Make sure Volume is not 0</span>
        <span class="p">),</span>
        <span class="p">[</span><span class="s1">&#39;exit_long&#39;</span><span class="p">,</span> <span class="s1">&#39;exit_tag&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;rsi_too_high&#39;</span><span class="p">)</span>
    <span class="n">dataframe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
        <span class="p">(</span>
            <span class="p">(</span><span class="n">qtpylib</span><span class="o">.</span><span class="n">crossed_below</span><span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;rsi&#39;</span><span class="p">],</span> <span class="mi">30</span><span class="p">))</span> <span class="o">&amp;</span>  <span class="c1"># Signal: RSI crosses below 30</span>
            <span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;tema&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;bb_middleband&#39;</span><span class="p">])</span> <span class="o">&amp;</span>  <span class="c1"># Guard</span>
            <span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;tema&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;tema&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span>  <span class="c1"># Guard</span>
            <span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;volume&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># Make sure Volume is not 0</span>
        <span class="p">),</span>
        <span class="p">[</span><span class="s1">&#39;exit_short&#39;</span><span class="p">,</span> <span class="s1">&#39;exit_tag&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;rsi_too_low&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dataframe</span>
</code></pre></div></details><h3 id="minimal-roi"> 최소 ROI <a class="headerlink" href="#minimal-roi" title="영구 링크"> ¶ </a></h3><p><code> minimal_roi </code> 전략 변수는 청산 신호와 관계없이 거래가 청산되기 전에 도달해야 하는 최소 수익률(ROI)을 정의합니다. </p><p> 이는 다음 형식의 파이썬 <code> dict </code> 로, dict 키(콜론의 왼쪽)는 거래가 열린 후 경과된 분을 나타내며, 값(콜론의 오른쪽)은 백분율입니다. </p><div class="highlight"><pre><code><span class="n">minimal_roi</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;40&quot;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="s2">&quot;30&quot;</span><span class="p">:</span> <span class="mf">0.01</span><span class="p">,</span>
    <span class="s2">&quot;20&quot;</span><span class="p">:</span> <span class="mf">0.02</span><span class="p">,</span>
    <span class="s2">&quot;0&quot;</span><span class="p">:</span> <span class="mf">0.04</span>
<span class="p">}</span>
</code></pre></div><p>위의 구성은 다음을 의미합니다:</p><ul><li>4% 수익이 도달하면 청산</li><li>2% 수익이 도달하면 청산(20분 후 적용)</li><li>1% 수익이 도달하면 청산(30분 후 적용)</li><li>손실이 없는 거래일 때 청산(40분 후 적용)</li></ul><p>계산에는 수수료가 포함됩니다.</p><h4 id="disabling-minimal-roi"> 최소 ROI 비활성화 <a class="headerlink" href="#disabling-minimal-roi" title="영구 링크"> ¶ </a></h4><p>ROI를 완전히 비활성화하려면 빈 사전으로 설정하세요:</p><div class="highlight"><pre><code><span class="n">minimal_roi</span> <span class="o">=</span> <span class="p">{}</span>
</code></pre></div><h4 id="using-calculations-in-minimal-roi"> 최소 ROI에서 계산 사용 <a class="headerlink" href="#using-calculations-in-minimal-roi" title="영구 링크"> ¶ </a></h4><p>캔들 기간(시간 프레임)을 기준으로 시간을 사용하려면 다음 스니펫이 유용할 수 있습니다.</p><p>이를 통해 전략의 시간 프레임을 변경할 수 있지만, 최소 ROI 시간은 여전히 캔들로 설정됩니다. 예를 들어 3개의 캔들 후에.</p><div class="highlight"><pre><code><span class="kn">from</span><span class="w"> </span><span class="nn">freqtrade.exchange</span><span class="w"> </span><span class="kn">import</span> <span class="n">timeframe_to_minutes</span>

<span class="k">class</span><span class="w"> </span><span class="nc">AwesomeStrategy</span><span class="p">(</span><span class="n">IStrategy</span><span class="p">):</span>

    <span class="n">timeframe</span> <span class="o">=</span> <span class="s2">&quot;1d&quot;</span>
    <span class="n">timeframe_mins</span> <span class="o">=</span> <span class="n">timeframe_to_minutes</span><span class="p">(</span><span class="n">timeframe</span><span class="p">)</span>
    <span class="n">minimal_roi</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;0&quot;</span><span class="p">:</span> <span class="mf">0.05</span><span class="p">,</span>                      <span class="c1"># 5% for the first 3 candles</span>
        <span class="nb">str</span><span class="p">(</span><span class="n">timeframe_mins</span> <span class="o">*</span> <span class="mi">3</span><span class="p">):</span> <span class="mf">0.02</span><span class="p">,</span>  <span class="c1"># 2% after 3 candles</span>
        <span class="nb">str</span><span class="p">(</span><span class="n">timeframe_mins</span> <span class="o">*</span> <span class="mi">6</span><span class="p">):</span> <span class="mf">0.01</span><span class="p">,</span>  <span class="c1"># 1% After 6 candles</span>
    <span class="p">}</span>
</code></pre></div><details class="info"><summary>즉시 채워지지 않는 주문</summary><p><code> minimal_roi </code> 는 참조로 <code> trade.open_date </code> 를 사용하며, 이는 거래가 시작된 시간, 즉 이 거래에 대한 첫 번째 주문이 배치된 시간입니다. 이는 즉시 채워지지 않는 제한 주문(일반적으로 <code> custom_entry_price() </code> 를 통해 &quot;오프 스팟&quot; 가격과 함께) 및 <code> adjust_entry_price() </code> 를 통해 초기 주문 가격이 교체된 경우에도 적용됩니다. 사용된 시간은 여전히 초기 <code> trade.open_date </code> (초기 주문이 처음 배치된 시간)에서 가져오며, 새로 배치되거나 조정된 주문 날짜가 아닙니다. </p></details><h3 id="stoploss"> 손절매 <a class="headerlink" href="#stoploss" title="영구 링크"> ¶ </a></h3><p>손절매를 설정하는 것은 자본을 강한 반대 움직임으로부터 보호하기 위해 매우 권장됩니다.</p><p>10% 손절매 설정 예제:</p><div class="highlight"><pre><code><span class="n">stoploss</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.10</span>
</code></pre></div>`,49)),n("p",null,[s[18]||(s[18]=a(" 손절매 기능에 대한 전체 문서는 전용 ")),l(p,{to:"stoploss"},{default:c(()=>s[17]||(s[17]=[a(" 손절매 페이지 ")])),_:1}),s[19]||(s[19]=a(" 를 참조하세요. "))]),s[73]||(s[73]=e('<h3 id="timeframe"> 시간 프레임 <a class="headerlink" href="#timeframe" title="영구 링크"> ¶ </a></h3><p>이는 전략에서 봇이 사용할 캔들의 주기입니다.</p><p> 일반적인 값은 <code> &quot;1m&quot; </code> , <code> &quot;5m&quot; </code> , <code> &quot;15m&quot; </code> , <code> &quot;1h&quot; </code> 이지만, 거래소에서 지원하는 모든 값이 작동해야 합니다. </p><p>동일한 진입/청산 신호가 하나의 시간 프레임에서는 잘 작동하지만 다른 시간 프레임에서는 그렇지 않을 수 있습니다.</p><p> 이 설정은 전략 메서드 내에서 <code> self.timeframe </code> 속성으로 접근할 수 있습니다. </p><h3 id="can-short"> 숏 가능 <a class="headerlink" href="#can-short" title="영구 링크"> ¶ </a></h3><p> 선물 시장에서 숏 신호를 사용하려면 <code> can_short = True </code> 로 설정해야 합니다. </p><p>이를 활성화한 전략은 현물 시장에서 로드되지 않습니다.</p><p><code> enter_short </code> 열에 <code> 1 </code> 값이 있는 경우, 숏 신호를 무시하려면 <code> can_short = False </code> (기본값)로 설정하세요. 이는 선물 시장에서 지정된 경우에도 적용됩니다. </p><h3 id="metadata-dict"> 메타데이터 사전 <a class="headerlink" href="#metadata-dict" title="영구 링크"> ¶ </a></h3><p><code> metadata </code> 사전( <code> populate_entry_trend </code> , <code> populate_exit_trend </code> , <code> populate_indicators </code> 에서 사용 가능)에는 추가 정보가 포함되어 있습니다. 현재는 <code> pair </code> 가 포함되어 있으며, <code> metadata[&#39;pair&#39;] </code> 를 사용하여 접근할 수 있으며, <code> XRP/BTC </code> 형식의 페어를 반환합니다(선물 시장의 경우 <code> XRP/BTC:BTC </code> ). </p><p>메타데이터 사전은 수정하지 말고, 전략의 여러 함수에 걸쳐 정보를 지속시키지 않습니다.</p>',12)),n("p",null,[s[21]||(s[21]=a(" 대신, ")),l(p,{to:"strategy-advanced"},{default:c(()=>s[20]||(s[20]=[a(" 정보 저장 ")])),_:1}),s[22]||(s[22]=a(" 섹션을 확인하세요. "))]),s[74]||(s[74]=e(`<h2 id="imports-necessary-for-a-strategy"> 전략에 필요한 가져오기 <a class="headerlink" href="#imports-necessary-for-a-strategy" title="영구 링크"> ¶ </a></h2><p>전략을 작성할 때 필요한 모듈과 클래스를 가져와야 합니다. 전략에 필요한 가져오기는 다음과 같습니다:</p><p>기본적으로, 전략을 위한 기본 라인으로 다음 가져오기를 권장합니다: 이는 freqtrade 기능이 작동하는 데 필요한 모든 가져오기를 포함합니다. 물론 전략에 필요한 추가 가져오기를 추가할 수 있습니다.</p><div class="highlight"><pre><code><span class="c1"># flake8: noqa: F401</span>
<span class="c1"># isort: skip_file</span>
<span class="c1"># --- Do not remove these imports ---</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timedelta</span><span class="p">,</span> <span class="n">timezone</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="kn">import</span> <span class="n">DataFrame</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">freqtrade.strategy</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">IStrategy</span><span class="p">,</span>
    <span class="n">Trade</span><span class="p">,</span> 
    <span class="n">Order</span><span class="p">,</span>
    <span class="n">PairLocks</span><span class="p">,</span>
    <span class="n">informative</span><span class="p">,</span>  <span class="c1"># @informative decorator</span>
    <span class="c1"># Hyperopt Parameters</span>
    <span class="n">BooleanParameter</span><span class="p">,</span>
    <span class="n">CategoricalParameter</span><span class="p">,</span>
    <span class="n">DecimalParameter</span><span class="p">,</span>
    <span class="n">IntParameter</span><span class="p">,</span>
    <span class="n">RealParameter</span><span class="p">,</span>
    <span class="c1"># timeframe helpers</span>
    <span class="n">timeframe_to_minutes</span><span class="p">,</span>
    <span class="n">timeframe_to_next_date</span><span class="p">,</span>
    <span class="n">timeframe_to_prev_date</span><span class="p">,</span>
    <span class="c1"># Strategy helper functions</span>
    <span class="n">merge_informative_pair</span><span class="p">,</span>
    <span class="n">stoploss_from_absolute</span><span class="p">,</span>
    <span class="n">stoploss_from_open</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># --------------------------------</span>
<span class="c1"># Add your lib to import here</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">talib.abstract</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ta</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">technical</span><span class="w"> </span><span class="kn">import</span> <span class="n">qtpylib</span>
</code></pre></div><h2 id="strategy-file-loading"> 전략 파일 로딩 <a class="headerlink" href="#strategy-file-loading" title="영구 링크"> ¶ </a></h2><p> 기본적으로 freqtrade는 <code> userdir </code> (기본값 <code> user_data/strategies </code> ) 내의 모든 <code> .py </code> 파일에서 전략을 로드하려고 시도합니다. </p><p> 전략이 <code> AwesomeStrategy </code> 라고 가정하고, 파일이 <code> user_data/strategies/AwesomeStrategy.py </code> 에 저장되어 있다면, freqtrade를 드라이 모드(또는 구성에 따라 라이브 모드)로 시작할 수 있습니다: </p><div class="highlight"><pre><code>freqtrade trade --strategy AwesomeStrategy
</code></pre></div><p>파일 이름이 아닌 클래스 이름을 사용하고 있음을 주의하세요.</p><p><code> freqtrade list-strategies </code> 를 사용하여 Freqtrade가 로드할 수 있는 모든 전략 목록(올바른 폴더에 있는 모든 전략)을 확인할 수 있습니다. 또한 &quot;상태&quot; 필드를 포함하여 잠재적인 문제를 강조합니다. </p><details class="hint"><summary>전략 디렉토리 사용자 정의</summary><p><code> --strategy-path user_data/otherPath </code> 를 사용하여 다른 디렉토리를 사용할 수 있습니다. 이 매개변수는 전략이 필요한 모든 명령어에 사용할 수 있습니다. </p></details><h2 id="informative-pairs"> 정보 제공 페어 <a class="headerlink" href="#informative-pairs" title="영구 링크"> ¶ </a></h2><h3 id="get-data-for-non-tradeable-pairs"> 거래 불가능한 페어에 대한 데이터 가져오기 <a class="headerlink" href="#get-data-for-non-tradeable-pairs" title="영구 링크"> ¶ </a></h3><p>추가적인 정보 제공 페어(참조 페어)에 대한 데이터는 일부 전략에서 더 넓은 시간 프레임의 데이터를 보기 위해 유용할 수 있습니다.</p><p> 이러한 페어에 대한 OHLCV 데이터는 정기적인 화이트리스트 새로 고침 프로세스의 일부로 다운로드되며, 다른 페어와 마찬가지로 <code> DataProvider </code> 를 통해 사용할 수 있습니다(아래 참조). </p><p> 이러한 페어는 화이트리스트에 포함되지 않으면 거래되지 않습니다. 또는 동적 화이트리스트에 의해 선택된 경우, 예를 들어 <code> VolumePairlist </code> . </p><p> 페어는 튜플 형식으로 지정해야 하며, 형식은 <code> (&quot;pair&quot;, &quot;timeframe&quot;) </code> 입니다. 첫 번째 인수는 페어, 두 번째 인수는 시간 프레임입니다. </p><p>샘플:</p><div class="highlight"><pre><code><span class="k">def</span><span class="w"> </span><span class="nf">informative_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[(</span><span class="s2">&quot;ETH/USDT&quot;</span><span class="p">,</span> <span class="s2">&quot;5m&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;BTC/TUSD&quot;</span><span class="p">,</span> <span class="s2">&quot;15m&quot;</span><span class="p">),</span>
            <span class="p">]</span>
</code></pre></div><p> 전체 샘플은 <a href="#complete-dataprovider-sample"> DataProvider 섹션 </a> 에서 확인할 수 있습니다. </p><div class="admonition warning"><p class="admonition-title">경고</p><p>이러한 페어는 정기적인 화이트리스트 새로 고침의 일부로 새로 고침되므로, 이 목록을 짧게 유지하는 것이 좋습니다. 모든 시간 프레임과 모든 페어는 사용 가능하며(활성화된 경우) 사용 가능합니다. 그러나 너무 많은 요청으로 인해 거래소가 차단될 위험이 있으므로 가능한 경우 더 긴 시간 프레임으로 리샘플링하는 것이 좋습니다.</p></div><details class="note"><summary>대체 캔들 유형</summary><p> Informative_pairs는 3 <sup> rd </sup> 튜플 요소를 제공하여 캔들 유형을 명시적으로 정의할 수 있습니다. 대체 캔들 유형의 가용성은 거래 모드 및 거래소에 따라 다릅니다. 일반적으로 현물 페어는 선물 시장에서 사용할 수 없으며, 선물 캔들은 현물 봇의 정보 제공 페어로 사용할 수 없습니다. 이에 대한 자세한 내용은 거래소 문서에서 확인할 수 있습니다. </p><div class="highlight"><pre><code><span class="k">def</span><span class="w"> </span><span class="nf">informative_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span>
        <span class="p">(</span><span class="s2">&quot;ETH/USDT&quot;</span><span class="p">,</span> <span class="s2">&quot;5m&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">),</span>   <span class="c1"># Uses default candletype, depends on trading_mode (recommended)</span>
        <span class="p">(</span><span class="s2">&quot;ETH/USDT&quot;</span><span class="p">,</span> <span class="s2">&quot;5m&quot;</span><span class="p">,</span> <span class="s2">&quot;spot&quot;</span><span class="p">),</span>   <span class="c1"># Forces usage of spot candles (only valid for bots running on spot markets).</span>
        <span class="p">(</span><span class="s2">&quot;BTC/TUSD&quot;</span><span class="p">,</span> <span class="s2">&quot;15m&quot;</span><span class="p">,</span> <span class="s2">&quot;futures&quot;</span><span class="p">),</span>  <span class="c1"># Uses futures candles (only bots with \`trading_mode=futures\`)</span>
        <span class="p">(</span><span class="s2">&quot;BTC/TUSD&quot;</span><span class="p">,</span> <span class="s2">&quot;15m&quot;</span><span class="p">,</span> <span class="s2">&quot;mark&quot;</span><span class="p">),</span>  <span class="c1"># Uses mark candles (only bots with \`trading_mode=futures\`)</span>
    <span class="p">]</span>
</code></pre></div></details><hr><h3 id="informative-pairs-decorator-informative"> 정보 제공 페어 데코레이터 ( <code> @informative() </code> ) <a class="headerlink" href="#informative-pairs-decorator-informative" title="영구 링크"> ¶ </a></h3><p> 정보 제공 페어를 쉽게 정의하려면 <code> @informative </code> 데코레이터를 사용하세요. 모든 데코레이터된 <code> populate_indicators_* </code> 메서드는 독립적으로 실행되며, 다른 정보 제공 페어의 데이터에 접근할 수 없습니다. 그러나 각 페어의 모든 정보 제공 데이터프레임은 병합되어 주요 <code> populate_indicators() </code> 메서드에 전달됩니다. </p><div class="admonition note"><p class="admonition-title">참고</p><p> 정보 제공 페어를 생성할 때 다른 정보 제공 페어의 데이터를 사용해야 하는 경우 <code> @informative </code> 데코레이터를 사용하지 마세요. 대신, DataProvider 섹션에서 설명한 대로 정보 제공 페어를 수동으로 정의하세요. </p></div>`,26)),n("p",null,[s[24]||(s[24]=a(" 하이퍼옵팅 시, 하이퍼옵트 가능한 매개변수 ")),s[25]||(s[25]=n("code",null," .value ",-1)),s[26]||(s[26]=a(" 속성은 지원되지 않습니다. ")),s[27]||(s[27]=n("code",null," .range ",-1)),s[28]||(s[28]=a(" 속성을 사용하세요. 자세한 내용은 ")),l(p,{to:"hyperopt"},{default:c(()=>s[23]||(s[23]=[a(" 지표 매개변수 최적화 ")])),_:1}),s[29]||(s[29]=a(" 를 참조하세요. "))]),s[75]||(s[75]=e(`<details class="info"><summary>전체 문서</summary><div class="highlight"><pre><code><span class="k">def</span><span class="w"> </span><span class="nf">informative</span><span class="p">(</span>
    <span class="n">timeframe</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">asset</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="n">fmt</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">],</span> <span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">candle_type</span><span class="p">:</span> <span class="n">CandleType</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">ffill</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">PopulateIndicators</span><span class="p">],</span> <span class="n">PopulateIndicators</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A decorator for populate_indicators_Nn(self, dataframe, metadata), allowing these functions to</span>
<span class="sd">    define informative indicators.</span>

<span class="sd">    Example usage:</span>

<span class="sd">        @informative(&#39;1h&#39;)</span>
<span class="sd">        def populate_indicators_1h(self, dataframe: DataFrame, metadata: dict) -&gt; DataFrame:</span>
<span class="sd">            dataframe[&#39;rsi&#39;] = ta.RSI(dataframe, timeperiod=14)</span>
<span class="sd">            return dataframe</span>

<span class="sd">    :param timeframe: Informative timeframe. Must always be equal or higher than strategy timeframe.</span>
<span class="sd">    :param asset: Informative asset, for example BTC, BTC/USDT, ETH/BTC. Do not specify to use</span>
<span class="sd">                current pair. Also supports limited pair format strings (see below)</span>
<span class="sd">    :param fmt: Column format (str) or column formatter (callable(name, asset, timeframe)). When not</span>
<span class="sd">    specified, defaults to:</span>
<span class="sd">    * {base}_{quote}_{column}_{timeframe} if asset is specified.</span>
<span class="sd">    * {column}_{timeframe} if asset is not specified.</span>
<span class="sd">    Pair format supports these format variables:</span>
<span class="sd">    * {base} - base currency in lower case, for example &#39;eth&#39;.</span>
<span class="sd">    * {BASE} - same as {base}, except in upper case.</span>
<span class="sd">    * {quote} - quote currency in lower case, for example &#39;usdt&#39;.</span>
<span class="sd">    * {QUOTE} - same as {quote}, except in upper case.</span>
<span class="sd">    Format string additionally supports this variables.</span>
<span class="sd">    * {asset} - full name of the asset, for example &#39;BTC/USDT&#39;.</span>
<span class="sd">    * {column} - name of dataframe column.</span>
<span class="sd">    * {timeframe} - timeframe of informative dataframe.</span>
<span class="sd">    :param ffill: ffill dataframe after merging informative pair.</span>
<span class="sd">    :param candle_type: &#39;&#39;, mark, index, premiumIndex, or funding_rate</span>
<span class="sd">    &quot;&quot;&quot;</span>
</code></pre></div></details><details class="example"><summary>정보 제공 페어를 정의하는 빠르고 쉬운 방법</summary><p> 대부분의 경우 <code> merge_informative_pair() </code> 가 제공하는 기능과 유연성이 필요하지 않으므로, 데코레이터를 사용하여 정보 제공 페어를 빠르게 정의할 수 있습니다. </p><div class="highlight"><pre><code><span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">freqtrade.persistence</span><span class="w"> </span><span class="kn">import</span> <span class="n">Trade</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">freqtrade.strategy</span><span class="w"> </span><span class="kn">import</span> <span class="n">IStrategy</span><span class="p">,</span> <span class="n">informative</span>

<span class="k">class</span><span class="w"> </span><span class="nc">AwesomeStrategy</span><span class="p">(</span><span class="n">IStrategy</span><span class="p">):</span>

    <span class="c1"># 이 메서드는 필요하지 않습니다. </span>
    <span class="c1"># def informative_pairs(self): ...</span>

    <span class="c1"># 각 페어에 대해 정보 제공 상위 시간 프레임을 정의합니다. 데코레이터는 동일한 메서드에 스택할 수 있습니다. &#39;rsi_30m&#39; 및 &#39;rsi_1h&#39;로 populate_indicators에서 사용할 수 있습니다.</span>
    <span class="nd">@informative</span><span class="p">(</span><span class="s1">&#39;30m&#39;</span><span class="p">)</span>
    <span class="nd">@informative</span><span class="p">(</span><span class="s1">&#39;1h&#39;</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">populate_indicators_1h</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">metadata</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;rsi&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">RSI</span><span class="p">(</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">timeperiod</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dataframe</span>

    <span class="c1"># BTC/STAKE 정보 제공 페어를 정의합니다. 현재 스테이크 통화는 하드 코딩된 실제 스테이크 통화 대신 {stake} 형식 변수를 사용하여 지정해야 합니다. populate_indicators 및 다른 메서드에서 &#39;btc_usdt_rsi_1h&#39;로 사용할 수 있습니다(스테이크 통화가 USDT인 경우).</span>
    <span class="nd">@informative</span><span class="p">(</span><span class="s1">&#39;1h&#39;</span><span class="p">,</span> <span class="s1">&#39;BTC/</span><span class="si">{stake}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">populate_indicators_btc_1h</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">metadata</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;rsi&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">RSI</span><span class="p">(</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">timeperiod</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dataframe</span>

    <span class="c1"># BTC/ETH 정보 제공 페어를 정의합니다. 스테이크 통화와 다른 경우 인용 통화를 지정해야 합니다. populate_indicators 및 다른 메서드에서 &#39;eth_btc_rsi_1h&#39;로 사용할 수 있습니다.</span>
    <span class="nd">@informative</span><span class="p">(</span><span class="s1">&#39;1h&#39;</span><span class="p">,</span> <span class="s1">&#39;ETH/BTC&#39;</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">populate_indicators_eth_btc_1h</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">metadata</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;rsi&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">RSI</span><span class="p">(</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">timeperiod</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dataframe</span>

    <span class="c1"># BTC/STAKE 정보 제공 페어를 정의합니다. 열 이름을 포맷하는 데 사용자 정의 포맷터를 지정할 수 있습니다. 열 이름을 포맷하는 사용자 정의 포맷터를 지정할 수 있습니다. populate_indicators 및 다른 메서드에서 &#39;rsi_upper_1h&#39;로 사용할 수 있습니다.</span>
    <span class="nd">@informative</span><span class="p">(</span><span class="s1">&#39;1h&#39;</span><span class="p">,</span> <span class="s1">&#39;BTC/</span><span class="si">{stake}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{column}</span><span class="s1">_</span><span class="si">{timeframe}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">populate_indicators_btc_1h_2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">metadata</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;rsi_upper&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">RSI</span><span class="p">(</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">timeperiod</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dataframe</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">populate_indicators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">metadata</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="c1"># 현재 페어에 대한 전략 시간 프레임 지표.</span>
        <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;rsi&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">RSI</span><span class="p">(</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">timeperiod</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
        <span class="c1"># 정보 제공 페어는 이 메서드에서 사용할 수 있습니다.</span>
        <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;rsi_less&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;rsi&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;rsi_1h&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">dataframe</span>
</code></pre></div></details><div class="admonition note"><p class="admonition-title">참고</p><p>정보 제공 데이터프레임의 열에 접근할 때 문자열 포맷팅을 사용하세요. 이를 통해 구성에서 전략 코드를 조정하지 않고 스테이크 통화를 쉽게 변경할 수 있습니다.</p><div class="highlight"><pre><code><span class="k">def</span><span class="w"> </span><span class="nf">populate_entry_trend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">metadata</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
    <span class="n">stake</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;stake_currency&#39;</span><span class="p">]</span>
    <span class="n">dataframe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
        <span class="p">(</span>
            <span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;btc_</span><span class="si">{</span><span class="n">stake</span><span class="si">}</span><span class="s1">_rsi_1h&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">35</span><span class="p">)</span>
            <span class="o">&amp;</span>
            <span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;volume&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">),</span>
        <span class="p">[</span><span class="s1">&#39;enter_long&#39;</span><span class="p">,</span> <span class="s1">&#39;enter_tag&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;buy_signal_rsi&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dataframe</span>
</code></pre></div><p> 대신 열 이름에서 스테이크 통화를 제거하려면 열 이름 바꾸기를 사용할 수 있습니다: <code> @informative(&#39;1h&#39;, &#39;BTC/{stake}&#39;, fmt=&#39;{base}_{column}_{timeframe}&#39;) </code> . </p></div><div class="admonition warning"><p class="admonition-title">중복 메서드 이름</p><p><code> @informative() </code> 데코레이터가 태그된 메서드는 항상 고유한 이름을 가져야 합니다! 동일한 이름을 재사용하면(예: 이미 정의된 정보 제공 메서드를 복사-붙여넣기할 때) 이전에 정의된 메서드를 덮어쓰며, Python 프로그래밍 언어의 제한으로 인해 오류가 발생하지 않습니다. 이러한 경우, 전략 파일의 상위에 있는 메서드에서 생성된 지표가 데이터프레임에서 사용할 수 없음을 알게 될 것입니다. 메서드 이름을 신중히 검토하고 고유한지 확인하세요! </p></div><h3 id="merge_informative_pair"><em> merge_informative_pair() </em><a class="headerlink" href="#merge_informative_pair" title="영구 링크"> ¶ </a></h3><p>이 메서드는 정보 제공 페어를 기존 주요 데이터프레임에 안전하고 일관되게 병합하는 데 도움이 되며, lookahead 바이어스 없이 병합할 수 있습니다.</p><p>옵션:</p><ul><li>고유한 열을 생성하기 위해 열 이름 변경</li><li>lookahead 바이어스 없이 데이터프레임 병합</li><li>앞으로 채우기(선택 사항)</li></ul><p> 전체 샘플은 아래의 <a href="#complete-dataprovider-sample"> 전체 데이터 제공자 예제 </a> 를 참조하세요. </p><p>정보 제공 데이터프레임의 모든 열은 다음과 같이 이름이 변경된 방식으로 반환되는 데이터프레임에서 사용할 수 있습니다:</p><div class="admonition example"><p class="admonition-title">열 이름 변경</p><p><code> inf_tf = &#39;1d&#39; </code> 라고 가정하면, 결과 열은 다음과 같습니다: </p><div class="highlight"><pre><code><span class="s1">&#39;date&#39;</span><span class="p">,</span> <span class="s1">&#39;open&#39;</span><span class="p">,</span> <span class="s1">&#39;high&#39;</span><span class="p">,</span> <span class="s1">&#39;low&#39;</span><span class="p">,</span> <span class="s1">&#39;close&#39;</span><span class="p">,</span> <span class="s1">&#39;rsi&#39;</span>                     <span class="c1"># from the original dataframe</span>
<span class="s1">&#39;date_1d&#39;</span><span class="p">,</span> <span class="s1">&#39;open_1d&#39;</span><span class="p">,</span> <span class="s1">&#39;high_1d&#39;</span><span class="p">,</span> <span class="s1">&#39;low_1d&#39;</span><span class="p">,</span> <span class="s1">&#39;close_1d&#39;</span><span class="p">,</span> <span class="s1">&#39;rsi_1d&#39;</span>   <span class="c1"># from the informative dataframe</span>
</code></pre></div></div><details class="example"><summary>열 이름 변경 - 1h</summary><p><code> inf_tf = &#39;1h&#39; </code> 라고 가정하면, 결과 열은 다음과 같습니다: </p><div class="highlight"><pre><code><span class="s1">&#39;date&#39;</span><span class="p">,</span> <span class="s1">&#39;open&#39;</span><span class="p">,</span> <span class="s1">&#39;high&#39;</span><span class="p">,</span> <span class="s1">&#39;low&#39;</span><span class="p">,</span> <span class="s1">&#39;close&#39;</span><span class="p">,</span> <span class="s1">&#39;rsi&#39;</span>                     <span class="c1"># from the original dataframe</span>
<span class="s1">&#39;date_1h&#39;</span><span class="p">,</span> <span class="s1">&#39;open_1h&#39;</span><span class="p">,</span> <span class="s1">&#39;high_1h&#39;</span><span class="p">,</span> <span class="s1">&#39;low_1h&#39;</span><span class="p">,</span> <span class="s1">&#39;close_1h&#39;</span><span class="p">,</span> <span class="s1">&#39;rsi_1h&#39;</span>   <span class="c1"># from the informative dataframe</span>
</code></pre></div></details><details class="example"><summary>사용자 정의 구현</summary><p>이를 위한 사용자 정의 구현은 다음과 같이 가능합니다:</p><div class="highlight"><pre><code><span class="c1"># Shift date by 1 candle</span>
<span class="c1"># This is necessary since the data is always the &quot;open date&quot;</span>
<span class="c1"># and a 15m candle starting at 12:15 should not know the close of the 1h candle from 12:00 to 13:00</span>
<span class="n">minutes</span> <span class="o">=</span> <span class="n">timeframe_to_minutes</span><span class="p">(</span><span class="n">inf_tf</span><span class="p">)</span>
<span class="c1"># Only do this if the timeframes are different:</span>
<span class="n">informative</span><span class="p">[</span><span class="s1">&#39;date_merge&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">informative</span><span class="p">[</span><span class="s2">&quot;date&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="n">minutes</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">)</span>

<span class="c1"># Rename columns to be unique</span>
<span class="n">informative</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">inf_tf</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">informative</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
<span class="c1"># Assuming inf_tf = &#39;1d&#39; - then the columns will now be:</span>
<span class="c1"># date_1d, open_1d, high_1d, low_1d, close_1d, rsi_1d</span>

<span class="c1"># Combine the 2 dataframes</span>
<span class="c1"># all indicators on the informative sample MUST be calculated before this point</span>
<span class="n">dataframe</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">informative</span><span class="p">,</span> <span class="n">left_on</span><span class="o">=</span><span class="s1">&#39;date&#39;</span><span class="p">,</span> <span class="n">right_on</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;date_merge_</span><span class="si">{</span><span class="n">inf_tf</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
<span class="c1"># FFill to have the 1d value available in every row throughout the day.</span>
<span class="c1"># Without this, comparisons would only work once per day.</span>
<span class="n">dataframe</span> <span class="o">=</span> <span class="n">dataframe</span><span class="o">.</span><span class="n">ffill</span><span class="p">()</span>
</code></pre></div></details><div class="admonition warning"><p class="admonition-title">정보 제공 시간 프레임 &lt; 시간 프레임</p><p>이 방법을 사용하여 주요 데이터프레임 시간 프레임보다 작은 정보 제공 시간 프레임을 사용하는 것은 권장되지 않습니다. 이는 제공하는 추가 정보를 사용하지 않기 때문입니다. 더 자세한 정보를 적절히 사용하려면 더 고급 방법을 적용해야 하며, 이는 이 문서의 범위를 벗어납니다.</p></div><h2 id="additional-data-dataprovider"> 추가 데이터 (DataProvider) <a class="headerlink" href="#additional-data-dataprovider" title="영구 링크"> ¶ </a></h2><p> 전략은 <code> DataProvider </code> 에 접근할 수 있습니다. 이를 통해 전략에서 사용할 추가 데이터를 얻을 수 있습니다. </p><p> 모든 메서드는 실패 시 <code> None </code> 을 반환합니다. 즉, 실패는 예외를 발생시키지 않습니다. </p><p>항상 실행 모드를 확인하여 데이터를 가져오는 올바른 메서드를 선택하세요(예제는 아래 참조).</p><div class="admonition warning"><p class="admonition-title">하이퍼옵트 제한</p><p> DataProvider는 하이퍼옵트 중에 사용할 수 있지만, 전략 내에서만 <code> populate_indicators() </code> 에서 사용할 수 있으며, 하이퍼옵트 클래스 파일 내에서는 사용할 수 없습니다. 또한 <code> populate_entry_trend() </code> 및 <code> populate_exit_trend() </code> 메서드에서는 사용할 수 없습니다. </p></div><h3 id="possible-options-for-dataprovider"> DataProvider의 가능한 옵션 <a class="headerlink" href="#possible-options-for-dataprovider" title="영구 링크"> ¶ </a></h3><ul><li><a href="#available_pairs"><code> available_pairs </code></a> - 시간 프레임과 함께 캐시된 페어를 나열하는 튜플 속성(페어, 시간 프레임). </li><li><a href="#current_whitelist"><code> current_whitelist() </code></a> - 현재 화이트리스트에 포함된 페어 목록을 반환합니다. 동적 화이트리스트(예: VolumePairlist)에 접근하는 데 유용합니다. </li><li><a href="#get_pair_dataframepair-timeframe"><code> get_pair_dataframe(pair, timeframe) </code></a> - 이는 범용 메서드로, 역사적 데이터(백테스팅용) 또는 캐시된 실시간 데이터(드라이런 및 라이브런 모드용)를 반환합니다. </li><li><a href="#get_analyzed_dataframepair-timeframe"><code> get_analyzed_dataframe(pair, timeframe) </code></a> - 분석된 데이터프레임을 반환하며(호출 후 <code> populate_indicators() </code> , <code> populate_buy() </code> , <code> populate_sell() </code> ) 최신 분석 시간을 반환합니다. </li><li><code> historic_ohlcv(pair, timeframe) </code> - 디스크에 저장된 역사적 데이터를 반환합니다. </li><li><code> market(pair) </code> - 페어에 대한 시장 데이터를 반환합니다: 수수료, 한도, 정밀도, 활동 플래그 등. 시장 데이터 구조에 대한 자세한 내용은 <a href="https://github.com/ccxt/ccxt/wiki/Manual#markets"> ccxt 문서 </a> 를 참조하세요. </li><li><code> ohlcv(pair, timeframe) </code> - 페어에 대한 현재 캐시된 캔들(OHLCV) 데이터를 반환하며, DataFrame 또는 빈 DataFrame을 반환합니다. </li><li><a href="#orderbookpair-maximum"><code> orderbook(pair, maximum) </code></a> - 페어에 대한 최신 주문서 데이터를 반환하며, 최대 <code> maximum </code> 항목이 포함된 dict를 반환합니다. </li><li><a href="#tickerpair"><code> ticker(pair) </code></a> - 페어에 대한 현재 티커 데이터를 반환합니다. 티커 데이터 구조에 대한 자세한 내용은 <a href="https://github.com/ccxt/ccxt/wiki/Manual#price-tickers"> ccxt 문서 </a> 를 참조하세요. </li><li><code> runmode </code> - 현재 실행 모드를 포함하는 속성. </li></ul><h3 id="example-usages"> 사용 예제 <a class="headerlink" href="#example-usages" title="영구 링크"> ¶ </a></h3><h3 id="available_pairs"><em> available_pairs </em><a class="headerlink" href="#available_pairs" title="영구 링크"> ¶ </a></h3><div class="highlight"><pre><code><span class="k">for</span> <span class="n">pair</span><span class="p">,</span> <span class="n">timeframe</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dp</span><span class="o">.</span><span class="n">available_pairs</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;available </span><span class="si">{</span><span class="n">pair</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">timeframe</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div><h3 id="current_whitelist"><em> current_whitelist() </em><a class="headerlink" href="#current_whitelist" title="영구 링크"> ¶ </a></h3><p><code> VolumePairList </code> 를 사용하여 상위 10개 거래소 페어의 거래량을 기준으로 5분마다 스캔하고 14일 RSI를 사용하여 진입 및 청산하는 전략을 개발했다고 가정해 보겠습니다. </p><p>전략 로직은 다음과 같을 수 있습니다:</p><p><em><code> VolumePairList </code> 를 사용하여 5분마다 상위 10개 페어를 스캔하고 14일 RSI를 사용하여 진입 및 청산합니다. </em></p><p>제한된 데이터로 인해 5m 캔들을 일일 캔들로 리샘플링하여 14일 RSI를 사용하는 것은 매우 어렵습니다. 대부분의 거래소는 사용자에게 500-1000개의 캔들만 제공하므로 약 1.74일의 일일 캔들만 제공합니다. 최소 14일이 필요합니다!</p><p>데이터를 리샘플링할 수 없으므로 정보 제공 페어를 사용해야 하며, 화이트리스트가 동적이므로 사용할 페어를 알 수 없습니다! 문제가 발생했습니다!</p><p> 이 경우 <code> self.dp.current_whitelist() </code> 를 호출하여 화이트리스트에 있는 페어만 검색하는 것이 유용합니다. </p><div class="highlight"><pre><code>    <span class="k">def</span><span class="w"> </span><span class="nf">informative_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="c1"># get access to all pairs available in whitelist.</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dp</span><span class="o">.</span><span class="n">current_whitelist</span><span class="p">()</span>
        <span class="c1"># Assign timeframe to each pair so they can be downloaded and cached for strategy.</span>
        <span class="n">informative_pairs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">pair</span><span class="p">,</span> <span class="s1">&#39;1d&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">informative_pairs</span>
</code></pre></div>`,32)),n("details",m,[s[35]||(s[35]=n("summary",null,"current_whitelist를 사용한 플로팅",-1)),n("p",null,[s[31]||(s[31]=a(" Current whitelist는 ")),s[32]||(s[32]=n("code",null," plot-dataframe ",-1)),s[33]||(s[33]=a(" 에 대해 지원되지 않습니다. 이 명령어는 일반적으로 명시적인 페어리스트를 제공하여 사용되므로 이 메서드의 반환 값을 오해할 수 있습니다. 또한 ")),l(p,{to:"utils"},{default:c(()=>s[30]||(s[30]=[a(" 웹서버 모드 ")])),_:1}),s[34]||(s[34]=a(" 에서 FreqUI 시각화를 위해 지원되지 않습니다. 웹서버 모드의 구성은 페어리스트를 설정할 필요가 없기 때문입니다. "))])]),s[76]||(s[76]=e(`<h3 id="get_pair_dataframepair-timeframe"><em> get_pair_dataframe(pair, timeframe) </em><a class="headerlink" href="#get_pair_dataframepair-timeframe" title="영구 링크"> ¶ </a></h3><div class="highlight"><pre><code><span class="c1"># fetch live / historical candle (OHLCV) data for the first informative pair</span>
<span class="n">inf_pair</span><span class="p">,</span> <span class="n">inf_timeframe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">informative_pairs</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">informative</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dp</span><span class="o">.</span><span class="n">get_pair_dataframe</span><span class="p">(</span><span class="n">pair</span><span class="o">=</span><span class="n">inf_pair</span><span class="p">,</span>
                                         <span class="n">timeframe</span><span class="o">=</span><span class="n">inf_timeframe</span><span class="p">)</span>
</code></pre></div><div class="admonition warning"><p class="admonition-title">백테스팅 관련 경고</p><p> 백테스팅에서 <code> dp.get_pair_dataframe() </code> 의 동작은 호출 위치에 따라 다릅니다. <code> populate_*() </code> 메서드 내에서는 전체 시간 범위를 반환합니다. 드라이런 및 라이브 모드에서는 현재(시뮬레이션된) 캔들까지의 전체 시간 범위를 반환합니다. </p></div><h3 id="get_analyzed_dataframepair-timeframe"><em> get_analyzed_dataframe(pair, timeframe) </em><a class="headerlink" href="#get_analyzed_dataframepair-timeframe" title="영구 링크"> ¶ </a></h3>`,4)),n("p",null,[s[37]||(s[37]=a(" 이 메서드는 Freqtrade가 마지막 신호를 결정하는 데 내부적으로 사용됩니다. 특정 콜백에서 이 메서드를 사용하여 작업을 유발한 신호를 얻을 수도 있습니다(사용 가능한 콜백에 대한 자세한 내용은 ")),l(p,{to:"strategy-advanced"},{default:c(()=>s[36]||(s[36]=[a(" 고급 전략 문서 ")])),_:1}),s[38]||(s[38]=a(" 를 참조하세요). "))]),s[77]||(s[77]=e(`<div class="highlight"><pre><code><span class="c1"># fetch current dataframe</span>
<span class="n">dataframe</span><span class="p">,</span> <span class="n">last_updated</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dp</span><span class="o">.</span><span class="n">get_analyzed_dataframe</span><span class="p">(</span><span class="n">pair</span><span class="o">=</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;pair&#39;</span><span class="p">],</span>
                                                         <span class="n">timeframe</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">timeframe</span><span class="p">)</span>
</code></pre></div><div class="admonition note"><p class="admonition-title">사용할 수 없는 데이터</p><p> 요청된 페어가 캐시되지 않은 경우 빈 데이터프레임을 반환합니다. 이를 <code> if dataframe.empty: </code> 로 확인하고 이에 따라 처리할 수 있습니다. 화이트리스트에 포함된 페어를 사용할 때는 발생하지 않아야 합니다. </p></div><h3 id="orderbookpair-maximum"><em> orderbook(pair, maximum) </em><a class="headerlink" href="#orderbookpair-maximum" title="영구 링크"> ¶ </a></h3><div class="highlight"><pre><code><span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dp</span><span class="o">.</span><span class="n">runmode</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;live&#39;</span><span class="p">,</span> <span class="s1">&#39;dry_run&#39;</span><span class="p">):</span>
    <span class="n">ob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dp</span><span class="o">.</span><span class="n">orderbook</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;pair&#39;</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;best_bid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ob</span><span class="p">[</span><span class="s1">&#39;bids&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;best_ask&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ob</span><span class="p">[</span><span class="s1">&#39;asks&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div><p> 티커 데이터 구조는 ccxt 통합 인터페이스의 일부이지만, 이 메서드에서 반환되는 값은 거래소마다 다를 수 있습니다. 예를 들어, 많은 거래소가 <code> vwap </code> 값을 반환하지 않으며, 일부 거래소는 <code> last </code> 필드를 항상 채우지 않을 수도 있습니다(따라서 None일 수 있음). 따라서 거래소에서 반환된 티커 데이터를 신중히 검증하고 적절한 오류 처리/기본값을 추가해야 합니다. </p><div class="admonition warning"><p class="admonition-title">백테스팅 관련 경고</p><p>이 메서드는 항상 최신/실시간 값을 반환합니다. 따라서 백테스팅/하이퍼옵트에서 실행 모드 확인 없이 사용하면 잘못된 결과를 초래할 수 있습니다. 예를 들어, 데이터프레임 전체가 동일한 단일 값으로 채워질 수 있습니다.</p></div><h3 id="send-notification"> 알림 보내기 <a class="headerlink" href="#send-notification" title="영구 링크"> ¶ </a></h3><p> 데이터 제공자의 <code> .send_msg() </code> 함수는 전략에서 사용자 정의 알림을 보낼 수 있도록 합니다. 동일한 알림은 한 캔들당 한 번만 전송되며, 두 번째 인수( <code> always_send </code> )를 True로 설정하면 이 제한을 무시할 수 있습니다. </p><div class="highlight"><pre><code>    <span class="bp">self</span><span class="o">.</span><span class="n">dp</span><span class="o">.</span><span class="n">send_msg</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;pair&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">가 방금 활성화되었습니다!&quot;</span><span class="p">)</span>

    <span class="c1"># 이 알림을 강제로 전송하고 캐싱을 방지합니다 (아래 경고를 읽으세요!)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dp</span><span class="o">.</span><span class="n">send_msg</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;pair&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">가 방금 활성화되었습니다!&quot;</span><span class="p">,</span> <span class="n">always_send</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</code></pre></div> 알림은 거래 모드(Live/Dry-run)에서만 전송됩니다. 따라서 백테스팅 중에도 조건 없이 이 메서드를 호출할 수 있습니다. <div class="admonition warning"><p class="admonition-title">스팸 경고</p><p> 이 메서드에서 <code> always_send=True </code> 를 설정하면 스팸 알림이 발생할 수 있습니다. 이 설정은 매우 신중하게 사용하고, 한 캔들 동안 여러 번 발생하지 않을 조건에서만 사용하세요. </p></div><h3 id="complete-dataprovider-sample"> Complete DataProvider sample <a class="headerlink" href="#complete-dataprovider-sample" title="영구 링크"> ¶ </a></h3><div class="highlight"><pre><code><span class="kn">from</span><span class="w"> </span><span class="nn">freqtrade.strategy</span><span class="w"> </span><span class="kn">import</span> <span class="n">IStrategy</span><span class="p">,</span> <span class="n">merge_informative_pair</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="kn">import</span> <span class="n">DataFrame</span>

<span class="k">class</span><span class="w"> </span><span class="nc">SampleStrategy</span><span class="p">(</span><span class="n">IStrategy</span><span class="p">):</span>
    <span class="c1"># strategy init stuff...</span>

    <span class="n">timeframe</span> <span class="o">=</span> <span class="s1">&#39;5m&#39;</span>

    <span class="c1"># more strategy init stuff..</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">informative_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="c1"># get access to all pairs available in whitelist.</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dp</span><span class="o">.</span><span class="n">current_whitelist</span><span class="p">()</span>
        <span class="c1"># Assign tf to each pair so they can be downloaded and cached for strategy.</span>
        <span class="n">informative_pairs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">pair</span><span class="p">,</span> <span class="s1">&#39;1d&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">]</span>
        <span class="c1"># Optionally Add additional &quot;static&quot; pairs</span>
        <span class="n">informative_pairs</span> <span class="o">+=</span> <span class="p">[(</span><span class="s2">&quot;ETH/USDT&quot;</span><span class="p">,</span> <span class="s2">&quot;5m&quot;</span><span class="p">),</span>
                              <span class="p">(</span><span class="s2">&quot;BTC/TUSD&quot;</span><span class="p">,</span> <span class="s2">&quot;15m&quot;</span><span class="p">),</span>
                            <span class="p">]</span>
        <span class="k">return</span> <span class="n">informative_pairs</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">populate_indicators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">metadata</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">dp</span><span class="p">:</span>
            <span class="c1"># Don&#39;t do anything if DataProvider is not available.</span>
            <span class="k">return</span> <span class="n">dataframe</span>

        <span class="n">inf_tf</span> <span class="o">=</span> <span class="s1">&#39;1d&#39;</span>
        <span class="c1"># Get the informative pair</span>
        <span class="n">informative</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dp</span><span class="o">.</span><span class="n">get_pair_dataframe</span><span class="p">(</span><span class="n">pair</span><span class="o">=</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;pair&#39;</span><span class="p">],</span> <span class="n">timeframe</span><span class="o">=</span><span class="n">inf_tf</span><span class="p">)</span>
        <span class="c1"># Get the 14 day rsi</span>
        <span class="n">informative</span><span class="p">[</span><span class="s1">&#39;rsi&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">RSI</span><span class="p">(</span><span class="n">informative</span><span class="p">,</span> <span class="n">timeperiod</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>

        <span class="c1"># Use the helper function merge_informative_pair to safely merge the pair</span>
        <span class="c1"># Automatically renames the columns and merges a shorter timeframe dataframe and a longer timeframe informative pair</span>
        <span class="c1"># use ffill to have the 1d value available in every row throughout the day.</span>
        <span class="c1"># Without this, comparisons between columns of the original and the informative pair would only work once per day.</span>
        <span class="c1"># Full documentation of this method, see below</span>
        <span class="n">dataframe</span> <span class="o">=</span> <span class="n">merge_informative_pair</span><span class="p">(</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">informative</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeframe</span><span class="p">,</span> <span class="n">inf_tf</span><span class="p">,</span> <span class="n">ffill</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Calculate rsi of the original dataframe (5m timeframe)</span>
        <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;rsi&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">RSI</span><span class="p">(</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">timeperiod</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>

        <span class="c1"># Do other stuff</span>
        <span class="c1"># ...</span>

        <span class="k">return</span> <span class="n">dataframe</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">populate_entry_trend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">metadata</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>

        <span class="n">dataframe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
            <span class="p">(</span>
                <span class="p">(</span><span class="n">qtpylib</span><span class="o">.</span><span class="n">crossed_above</span><span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;rsi&#39;</span><span class="p">],</span> <span class="mi">30</span><span class="p">))</span> <span class="o">&amp;</span>  <span class="c1"># Signal: RSI crosses above 30</span>
                <span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;rsi_1d&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">)</span> <span class="o">&amp;</span>                     <span class="c1"># Ensure daily RSI is &lt; 30</span>
                <span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;volume&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>                        <span class="c1"># Ensure this candle had volume (important for backtesting)</span>
            <span class="p">),</span>
            <span class="p">[</span><span class="s1">&#39;enter_long&#39;</span><span class="p">,</span> <span class="s1">&#39;enter_tag&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;rsi_cross&#39;</span><span class="p">)</span>
</code></pre></div><hr><h2 id="additional-data-wallets"> 추가 데이터 (지갑) <a class="headerlink" href="#additional-data-wallets" title="영구 링크"> ¶ </a></h2><p> 전략은 거래소에서 현재 지갑/계정 잔액을 포함하는 <code> wallets </code> 객체에 접근할 수 있습니다. </p>`,16)),n("div",f,[s[44]||(s[44]=n("p",{class:"admonition-title"},"백테스팅 / 하이퍼옵트",-1)),n("p",null,[s[40]||(s[40]=a(" 지갑은 호출된 함수에 따라 다르게 동작합니다. ")),s[41]||(s[41]=n("code",null," populate_*() ",-1)),s[42]||(s[42]=a(" 메서드 내에서는 구성된 전체 지갑을 반환합니다. ")),l(p,{to:"strategy-callbacks"},{default:c(()=>s[39]||(s[39]=[a(" 콜백 ")])),_:1}),s[43]||(s[43]=a(" 내에서는 시뮬레이션된 시점의 실제 시뮬레이션된 지갑 상태를 반환합니다. "))])]),s[78]||(s[78]=e(`<p> 항상 <code> wallets </code> 가 사용 가능한지 확인하여 백테스팅 중에 실패하지 않도록 하세요. </p><div class="highlight"><pre><code><span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wallets</span><span class="p">:</span>
    <span class="n">free_eth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wallets</span><span class="o">.</span><span class="n">get_free</span><span class="p">(</span><span class="s1">&#39;ETH&#39;</span><span class="p">)</span>
    <span class="n">used_eth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wallets</span><span class="o">.</span><span class="n">get_used</span><span class="p">(</span><span class="s1">&#39;ETH&#39;</span><span class="p">)</span>
    <span class="n">total_eth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wallets</span><span class="o">.</span><span class="n">get_total</span><span class="p">(</span><span class="s1">&#39;ETH&#39;</span><span class="p">)</span>
</code></pre></div><h3 id="possible-options-for-wallets"> 지갑의 가능한 옵션 <a class="headerlink" href="#possible-options-for-wallets" title="영구 링크"> ¶ </a></h3><ul><li><code> get_free(asset) </code> - 거래 가능한 현재 사용 가능한 잔액 </li><li><code> get_used(asset) </code> - 현재 묶여 있는 잔액(미체결 주문) </li><li><code> get_total(asset) </code> - 총 사용 가능한 잔액 - 위의 두 가지 합계 </li></ul><hr><h2 id="additional-data-trades"> 추가 데이터 (거래) <a class="headerlink" href="#additional-data-trades" title="영구 링크"> ¶ </a></h2><p>거래 내역은 데이터베이스를 쿼리하여 전략에서 검색할 수 있습니다.</p><p>파일 상단에 필요한 객체를 가져옵니다:</p><div class="highlight"><pre><code><span class="kn">from</span><span class="w"> </span><span class="nn">freqtrade.persistence</span><span class="w"> </span><span class="kn">import</span> <span class="n">Trade</span>
</code></pre></div><p> 다음 예제는 현재 페어( <code> metadata[&#39;pair&#39;] </code> )에 대한 오늘의 거래를 쿼리합니다. 다른 필터를 쉽게 추가할 수 있습니다. </p><div class="highlight"><pre><code><span class="n">trades</span> <span class="o">=</span> <span class="n">Trade</span><span class="o">.</span><span class="n">get_trades_proxy</span><span class="p">(</span><span class="n">pair</span><span class="o">=</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;pair&#39;</span><span class="p">],</span>
                                <span class="n">open_date</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">(</span><span class="n">timezone</span><span class="o">.</span><span class="n">utc</span><span class="p">)</span> <span class="o">-</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                                <span class="n">is_open</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">])</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">Trade</span><span class="o">.</span><span class="n">close_date</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="c1"># Summarize profit for this pair.</span>
<span class="n">curdayprofit</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">trade</span><span class="o">.</span><span class="n">close_profit</span> <span class="k">for</span> <span class="n">trade</span> <span class="ow">in</span> <span class="n">trades</span><span class="p">)</span>
</code></pre></div>`,11)),n("p",null,[s[46]||(s[46]=a(" 사용 가능한 메서드의 전체 목록은 ")),l(p,{to:"trade-object"},{default:c(()=>s[45]||(s[45]=[a(" 거래 객체 ")])),_:1}),s[47]||(s[47]=a(" 문서를 참조하세요. "))]),s[79]||(s[79]=e(`<div class="admonition warning"><p class="admonition-title">경고</p><p> 백테스팅 중에는 <code> populate_* </code> 메서드에서 거래 내역을 사용할 수 없으며, 빈 결과를 초래합니다. </p></div><h2 id="prevent-trades-from-happening-for-a-specific-pair"> 특정 페어에 대한 거래 방지 <a class="headerlink" href="#prevent-trades-from-happening-for-a-specific-pair" title="영구 링크"> ¶ </a></h2><p>Freqtrade는 페어가 청산될 때 현재 캔들 동안(해당 캔들이 끝날 때까지) 페어를 자동으로 잠급니다. 이는 해당 캔들 내에서 즉시 재진입을 방지합니다.</p><p>이는 단일 캔들 내에서 많은 빈번한 거래의 &quot;폭포&quot;를 방지하기 위함입니다.</p><p> 잠긴 페어는 <code> Pair &lt;pair&gt; is currently locked. </code> 메시지를 표시합니다. </p><h3 id="locking-pairs-from-within-the-strategy"> 전략 내에서 페어 잠금 <a class="headerlink" href="#locking-pairs-from-within-the-strategy" title="영구 링크"> ¶ </a></h3><p>특정 이벤트가 발생한 후(예: 연속 손실 거래) 페어를 잠그는 것이 바람직할 수 있습니다.</p><p> Freqtrade는 전략 내에서 <code> self.lock_pair(pair, until, [reason]) </code> 을 호출하여 이를 쉽게 수행할 수 있는 방법을 제공합니다. <code> until </code> 은 거래가 해당 페어에 대해 다시 활성화될 때까지의 미래의 datetime 객체여야 하며, <code> reason </code> 은 페어가 잠긴 이유를 설명하는 선택적 문자열입니다. </p><p> 페어 잠금은 <code> self.unlock_pair(pair) </code> 또는 <code> self.unlock_reason(&lt;reason&gt;) </code> 을 호출하여 수동으로 해제할 수 있습니다. 제공된 이유로 잠긴 모든 페어를 해제합니다. </p><p> 페어가 현재 잠겨 있는지 확인하려면 <code> self.is_pair_locked(pair) </code> 을 사용하세요. </p><div class="admonition note"><p class="admonition-title">참고</p><p> 잠긴 페어는 항상 다음 캔들로 반올림됩니다. 따라서 <code> 5m </code> 시간 프레임을 가정하면, 10:18로 설정된 잠금은 10:15-10:20 캔들이 완료될 때까지 페어를 잠급니다. </p></div><div class="admonition warning"><p class="admonition-title">경고</p><p>백테스팅 중에는 수동으로 페어를 잠글 수 없습니다. 보호를 통한 잠금만 허용됩니다.</p></div><h4 id="pair-locking-example"> 페어 잠금 예제 <a class="headerlink" href="#pair-locking-example" title="영구 링크"> ¶ </a></h4><div class="highlight"><pre><code><span class="kn">from</span><span class="w"> </span><span class="nn">freqtrade.persistence</span><span class="w"> </span><span class="kn">import</span> <span class="n">Trade</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">timedelta</span><span class="p">,</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timezone</span>
<span class="c1"># Put the above lines a the top of the strategy file, next to all the other imports</span>
<span class="c1"># --------</span>

<span class="c1"># Within populate indicators (or populate_entry_trend):</span>
<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;runmode&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;live&#39;</span><span class="p">,</span> <span class="s1">&#39;dry_run&#39;</span><span class="p">):</span>
    <span class="c1"># fetch closed trades for the last 2 days</span>
    <span class="n">trades</span> <span class="o">=</span> <span class="n">Trade</span><span class="o">.</span><span class="n">get_trades_proxy</span><span class="p">(</span>
        <span class="n">pair</span><span class="o">=</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;pair&#39;</span><span class="p">],</span> <span class="n">is_open</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
        <span class="n">open_date</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">(</span><span class="n">timezone</span><span class="o">.</span><span class="n">utc</span><span class="p">)</span> <span class="o">-</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
    <span class="c1"># Analyze the conditions you&#39;d like to lock the pair .... will probably be different for every strategy</span>
    <span class="n">sumprofit</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">trade</span><span class="o">.</span><span class="n">close_profit</span> <span class="k">for</span> <span class="n">trade</span> <span class="ow">in</span> <span class="n">trades</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sumprofit</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Lock pair for 12 hours</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lock_pair</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;pair&#39;</span><span class="p">],</span> <span class="n">until</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">(</span><span class="n">timezone</span><span class="o">.</span><span class="n">utc</span><span class="p">)</span> <span class="o">+</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">hours</span><span class="o">=</span><span class="mi">12</span><span class="p">))</span>
</code></pre></div><h2 id="print-the-main-dataframe"> 주요 데이터프레임 인쇄 <a class="headerlink" href="#print-the-main-dataframe" title="영구 링크"> ¶ </a></h2><p> 현재 주요 데이터프레임을 검사하려면 <code> populate_entry_trend() </code> 또는 <code> populate_exit_trend() </code> 에 print 문을 추가할 수 있습니다. 또한 현재 표시된 데이터가 무엇인지 명확히 하기 위해 페어를 인쇄할 수도 있습니다. </p><div class="highlight"><pre><code><span class="k">def</span><span class="w"> </span><span class="nf">populate_entry_trend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">metadata</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
    <span class="n">dataframe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
        <span class="p">(</span>
            <span class="c1">#&gt;&gt; whatever condition&lt;&lt;&lt;</span>
        <span class="p">),</span>
        <span class="p">[</span><span class="s1">&#39;enter_long&#39;</span><span class="p">,</span> <span class="s1">&#39;enter_tag&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;somestring&#39;</span><span class="p">)</span>

    <span class="c1"># Print the Analyzed pair</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;result for </span><span class="si">{</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;pair&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Inspect the last 5 rows</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">dataframe</span><span class="o">.</span><span class="n">tail</span><span class="p">())</span>

    <span class="k">return</span> <span class="n">dataframe</span>
</code></pre></div><p> 몇 줄 이상을 인쇄하는 것도 <code> print(dataframe) </code> 대신 <code> print(dataframe.tail()) </code> 를 사용하여 가능합니다. 그러나 이는 많은 출력(~500줄 페어당 5초마다)을 초래할 수 있으므로 권장되지 않습니다. </p><h2 id="common-mistakes-when-developing-strategies"> 전략 개발 시 일반적인 실수 <a class="headerlink" href="#common-mistakes-when-developing-strategies" title="영구 링크"> ¶ </a></h2><h3 id="looking-into-the-future-while-backtesting"> 백테스팅 중 미래를 보는 것 <a class="headerlink" href="#looking-into-the-future-while-backtesting" title="영구 링크"> ¶ </a></h3><p>백테스팅은 성능상의 이유로 전체 데이터프레임 시간 범위를 한 번에 분석합니다. 이로 인해 전략 작성자는 전략이 미래의 데이터를 사용하지 않도록 주의해야 합니다. 즉, 드라이 또는 라이브 모드에서 사용할 수 없는 데이터를 사용하지 않도록 해야 합니다.</p><p>이는 일반적인 문제로, 백테스팅과 드라이/라이브 실행 방법 간의 큰 차이를 초래할 수 있습니다. 미래를 보는 전략은 백테스팅 중에 잘 작동하며 종종 놀라운 수익률이나 승률을 보이지만 실제 조건에서는 실패하거나 성능이 저하됩니다.</p><p>다음 목록에는 좌절을 방지하기 위해 피해야 할 일반적인 패턴이 포함되어 있습니다:</p>`,23)),n("ul",null,[s[54]||(s[54]=n("li",null,[n("code",null," shift(-1) "),a(" 또는 다른 음수 값을 사용하지 마세요. 이는 백테스팅에서 미래의 데이터를 사용하며, 드라이 또는 라이브 모드에서는 사용할 수 없습니다. ")],-1)),n("li",null,[s[49]||(s[49]=n("code",null," .iloc[-1] ",-1)),s[50]||(s[50]=a(" 또는 데이터프레임 내에서 절대 위치를 사용하지 마세요. 이는 드라이런과 백테스팅 간에 다를 수 있습니다. 절대 ")),s[51]||(s[51]=n("code",null," iloc ",-1)),s[52]||(s[52]=a(" 인덱싱은 콜백에서는 안전하게 사용할 수 있습니다. 자세한 내용은 ")),l(p,{to:"strategy-callbacks"},{default:c(()=>s[48]||(s[48]=[a(" 전략 콜백 ")])),_:1}),s[53]||(s[53]=a(" 를 참조하세요. "))]),s[55]||(s[55]=n("li",null,[a(" 데이터프레임 또는 열 값을 모두 사용하는 함수를 사용하지 마세요. 예: "),n("code",null," dataframe['mean_volume'] = dataframe['volume'].mean() "),a(" . 백테스팅은 전체 데이터프레임을 사용하므로, 데이터프레임의 어느 시점에서든 "),n("code",null," 'mean_volume' "),a(" 시리즈는 미래의 데이터를 포함합니다. 대신 롤링() 계산을 사용하세요. 예: "),n("code",null," dataframe['volume'].rolling(<window>).mean() "),a(" . ")],-1)),s[56]||(s[56]=n("li",null,[n("code",null," .resample('1h') "),a(" 를 사용하지 마세요. 이는 기간 간격의 왼쪽 경계를 사용하므로, 데이터를 시간의 시작으로 이동합니다. 대신 "),n("code",null," .resample('1h', label='right') "),a(" 를 사용하세요. ")],-1))]),n("div",u,[s[62]||(s[62]=n("p",{class:"admonition-title"},"문제 식별",-1)),n("p",null,[s[59]||(s[59]=a(" 항상 두 가지 도우미 명령어를 사용해야 합니다. ")),l(p,{to:"lookahead-analysis"},{default:c(()=>s[57]||(s[57]=[a(" lookahead-analysis ")])),_:1}),s[60]||(s[60]=a(" 및 ")),l(p,{to:"recursive-analysis"},{default:c(()=>s[58]||(s[58]=[a(" recursive-analysis ")])),_:1}),s[61]||(s[61]=a(" . 이는 각기 다른 방식으로 전략의 문제를 파악하는 데 도움이 될 수 있습니다. 이를 문제를 식별하는 도구로 사용하세요. 각 명령어의 부정적인 결과가 포함된다고 해서 위의 오류가 포함되지 않았음을 보장하지 않습니다. "))])]),s[80]||(s[80]=e('<h3 id="colliding-signals"> 신호 충돌 <a class="headerlink" href="#colliding-signals" title="영구 링크"> ¶ </a></h3><p> 충돌하는 신호가 충돌할 때(예: <code> &#39;enter_long&#39; </code> 과 <code> &#39;exit_long&#39; </code> 이 모두 <code> 1 </code> 로 설정된 경우), freqtrade는 아무 작업도 하지 않고 진입 신호를 무시합니다. 이는 즉시 진입하고 청산하는 거래를 방지합니다. 물론, 이는 진입을 놓칠 수 있습니다. </p><p>다음 규칙이 적용되며, 세 가지 신호 중 하나 이상이 설정된 경우 진입 신호가 무시됩니다:</p><ul><li><code> enter_long </code> -&gt; <code> exit_long </code> , <code> enter_short </code></li><li><code> enter_short </code> -&gt; <code> exit_short </code> , <code> enter_long </code></li></ul><h2 id="further-strategy-ideas"> 추가 전략 아이디어 <a class="headerlink" href="#further-strategy-ideas" title="영구 링크"> ¶ </a></h2><p> 추가 전략 아이디어를 얻으려면 <a href="https://github.com/freqtrade/freqtrade-strategies"> 전략 저장소 </a> 로 이동하세요. 학습 목적으로만 사용해야 하며, 실제 거래에는 사용하지 마세요. 전략을 먼저 백테스트하고, 드라이런을 통해 신중하게 평가한 후 사용하세요. 사용에 따른 위험은 사용자에게 있습니다. </p><p>이들 중 어떤 것을 영감을 받아 자신의 전략으로 사용할 수 있습니다. 새로운 전략을 저장소에 추가하는 Pull Request를 환영합니다.</p><h2 id="next-steps"> 다음 단계 <a class="headerlink" href="#next-steps" title="영구 링크"> ¶ </a></h2>',8)),n("p",null,[s[64]||(s[64]=a(" 이제 완벽한 전략을 가지고 있으므로 백테스트를 수행하고 싶을 것입니다. 다음 단계는 ")),l(p,{to:"backtesting"},{default:c(()=>s[63]||(s[63]=[a(" 백테스팅 사용 방법 ")])),_:1}),s[65]||(s[65]=a(" 을 배우는 것입니다. "))])])}}};export{_ as default};
