import{r as s,o as l,c as d,b as t,d as i,e as o,w as n,a as r}from"./index-1f8801f6.js";const c={class:"md-content__inner md-typeset"},p={class:"admonition tip"},v={__name:"SQLCheatsheet",setup(h){return(g,e)=>{const a=s("router-link");return l(),d("article",c,[e[4]||(e[4]=t("h1",{id:"sql-helper"},[i(" SQL 도우미 "),t("a",{class:"headerlink",href:"#sql-helper",title:"영구 링크"}," ¶ ")],-1)),e[5]||(e[5]=t("p",null,"이 페이지는 SQLite 데이터베이스를 쿼리할 때 도움이 되는 내용을 포함하고 있습니다.",-1)),t("div",p,[e[3]||(e[3]=t("p",{class:"admonition-title"},"다른 데이터베이스 시스템",-1)),t("p",null,[e[1]||(e[1]=i(" PostgreSQL 또는 MariaDB와 같은 다른 데이터베이스 시스템을 사용하려면 동일한 쿼리를 사용할 수 있지만, 해당 데이터베이스 시스템의 클라이언트를 사용해야 합니다. ")),o(a,{to:"advanced-setup"},{default:n(()=>e[0]||(e[0]=[i("여기를 클릭")])),_:1}),e[2]||(e[2]=i("하여 freqtrade에서 다른 데이터베이스 시스템을 설정하는 방법을 알아보세요. "))])]),e[6]||(e[6]=r(`<div class="admonition warning"><p class="admonition-title">경고</p><p> SQL에 익숙하지 않은 경우 데이터베이스에서 쿼리를 실행할 때 매우 주의해야 합니다. <br> 쿼리를 실행하기 전에 항상 데이터베이스 백업을 만들어 두세요. </p></div><h2 id="install-sqlite3"> SQLite3 설치 <a class="headerlink" href="#install-sqlite3" title="영구 링크"> ¶ </a></h2><p>SQLite3는 터미널 기반 SQLite 애플리케이션입니다. 더 편리하게 사용하려면 SQLiteBrowser와 같은 시각적 데이터베이스 편집기를 사용할 수 있습니다.</p><h3 id="ubuntudebian-installation"> Ubuntu/Debian 설치 <a class="headerlink" href="#ubuntudebian-installation" title="영구 링크"> ¶ </a></h3><div class="highlight"><pre><code>sudo apt-get install sqlite3</code></pre></div><h3 id="using-sqlite3-via-docker"> Docker를 통한 sqlite3 사용 <a class="headerlink" href="#using-sqlite3-via-docker" title="영구 링크"> ¶ </a></h3><p>freqtrade Docker 이미지에는 sqlite3가 포함되어 있으므로 호스트 시스템에 아무것도 설치하지 않고 데이터베이스를 편집할 수 있습니다.</p><div class="highlight"><pre><code>docker compose exec freqtrade /bin/bash
sqlite3 &gt;database-file&lt;.sqlite</code></pre></div><h2 id="open-the-db"> DB 열기 <a class="headerlink" href="#open-the-db" title="영구 링크"> ¶ </a></h2><div class="highlight"><pre><code>sqlite3
.open &gt;filepath&lt;</code></pre></div><h2 id="table-structure"> 테이블 구조 <a class="headerlink" href="#table-structure" title="영구 링크"> ¶ </a></h2><h3 id="list-tables"> 테이블 목록 <a class="headerlink" href="#list-tables" title="영구 링크"> ¶ </a></h3><div class="highlight"><pre><code>.tables</code></pre></div><h3 id="display-table-structure"> 테이블 구조 표시 <a class="headerlink" href="#display-table-structure" title="영구 링크"> ¶ </a></h3><div class="highlight"><pre><code>.schema &gt;table_name&lt;</code></pre></div><h3 id="get-all-trades-in-the-table"> 테이블의 모든 거래 가져오기 <a class="headerlink" href="#get-all-trades-in-the-table" title="영구 링크"> ¶ </a></h3><div class="highlight"><pre><code>SELECT * FROM trades;</code></pre></div><h2 id="destructive-queries"> 데이터 수정 쿼리 <a class="headerlink" href="#destructive-queries" title="영구 링크"> ¶ </a></h2><p>데이터베이스에 쓰기를 수행하는 쿼리입니다. freqtrade는 모든 데이터베이스 작업을 자체적으로 처리하거나 API 또는 텔레그램 명령을 통해 노출하려고 하므로 이러한 쿼리는 일반적으로 필요하지 않습니다.</p><div class="admonition warning"><p class="admonition-title">경고</p><p>아래 쿼리를 실행하기 전에 데이터베이스 백업을 반드시 만들어 두세요.</p></div><div class="admonition danger"><p class="admonition-title">위험</p><p>데이터베이스에 연결된 봇이 있는 동안 쓰기 쿼리(<code>update</code>, <code>insert</code>, <code>delete</code>)를 절대 실행하지 마세요. 이는 데이터 손상으로 이어질 수 있으며, 복구가 불가능할 가능성이 높습니다.</p></div><h3 id="fix-trade-still-open-after-a-manual-exit-on-the-exchange"> 거래소에서 수동 종료 후 여전히 열려 있는 거래 수정 <a class="headerlink" href="#fix-trade-still-open-after-a-manual-exit-on-the-exchange" title="영구 링크"> ¶ </a></h3><div class="admonition warning"><p class="admonition-title">경고</p><p> 거래소에서 거래 쌍을 수동으로 판매하면 봇이 이를 감지하지 못하며 여전히 판매를 시도합니다. 가능한 경우 <code>/forceexit &gt;tradeid&lt;</code>를 사용하여 동일한 작업을 수행하는 것이 좋습니다. <br> 수동으로 변경하기 전에 데이터베이스 파일을 백업하는 것이 강력히 권장됩니다. </p></div><div class="admonition note"><p class="admonition-title">참고</p><p>/forceexit 이후에는 필요하지 않습니다. force_exit 명령은 다음 반복 시 봇에 의해 자동으로 닫힙니다.</p></div><div class="highlight"><pre><code>UPDATE trades
SET is_open=0,
  close_date=&gt;close_date&lt;,
  close_rate=&gt;close_rate&lt;,
  close_profit = close_rate / open_rate - 1,
  close_profit_abs = (amount * &gt;close_rate&lt; * (1 - fee_close) - (amount * (open_rate * (1 - fee_open)))),
  exit_reason=&gt;exit_reason&lt;
WHERE id=&gt;trade_ID_to_update&lt;;</code></pre></div><h4 id="example"> 예제 <a class="headerlink" href="#example" title="영구 링크"> ¶ </a></h4><div class="highlight"><pre><code>UPDATE trades
SET is_open=0,
  close_date=&#39;2020-06-20 03:08:45.103418&#39;,
  close_rate=0.19638016,
  close_profit=0.0496,
  close_profit_abs = (amount * 0.19638016 * (1 - fee_close) - (amount * (open_rate * (1 - fee_open)))),
  exit_reason=&#39;force_exit&#39;
WHERE id=31;</code></pre></div><h3 id="remove-trade-from-the-database"> 데이터베이스에서 거래 제거 <a class="headerlink" href="#remove-trade-from-the-database" title="영구 링크"> ¶ </a></h3><div class="admonition tip"><p class="admonition-title">RPC 메서드를 사용하여 거래 삭제</p><p>텔레그램 또는 REST API를 통해 <code>/delete &lt;tradeid&gt;</code>를 사용하는 것이 권장됩니다.</p></div><p>여전히 데이터베이스에서 거래를 직접 제거하려면 아래 쿼리를 사용할 수 있습니다.</p><div class="admonition danger"><p class="admonition-title">위험</p><p>일부 시스템(Ubuntu)은 sqlite3 패키징에서 외래 키를 비활성화합니다. sqlite를 사용할 때 위 쿼리를 실행하기 전에 <code>PRAGMA foreign_keys = ON</code>을 실행하여 외래 키가 활성화되어 있는지 확인하세요.</p></div><div class="highlight"><pre><code>DELETE FROM trades WHERE id=&gt;tradeid&lt;;

DELETE FROM trades WHERE id=31;</code></pre></div><div class="admonition warning"><p class="admonition-title">경고</p><p>이 쿼리는 데이터베이스에서 해당 거래를 제거합니다. 올바른 ID를 선택했는지 확인하고 <strong>절대</strong> <code>where</code> 절 없이 이 쿼리를 실행하지 마세요.</p></div>`,33))])}}};export{v as default};
