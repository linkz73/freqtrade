import{o,c as i,a as t}from"./index-1d9d7dc5.js";const c={class:"md-content__inner md-typeset"},a={__name:"BotBasics",setup(l){return(d,e)=>(o(),i("article",c,e[0]||(e[0]=[t('<h1 id="freqtrade-basics"> Freqtrade 기본 개념 <a class="headerlink" href="#freqtrade-basics" title="영구 링크"> ¶ </a></h1><p>이 페이지는 Freqtrade가 작동하고 운영되는 기본 개념을 제공합니다.</p><h2 id="freqtrade-terminology"> Freqtrade 용어 <a class="headerlink" href="#freqtrade-terminology" title="영구 링크"> ¶ </a></h2><ul><li><strong> 전략 (Strategy) </strong> : 봇이 무엇을 해야 하는지 알려주는 거래 전략. </li><li><strong> 거래 (Trade) </strong> : 열린 포지션. </li><li><strong> 미체결 주문 (Open Order) </strong> : 현재 거래소에 배치되었지만 아직 완료되지 않은 주문. </li><li><strong> 거래쌍 (Pair) </strong> : 거래 가능한 쌍, 일반적으로 Base/Quote 형식 (예: <code> XRP/USDT </code> 는 현물, <code> XRP/USDT:USDT </code> 는 선물). </li><li><strong> 시간 프레임 (Timeframe) </strong> : 사용할 캔들 길이 (예: <code> &quot;5m&quot; </code> , <code> &quot;1h&quot; </code> , ...). </li><li><strong> 지표 (Indicators) </strong> : 기술적 지표 (SMA, EMA, RSI, ...). </li><li><strong> 지정가 주문 (Limit order) </strong> : 정의된 지정가 또는 더 나은 가격에서 실행되는 주문. </li><li><strong> 시장가 주문 (Market order) </strong> : 반드시 체결되며, 주문 크기에 따라 가격이 움직일 수 있음. </li><li><strong> 현재 수익 (Current Profit) </strong> : 현재 대기 중인 (미실현) 거래 수익. 주로 봇과 UI에서 사용됨. </li><li><strong> 실현 수익 (Realized Profit) </strong> : 이미 실현된 수익. 주로 <a href="strategy-callbacks.html"> 부분 청산 </a> 과 관련이 있으며, 계산 로직도 설명됨. </li><li><strong> 총 수익 (Total Profit) </strong> : 실현 및 미실현 수익의 합계. 이 비율 (%)은 해당 거래의 총 투자 대비로 계산됨. </li></ul><h2 id="fee-handling"> 수수료 처리 <a class="headerlink" href="#fee-handling" title="영구 링크"> ¶ </a></h2><p>Freqtrade의 모든 수익 계산에는 수수료가 포함됩니다. 백테스팅 / 하이퍼옵트 / 드라이런 모드에서는 거래소 기본 수수료(거래소의 최저 등급)가 사용됩니다. 라이브 운영에서는 거래소에서 적용된 수수료(BNB 리베이트 등 포함)가 사용됩니다.</p><h2 id="pair-naming"> 거래쌍 명명 규칙 <a class="headerlink" href="#pair-naming" title="영구 링크"> ¶ </a></h2><p> Freqtrade는 <a href="https://docs.ccxt.com/#/README?id=consistency-of-base-and-quote-currencies"> ccxt 명명 규칙 </a> 을 따릅니다. 잘못된 명명 규칙을 사용하면 봇이 거래쌍을 인식하지 못해 &quot;이 거래쌍은 사용할 수 없습니다&quot;와 같은 오류가 발생할 수 있습니다. </p><h3 id="spot-pair-naming"> 현물 거래쌍 명명 <a class="headerlink" href="#spot-pair-naming" title="영구 링크"> ¶ </a></h3><p> 현물 거래쌍의 명명은 <code> base/quote </code> 형식입니다 (예: <code> ETH/USDT </code> ). </p><h3 id="futures-pair-naming"> 선물 거래쌍 명명 <a class="headerlink" href="#futures-pair-naming" title="영구 링크"> ¶ </a></h3><p> 선물 거래쌍의 명명은 <code> base/quote:settle </code> 형식입니다 (예: <code> ETH/USDT:USDT </code> ). </p><h2 id="bot-execution-logic"> 봇 실행 로직 <a class="headerlink" href="#bot-execution-logic" title="영구 링크"> ¶ </a></h2><p> 드라이런 또는 라이브 모드에서 freqtrade를 시작하면 ( <code> freqtrade trade </code> 사용) 봇이 시작되고 봇 반복 루프가 시작됩니다. 이때 <code> bot_start() </code> 콜백도 실행됩니다. </p><p> 기본적으로 봇 루프는 몇 초마다 ( <code> internals.process_throttle_secs </code> ) 실행되며 다음 작업을 수행합니다: </p><ul><li>영구 저장소에서 열린 거래를 가져옵니다.</li><li>현재 거래 가능한 거래쌍 목록을 계산합니다.</li><li> 거래쌍 목록에 대한 OHLCV 데이터를 다운로드하고 모든 <a href="strategy-customization.html"> 정보 제공 거래쌍 </a> 을 포함합니다. <br> 이 단계는 불필요한 네트워크 트래픽을 피하기 위해 캔들당 한 번만 실행됩니다. </li><li><code> bot_loop_start() </code> 전략 콜백을 호출합니다. </li><li> 거래쌍별로 전략을 분석합니다. <ul><li><code> populate_indicators() </code> 를 호출합니다. </li><li><code> populate_entry_trend() </code> 를 호출합니다. </li><li><code> populate_exit_trend() </code> 를 호출합니다. </li></ul></li><li> 거래소에서 열린 주문 상태를 업데이트합니다. <ul><li><code> order_filled() </code> 전략 콜백을 호출하여 체결된 주문을 처리합니다. </li><li> 열린 주문의 타임아웃을 확인합니다. <ul><li><code> check_entry_timeout() </code> 전략 콜백을 호출하여 열린 진입 주문을 확인합니다. </li><li><code> check_exit_timeout() </code> 전략 콜백을 호출하여 열린 종료 주문을 확인합니다. </li><li><code> adjust_order_price() </code> 전략 콜백을 호출하여 열린 주문의 가격을 조정합니다. <ul><li><code> adjust_entry_price() </code> 전략 콜백을 호출하여 열린 진입 주문의 가격을 조정합니다. <em><code> adjust_order_price() </code> 가 구현되지 않은 경우에만 호출됩니다. </em></li><li><code> adjust_exit_price() </code> 전략 콜백을 호출하여 열린 종료 주문의 가격을 조정합니다. <em><code> adjust_order_price() </code> 가 구현되지 않은 경우에만 호출됩니다. </em></li></ul></li></ul></li></ul></li><li> 기존 포지션을 확인하고 종료 주문을 배치합니다. <ul><li> 손절매, ROI 및 종료 신호를 고려하고, <code> custom_exit() </code> 와 <code> custom_stoploss() </code> 를 사용합니다. </li><li><code> exit_pricing </code> 구성 설정을 기반으로 종료 가격을 결정하거나 <code> custom_exit_price() </code> 콜백을 사용하여 결정합니다. </li><li> 종료 주문이 배치되기 전에, <code> confirm_trade_exit() </code> 전략 콜백이 호출됩니다. </li></ul></li><li>열린 거래에 대한 포지션 조정을 확인하고 필요한 경우 추가 주문을 배치합니다.</li><li> 거래 슬롯이 여전히 사용 가능한지 확인합니다 ( <code> max_open_trades </code> 가 도달했는지 확인). </li><li> 새 포지션에 진입하려고 진입 신호를 확인합니다. <ul><li><code> entry_pricing </code> 구성 설정을 기반으로 진입 가격을 결정하거나 <code> custom_entry_price() </code> 콜백을 사용하여 결정합니다. </li><li> 마진 및 선물 모드에서, <code> leverage() </code> 전략 콜백이 호출되어 원하는 레버리지를 결정합니다. </li><li><code> custom_stake_amount() </code> 콜백을 호출하여 스테이크 크기를 결정합니다. </li><li> 진입 주문이 배치되기 전에, <code> confirm_trade_entry() </code> 전략 콜백이 호출됩니다. </li></ul></li></ul><p>이 루프는 봇이 중지될 때까지 반복됩니다.</p><h2 id="backtesting-hyperopt-execution-logic"> 백테스팅 / 하이퍼옵트 실행 로직 <a class="headerlink" href="#backtesting-hyperopt-execution-logic" title="영구 링크"> ¶ </a></h2><p><a href="backtesting.html"> 백테스팅 </a> 또는 <a href="hyperopt.html"> 하이퍼옵트 </a> 는 위의 로직 중 일부만 수행합니다. 대부분의 거래 작업은 완전히 시뮬레이션됩니다. </p><ul><li>구성된 거래쌍 목록에 대한 과거 데이터를 로드합니다.</li><li><code> bot_start() </code> 를 한 번 호출합니다. </li><li> 지표를 계산합니다 ( <code> populate_indicators() </code> 를 거래쌍별로 한 번 호출). </li><li> 진입 / 종료 신호를 계산합니다 ( <code> populate_entry_trend() </code> 와 <code> populate_exit_trend() </code> 를 거래쌍별로 한 번 호출). </li><li> 캔들별로 루프를 돌며 진입 및 종료 지점을 시뮬레이션합니다. <ul><li><code> bot_loop_start() </code> 전략 콜백을 호출합니다. </li><li> 주문 타임아웃을 확인합니다. 구성된 <code> unfilledtimeout </code> 또는 <code> check_entry_timeout() </code> / <code> check_exit_timeout() </code> 전략 콜백을 통해 확인합니다. </li><li><code> adjust_order_price() </code> 전략 콜백을 호출하여 열린 주문의 가격을 조정합니다. <ul><li><code> adjust_entry_price() </code> 전략 콜백을 호출하여 열린 진입 주문의 가격을 조정합니다. <em><code> adjust_order_price() </code> 가 구현되지 않은 경우에만 호출됩니다. </em></li><li><code> adjust_exit_price() </code> 전략 콜백을 호출하여 열린 종료 주문의 가격을 조정합니다. <em><code> adjust_order_price() </code> 가 구현되지 않은 경우에만 호출됩니다. </em></li></ul></li><li> 거래 진입 신호를 확인합니다 ( <code> enter_long </code> / <code> enter_short </code> 열). </li><li> 거래 진입 / 종료를 확인합니다 ( <code> confirm_trade_entry() </code> 와 <code> confirm_trade_exit() </code> 전략에 구현된 경우 호출). </li><li> 진입 가격을 결정하기 위해 <code> custom_entry_price() </code> 를 호출합니다 (전략에 구현된 경우). 가격은 개봉 캔들 내에서 이동됩니다. </li><li> 마진 및 선물 모드에서, <code> leverage() </code> 전략 콜백이 호출되어 원하는 레버리지를 결정합니다. </li><li><code> custom_stake_amount() </code> 콜백을 호출하여 스테이크 크기를 결정합니다. </li><li> 열린 거래에 대한 포지션 조정을 확인하고 <code> adjust_trade_position() </code> 을 호출하여 추가 주문이 필요한지 확인합니다. </li><li> 체결된 진입 주문에 대해 <code> order_filled() </code> 전략 콜백을 호출합니다. </li><li><code> custom_stoploss() </code> 와 <code> custom_exit() </code> 를 호출하여 사용자 정의 종료 지점을 찾습니다. </li><li> 종료 신호, 사용자 정의 종료 및 부분 종료를 기반으로 종료할 경우: <code> custom_exit_price() </code> 를 호출하여 종료 가격을 결정합니다 (가격은 닫는 캔들 내에서 이동됩니다). </li><li> 체결된 종료 주문에 대해 <code> order_filled() </code> 전략 콜백을 호출합니다. </li></ul></li><li>백테스트 보고서 출력을 생성합니다.</li></ul><div class="admonition note"><p class="admonition-title">참고</p><p> 백테스팅과 하이퍼옵트 모두 계산에 거래소 기본 수수료를 포함합니다. 사용자 정의 수수료는 <code> --fee </code> 인수를 지정하여 백테스팅 / 하이퍼옵트에 전달할 수 있습니다. </p></div><div class="admonition warning"><p class="admonition-title">콜백 호출 빈도</p><p> 백테스팅은 각 콜백을 최대 캔들당 한 번 호출합니다 ( <code> --timeframe-detail </code> 은 이 동작을 자세한 캔들당 한 번으로 수정합니다). 대부분의 콜백은 라이브에서 한 번의 반복마다 호출됩니다 (보통 약 5초마다) - 이는 백테스팅 불일치를 초래할 수 있습니다. </p></div>',22)])))}};export{a as default};
