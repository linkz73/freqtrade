import{_ as e}from"./_plugin-vue_export-helper-c27b6911.js";import{r as d,o as r,c as u,a as o,b as s,d as l,e as a,w as p}from"./index-a1bb88b6.js";const i={},g={class:"md-content__inner md-typeset"},m={class:"admonition tip"},f={class:"admonition tip"},q={class:"admonition note"};function b(c,n){const t=d("router-link");return r(),u("article",g,[n[425]||(n[425]=o(`<h1 id="configure-the-bot">봇 설정하기</h1><p>Freqtrade는 다양한 설정 기능과 옵션을 제공합니다. 기본적으로 이러한 설정은 설정 파일을 통해 구성됩니다(아래 참조).</p><h2 id="the-freqtrade-configuration-file"> Freqtrade 설정 파일 <a class="headerlink" href="#the-freqtrade-configuration-file" title="영구 링크"></a></h2><p>봇은 실행 중에 설정 파일(Freqtrade 설정 파일)에서 읽어오는 설정 매개변수를 사용합니다. 기본적으로 현재 작업 디렉토리에 있는 파일에서 설정을 불러옵니다.</p><p>명령줄 옵션을 사용하여 봇이 사용할 다른 설정 파일을 지정할 수 있습니다.</p><p> Docker 빠른 시작 방법으로 봇을 설치한 경우, 설치 스크립트가 기본 설정 파일( <code>config.json</code>)을 이미 생성했을 것입니다. </p><p> 기본 설정 파일이 생성되지 않은 경우, 기본 설정 파일을 생성하기 위해 <code>freqtrade new-config</code> 명령을 사용하는 것을 권장합니다. </p><p>Freqtrade 설정 파일은 JSON 형식으로 작성해야 합니다.</p><p>표준 JSON 구문 외에도, 설정 파일에서 한 줄 및 여러 줄 주석과 매개변수 목록의 후행 쉼표를 사용할 수 있습니다.</p><p>JSON 형식에 익숙하지 않더라도 걱정하지 마세요. 원하는 편집기로 설정 파일을 열고 필요한 매개변수를 변경한 후 저장하세요. 그런 다음 봇을 다시 시작하거나, 중지된 경우 변경 사항을 반영하여 다시 실행하면 됩니다. 봇은 시작 시 설정 파일의 구문을 검증하며, 편집 중 오류가 발생한 경우 문제가 있는 줄을 알려줍니다.</p><h3 id="environment-variables"> 환경 변수 <a class="headerlink" href="#environment-variables" title="영구 링크"></a></h3><p>환경 변수를 통해 Freqtrade 설정의 옵션을 설정할 수 있습니다. 이는 설정 파일이나 전략의 해당 값을 우선합니다.</p><p> 환경 변수는 <code>FREQTRADE__</code>로 시작해야 freqtrade 설정에 로드됩니다. </p><p><code>__</code>는 레벨 구분자로 사용되므로, 사용 형식은 <code>FREQTRADE__{section}__{key}</code>에 해당해야 합니다. 따라서 <code>export FREQTRADE__STAKE_AMOUNT=200</code>로 정의된 환경 변수는 <code>{stake_amount: 200}</code>이 됩니다.</p><p> 더 복잡한 예로는 <code>export FREQTRADE__EXCHANGE__KEY=&lt;yourExchangeKey&gt;</code>를 사용하여 거래소 키를 비밀로 유지할 수 있습니다. 이 값은 설정의 <code>exchange.key</code> 섹션으로 이동합니다. 이 스키마를 사용하면 모든 설정 옵션이 환경 변수로도 사용할 수 있습니다. </p><p>환경 변수는 설정 파일의 해당 설정을 덮어쓰지만, 명령줄 인수가 항상 우선합니다.</p><p>일반적인 예:</p><div class="highlight"><pre><code><span class="nv">FREQTRADE__TELEGRAM__CHAT_ID</span><span class="o">=</span>&lt;telegramchatid&gt;
<span class="nv">FREQTRADE__TELEGRAM__TOKEN</span><span class="o">=</span>&lt;telegramToken&gt;
<span class="nv">FREQTRADE__EXCHANGE__KEY</span><span class="o">=</span>&lt;yourExchangeKey&gt;
<span class="nv">FREQTRADE__EXCHANGE__SECRET</span><span class="o">=</span>&lt;yourExchangeSecret&gt;
</code></pre></div><p>Json 목록은 json으로 구문 분석되므로, 다음과 같이 쌍 목록을 설정할 수 있습니다:</p><div class="highlight"><pre><code><span class="nb">export</span><span class="w"> </span><span class="nv">FREQTRADE__EXCHANGE__PAIR_WHITELIST</span><span class="o">=</span><span class="s1">&#39;[&quot;BTC/USDT&quot;, &quot;ETH/USDT&quot;]&#39;</span>
</code></pre></div><div class="admonition note"><p class="admonition-title">참고</p><p>감지된 환경 변수는 시작 시 기록되므로, 값이 설정 파일과 다를 경우 환경 변수에서 로드되지 않는지 확인하세요.</p></div>`,21)),s("div",m,[n[3]||(n[3]=s("p",{class:"admonition-title"},"결합된 결과 검증",-1)),s("p",null,[n[1]||(n[1]=l(" 최종 결합된 설정을 보려면 ")),a(t,{to:"utils"},{default:p(()=>n[0]||(n[0]=[l(" show-config 하위 명령어 ")])),_:1}),n[2]||(n[2]=l(" 를 사용할 수 있습니다. "))])]),n[426]||(n[426]=o('<details class="warning"><summary>로딩 순서</summary><p> 환경 변수는 초기 설정 후에 로드됩니다. 따라서 환경 변수를 통해 설정 경로를 제공할 수 없습니다. 이를 위해 <code>--config path/to/config.json</code>을 사용하세요. 이것은 <code>user_dir</code>에도 어느 정도 적용됩니다. 사용자 디렉토리는 환경 변수를 통해 설정할 수 있지만, 설정은 해당 위치에서 로드되지 않습니다. </p></details><h3 id="multiple-configuration-files"> 다중 설정 파일 <a class="headerlink" href="#multiple-configuration-files" title="영구 링크"></a></h3><p>봇은 여러 설정 파일을 지정하고 사용할 수 있으며, 프로세스 표준 입력 스트림에서 설정 매개변수를 읽을 수 있습니다.</p><p><code>add_config_files</code>에 추가 설정 파일을 지정할 수 있습니다. 이 매개변수에 지정된 파일은 초기 설정 파일과 병합되어 로드됩니다. 이는 여러 <code>--config</code> 매개변수를 사용하는 것과 유사하지만, 모든 명령에 대해 모든 파일을 지정할 필요가 없으므로 더 간단합니다.</p>',4)),s("div",f,[n[7]||(n[7]=s("p",{class:"admonition-title"},"결합된 결과 검증",-1)),s("p",null,[n[5]||(n[5]=l(" 최종 결합된 설정을 보려면 ")),a(t,{to:"utils"},{default:p(()=>n[4]||(n[4]=[l(" show-config 하위 명령어 ")])),_:1}),n[6]||(n[6]=l(" 를 사용할 수 있습니다. "))])]),n[427]||(n[427]=o(`<div class="admonition tip"><p class="admonition-title">비밀을 유지하기 위해 여러 설정 파일 사용</p><p> 비밀을 포함하는 두 번째 설정 파일을 사용할 수 있습니다. 이렇게 하면 &quot;기본&quot; 설정 파일을 공유하면서도 API 키를 비공개로 유지할 수 있습니다. 두 번째 파일은 덮어쓰려는 항목만 지정해야 합니다. 키가 여러 설정에 있는 경우, &quot;마지막으로 지정된 설정&quot;이 우선합니다(위 예제에서는 <code>config-private.json</code>). </p><p>일회성 명령의 경우, 여러 &quot;--config&quot; 매개변수를 지정하여 아래 구문을 사용할 수도 있습니다.</p><div class="highlight"><pre><code>freqtrade trade --config user_data/config1.json --config user_data/config-private.json &lt;...&gt;
</code></pre></div><p>아래는 위 예제와 동일하지만, 재사용을 위해 두 개의 설정 파일을 설정에 포함한 것입니다.</p><div class="highlight"><span class="filename"> user_data/config.json </span><pre><code><span class="nt">&quot;add_config_files&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">    </span><span class="s2">&quot;config1.json&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="s2">&quot;config-private.json&quot;</span>
<span class="p">]</span>
</code></pre></div><div class="highlight"><pre><code>freqtrade trade --config user_data/config.json &lt;...&gt;
</code></pre></div></div><details class="note"><summary>설정 충돌 처리</summary><p> 동일한 설정이 <code>config.json</code>과 <code>config-import.json</code>에 모두 있는 경우, 상위 설정이 우선합니다. 아래의 경우, 재사용 가능한 &quot;import&quot; 설정이 이 키를 덮어쓰므로 <code>max_open_trades</code>는 병합 후 3이 됩니다. </p><div class="highlight"><span class="filename"> user_data/config.json </span><pre><code><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;max_open_trades&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;stake_currency&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;USDT&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;add_config_files&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">        </span><span class="s2">&quot;config-import.json&quot;</span>
<span class="w">    </span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><span class="filename"> user_data/config-import.json </span><pre><code><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;max_open_trades&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;stake_amount&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;unlimited&quot;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div><p>결과 결합된 설정:</p><div class="highlight"><span class="filename"> 결과 </span><pre><code><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;max_open_trades&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;stake_currency&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;USDT&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;stake_amount&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;unlimited&quot;</span>
<span class="p">}</span>
</code></pre></div><p><code>add_config_files</code> 섹션에 여러 파일이 있는 경우, 동일한 수준으로 간주되며, 마지막에 지정된 설정이 이전 설정을 덮어씁니다(상위 설정이 이미 해당 키를 정의하지 않은 경우).</p></details><h2 id="editor-autocomplete-and-validation"> 편집기 자동 완성 및 검증 <a class="headerlink" href="#editor-autocomplete-and-validation" title="영구 링크"></a></h2><p>JSON 스키마를 지원하는 편집기를 사용하는 경우, Freqtrade에서 제공하는 스키마를 사용하여 설정 파일의 자동 완성 및 검증을 받을 수 있습니다. 설정 파일 상단에 다음 줄을 추가하세요:</p><div class="highlight"><pre><code><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;$schema&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;https://schema.freqtrade.io/schema.json&quot;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div><details class="note"><summary>개발 버전</summary><p> 개발 스키마는 <code>https://schema.freqtrade.io/schema_dev.json</code>으로 제공됩니다. 최상의 경험을 위해 안정적인 버전을 사용하는 것이 좋습니다. </p></details><h2 id="configuration-parameters"> 설정 매개변수 <a class="headerlink" href="#configuration-parameters" title="영구 링크"></a></h2><p>아래 표에는 사용 가능한 모든 설정 매개변수가 나열됩니다.</p><p> Freqtrade는 명령줄(CLI) 인수를 통해 많은 옵션을 로드할 수도 있습니다(자세한 내용은 명령어 <code>--help</code> 출력을 확인하세요). </p><h3 id="configuration-option-prevalence"> 설정 옵션 우선 순위 <a class="headerlink" href="#configuration-option-prevalence" title="영구 링크"></a></h3><p>모든 옵션의 우선 순위는 다음과 같습니다:</p><ul><li>CLI 인수가 다른 모든 옵션을 덮어씁니다.</li><li><a href="#environment-variables"> 환경 변수 </a></li><li>설정 파일은 순서대로 사용되며(마지막 파일이 우선) 전략 설정을 덮어씁니다.</li><li> 전략 설정은 설정 파일이나 명령줄 인수를 통해 설정되지 않은 경우에만 사용됩니다. 이러한 옵션은 아래 표에서 <a href="#parameters-in-the-strategy"> 전략 덮어쓰기 </a> 로 표시됩니다. </li></ul><h3 id="parameters-table"> 매개변수 표 <a class="headerlink" href="#parameters-table" title="영구 링크"></a></h3><p> 필수 매개변수는 <strong> 필수 </strong> 로 표시되며, 이는 가능한 방법 중 하나로 설정해야 함을 의미합니다. </p>`,14)),s("table",null,[n[392]||(n[392]=s("thead",null,[s("tr",null,[s("th",null,"매개변수"),s("th",null,"설명")])],-1)),s("tbody",null,[n[305]||(n[305]=s("tr",null,[s("td",null,[s("code",null," max_open_trades ")]),s("td",null,[s("strong",null," 필수. "),l(" 봇이 허용하는 최대 오픈 거래 수입니다. 한 거래 쌍당 하나의 오픈 거래만 가능하므로, 거래 쌍 목록의 길이가 적용될 수 있는 또 다른 제한 사항입니다. -1인 경우 무시됩니다(즉, 거래 쌍 목록에 의해 제한된 무제한 오픈 거래 가능). "),s("a",{href:"#configuring-amount-per-trade"}," 자세한 정보는 아래 참조 "),l(" . "),s("a",{href:"#parameters-in-the-strategy"}," 전략 덮어쓰기 "),l(" . "),s("br"),s("strong",null," 데이터 유형: "),l(" 양의 정수 또는 -1. ")])],-1)),n[306]||(n[306]=s("tr",null,[s("td",null,[s("code",null," stake_currency ")]),s("td",null,[s("strong",null," 필수. "),l(" 거래에 사용되는 암호화폐. "),s("br"),s("strong",null," 데이터 유형: "),l(" 문자열 ")])],-1)),n[307]||(n[307]=s("tr",null,[s("td",null,[s("code",null," stake_amount ")]),s("td",null,[s("strong",null," 필수. "),l(" 봇이 각 거래에 사용할 암호화폐의 양입니다. "),s("code",null,' "unlimited" '),l(" 로 설정하여 봇이 사용 가능한 모든 잔액을 사용하도록 할 수 있습니다. "),s("a",{href:"#configuring-amount-per-trade"}," 자세한 정보는 아래 참조 "),l(" . "),s("br"),s("strong",null," 데이터 유형: "),l(" 양의 부동 소수점 또는 "),s("code",null,' "unlimited" '),l(" . ")])],-1)),n[308]||(n[308]=s("tr",null,[s("td",null,[s("code",null," tradable_balance_ratio ")]),s("td",null,[l(" 봇이 거래할 수 있는 총 계정 잔액의 비율입니다. "),s("a",{href:"#configuring-amount-per-trade"}," 자세한 정보는 아래 참조 "),l(" . "),s("br"),s("em",null,[l(" 기본값은 "),s("code",null," 0.99 "),l(" (99%)입니다. ")]),s("br"),s("strong",null," 데이터 유형: "),s("code",null," 0.1 "),l(" 과 "),s("code",null," 1.0 "),l(" 사이의 양의 부동 소수점. ")])],-1)),n[309]||(n[309]=s("tr",null,[s("td",null,[s("code",null," available_capital ")]),s("td",null,[l(" 봇의 시작 자본을 사용할 수 있습니다. 동일한 거래소 계정에서 여러 봇을 실행할 때 유용합니다. "),s("a",{href:"#configuring-amount-per-trade"}," 자세한 정보는 아래 참조 "),l(" . "),s("br"),s("strong",null," 데이터 유형: "),l(" 양의 부동 소수점. ")])],-1)),n[310]||(n[310]=s("tr",null,[s("td",null,[s("code",null," amend_last_stake_amount ")]),s("td",null,[l(" 필요한 경우 마지막 스테이크 금액을 줄여서 사용합니다. "),s("a",{href:"#configuring-amount-per-trade"}," 자세한 정보는 아래 참조 "),l(" . "),s("br"),s("em",null,[l(" 기본값은 "),s("code",null," false "),l(" 입니다. ")]),s("br"),s("strong",null," 데이터 유형: "),l(" 부울 ")])],-1)),n[311]||(n[311]=s("tr",null,[s("td",null,[s("code",null," last_stake_amount_min_ratio ")]),s("td",null,[l(" 최소 스테이크 금액을 정의합니다. 이는 마지막 스테이크 금액이 줄어들 때만 적용됩니다(즉, "),s("code",null," amend_last_stake_amount "),l(" 가 "),s("code",null," true "),l(" 로 설정된 경우). "),s("a",{href:"#configuring-amount-per-trade"}," 자세한 정보는 아래 참조 "),l(" . "),s("br"),s("em",null,[l(" 기본값은 "),s("code",null," 0.5 "),l(" 입니다. ")]),s("br"),s("strong",null," 데이터 유형: "),l(" 비율로서의 부동 소수점 ")])],-1)),n[312]||(n[312]=s("tr",null,[s("td",null,[s("code",null," amount_reserve_percent ")]),s("td",null,[l(" 최소 쌍 스테이크 금액에서 일부 금액을 예약합니다. 봇은 최소 쌍 스테이크 금액을 계산할 때 "),s("code",null," amount_reserve_percent "),l(" + 손절매 값을 예약하여 거래 거부를 방지합니다. "),s("br"),s("em",null,[l(" 기본값은 "),s("code",null," 0.05 "),l(" (5%)입니다. ")]),s("br"),s("strong",null," 데이터 유형: "),l(" 비율로서의 양의 부동 소수점. ")])],-1)),n[313]||(n[313]=s("tr",null,[s("td",null,[s("code",null," timeframe ")]),s("td",null,[l(" 사용할 시간 프레임(예: "),s("code",null," 1m "),l(" , "),s("code",null," 5m "),l(" , "),s("code",null," 15m "),l(" , "),s("code",null," 30m "),l(" , "),s("code",null," 1h "),l(" ...). 일반적으로 설정에 누락되며, 전략에서 지정됩니다. "),s("a",{href:"#parameters-in-the-strategy"}," 전략 덮어쓰기 "),l(" . "),s("br"),s("strong",null," 데이터 유형: "),l(" 문자열 ")])],-1)),n[314]||(n[314]=s("tr",null,[s("td",null,[s("code",null," fiat_display_currency ")]),s("td",null,[l(" 수익을 표시하는 데 사용되는 법정 화폐. "),s("a",{href:"#what-values-can-be-used-for-fiat_display_currency"}," 자세한 정보는 아래 참조 "),l(" . "),s("br"),s("strong",null," 데이터 유형: "),l(" 문자열 ")])],-1)),n[315]||(n[315]=s("tr",null,[s("td",null,[s("code",null," dry_run ")]),s("td",null,[s("strong",null," 필수. "),l(" 봇이 드라이런 모드인지 프로덕션 모드인지 정의합니다. "),s("br"),s("em",null,[l(" 기본값은 "),s("code",null," true "),l(" 입니다. ")]),s("br"),s("strong",null," 데이터 유형: "),l(" 부울 ")])],-1)),n[316]||(n[316]=s("tr",null,[s("td",null,[s("code",null," dry_run_wallet ")]),s("td",null,[l(" 드라이런 모드에서 봇이 사용하는 시뮬레이션 지갑의 시작 금액을 정의합니다. "),s("a",{href:"#dry-run-wallet"}," 자세한 정보는 아래 참조 "),s("br"),s("em",null,[l(" 기본값은 "),s("code",null," 1000 "),l(" 입니다. ")]),s("br"),s("strong",null," 데이터 유형: "),l(" 부동 소수점 또는 사전 ")])],-1)),n[317]||(n[317]=s("tr",null,[s("td",null,[s("code",null," cancel_open_orders_on_exit ")]),s("td",null,[s("code",null," /stop "),l(" RPC 명령이 발행되거나, "),s("code",null," Ctrl+C "),l(" 가 눌리거나 봇이 예기치 않게 종료될 때 오픈 주문을 취소합니다. "),s("code",null," true "),l(" 로 설정된 경우, 이는 시장 붕괴 시 미체결 및 부분 체결 주문을 취소할 수 있습니다. 오픈 포지션에는 영향을 미치지 않습니다. "),s("br"),s("em",null,[l(" 기본값은 "),s("code",null," false "),l(" 입니다. ")]),s("br"),s("strong",null," 데이터 유형: "),l(" 부울 ")])],-1)),n[318]||(n[318]=s("tr",null,[s("td",null,[s("code",null," process_only_new_candles ")]),s("td",null,[l(" 새로운 캔들이 도착할 때만 지표 처리를 활성화합니다. "),s("code",null," false "),l(" 인 경우 각 루프는 지표를 채우며, 이는 동일한 캔들이 여러 번 처리되어 시스템 부하를 생성하지만, 전략이 틱 데이터에 의존하는 경우 유용할 수 있습니다. "),s("a",{href:"#parameters-in-the-strategy"}," 전략 덮어쓰기 "),l(" . "),s("br"),s("em",null,[l(" 기본값은 "),s("code",null," true "),l(" 입니다. ")]),s("br"),s("strong",null," 데이터 유형: "),l(" 부울 ")])],-1)),n[319]||(n[319]=s("tr",null,[s("td",null,[s("code",null," minimal_roi ")]),s("td",null,[s("strong",null," 필수. "),l(" 봇이 거래를 종료하는 데 사용할 임계값을 비율로 설정합니다. "),s("a",{href:"#understand-minimal_roi"}," 자세한 정보는 아래 참조 "),l(" . "),s("a",{href:"#parameters-in-the-strategy"}," 전략 덮어쓰기 "),l(" . "),s("br"),s("strong",null," 데이터 유형: "),l(" 사전 ")])],-1)),s("tr",null,[n[17]||(n[17]=s("td",null,[s("code",null," stoploss ")],-1)),s("td",null,[n[9]||(n[9]=s("strong",null," 필수. ",-1)),n[10]||(n[10]=l(" 봇이 사용하는 손절매의 비율 값입니다. 자세한 내용은 ")),a(t,{to:"stoploss"},{default:p(()=>n[8]||(n[8]=[l("손절매 문서")])),_:1}),n[11]||(n[11]=l(" 를 참조하세요. ")),n[12]||(n[12]=s("a",{href:"#parameters-in-the-strategy"}," 전략 덮어쓰기 ",-1)),n[13]||(n[13]=l(" . ")),n[14]||(n[14]=s("br",null,null,-1)),n[15]||(n[15]=s("strong",null," 데이터 유형: ",-1)),n[16]||(n[16]=l(" 비율로서의 부동 소수점 "))])]),s("tr",null,[n[28]||(n[28]=s("td",null,[s("code",null," trailing_stop ")],-1)),s("td",null,[n[19]||(n[19]=l(" 손절매를 활성화합니다(설정 파일 또는 전략 파일의 ")),n[20]||(n[20]=s("code",null," stoploss ",-1)),n[21]||(n[21]=l(" 기반). 자세한 내용은 ")),a(t,{to:"stoploss"},{default:p(()=>n[18]||(n[18]=[l("손절매 문서")])),_:1}),n[22]||(n[22]=l(" 를 참조하세요. ")),n[23]||(n[23]=s("a",{href:"#parameters-in-the-strategy"}," 전략 덮어쓰기 ",-1)),n[24]||(n[24]=l(" . ")),n[25]||(n[25]=s("br",null,null,-1)),n[26]||(n[26]=s("strong",null," 데이터 유형: ",-1)),n[27]||(n[27]=l(" 부울 "))])]),s("tr",null,[n[37]||(n[37]=s("td",null,[s("code",null," trailing_stop_positive ")],-1)),s("td",null,[n[30]||(n[30]=l(" 이익이 발생하면 손절매를 변경합니다. 자세한 내용은 ")),a(t,{to:"stoploss"},{default:p(()=>n[29]||(n[29]=[l("손절매 문서")])),_:1}),n[31]||(n[31]=l(" 를 참조하세요. ")),n[32]||(n[32]=s("a",{href:"#parameters-in-the-strategy"}," 전략 덮어쓰기 ",-1)),n[33]||(n[33]=l(" . ")),n[34]||(n[34]=s("br",null,null,-1)),n[35]||(n[35]=s("strong",null," 데이터 유형: ",-1)),n[36]||(n[36]=l(" 부동 소수점 "))])]),s("tr",null,[n[49]||(n[49]=s("td",null,[s("code",null," trailing_stop_positive_offset ")],-1)),s("td",null,[n[39]||(n[39]=s("code",null," trailing_stop_positive ",-1)),n[40]||(n[40]=l(" 를 적용할 때의 오프셋입니다. 양수 값이어야 합니다. 자세한 내용은 ")),a(t,{to:"stoploss"},{default:p(()=>n[38]||(n[38]=[l("손절매 문서")])),_:1}),n[41]||(n[41]=l(" 를 참조하세요. ")),n[42]||(n[42]=s("a",{href:"#parameters-in-the-strategy"}," 전략 덮어쓰기 ",-1)),n[43]||(n[43]=l(" . ")),n[44]||(n[44]=s("br",null,null,-1)),n[45]||(n[45]=s("em",null,[l(" 기본값은 "),s("code",null," 0.0 "),l(" (오프셋 없음)입니다. ")],-1)),n[46]||(n[46]=s("br",null,null,-1)),n[47]||(n[47]=s("strong",null," 데이터 유형: ",-1)),n[48]||(n[48]=l(" 부동 소수점 "))])]),s("tr",null,[n[60]||(n[60]=s("td",null,[s("code",null," trailing_only_offset_is_reached ")],-1)),s("td",null,[n[51]||(n[51]=l(" 오프셋이 도달했을 때만 손절매를 적용합니다. ")),a(t,{to:"stoploss"},{default:p(()=>n[50]||(n[50]=[l("손절매 문서")])),_:1}),n[52]||(n[52]=l(" . ")),n[53]||(n[53]=s("a",{href:"#parameters-in-the-strategy"}," 전략 덮어쓰기 ",-1)),n[54]||(n[54]=l(" . ")),n[55]||(n[55]=s("br",null,null,-1)),n[56]||(n[56]=s("em",null,[l(" 기본값은 "),s("code",null," false "),l(" 입니다. ")],-1)),n[57]||(n[57]=s("br",null,null,-1)),n[58]||(n[58]=s("strong",null," 데이터 유형: ",-1)),n[59]||(n[59]=l(" 부울 "))])]),n[320]||(n[320]=s("tr",null,[s("td",null,[s("code",null," fee ")]),s("td",null,[l(" 백테스팅/드라이런 중 사용되는 수수료입니다. 일반적으로 설정하지 않으며, freqtrade는 거래소 기본 수수료로 대체됩니다. 비율로 설정(예: "),s("code",null," 0.001 = 0.1% "),l(" ). 수수료는 각 거래 시 한 번씩, 즉 매수 시 한 번, 매도 시 한 번 적용됩니다. "),s("br"),s("strong",null," 데이터 유형: "),l(" 비율로서의 부동 소수점 ")])],-1)),s("tr",null,[n[68]||(n[68]=s("td",null,[s("code",null," futures_funding_rate ")],-1)),s("td",null,[n[62]||(n[62]=l(" 거래소에서 역사적 자금 조달 비율을 사용할 수 없는 경우 사용되는 사용자 지정 자금 조달 비율입니다. 이는 실제 역사적 비율을 덮어쓰지 않습니다. 특정 코인을 테스트하고 자금 조달 비율이 freqtrade의 수익 계산에 미치는 영향을 이해하는 경우에만 0으로 설정하는 것이 좋습니다. ")),a(t,{to:"leverage"},{default:p(()=>n[61]||(n[61]=[l(" 자세한 정보는 여기 참조 ")])),_:1}),n[63]||(n[63]=s("br",null,null,-1)),n[64]||(n[64]=s("em",null,[l(" 기본값은 "),s("code",null," 없음 "),l(" 입니다. ")],-1)),n[65]||(n[65]=s("br",null,null,-1)),n[66]||(n[66]=s("strong",null," 데이터 유형: ",-1)),n[67]||(n[67]=l(" 부동 소수점 "))])]),s("tr",null,[n[77]||(n[77]=s("td",null,[s("code",null," trading_mode ")],-1)),s("td",null,[n[70]||(n[70]=l(" 정기적으로 거래할지, 레버리지를 사용하여 거래할지, 또는 암호화폐 가격에서 파생된 계약을 거래할지 여부를 지정합니다. ")),a(t,{to:"leverage"},{default:p(()=>n[69]||(n[69]=[l(" 레버리지 문서 ")])),_:1}),n[71]||(n[71]=l(" . ")),n[72]||(n[72]=s("br",null,null,-1)),n[73]||(n[73]=s("em",null,[l(" 기본값은 "),s("code",null,' "spot" '),l(" 입니다. ")],-1)),n[74]||(n[74]=s("br",null,null,-1)),n[75]||(n[75]=s("strong",null," 데이터 유형: ",-1)),n[76]||(n[76]=l(" 문자열 "))])]),s("tr",null,[n[84]||(n[84]=s("td",null,[s("code",null," margin_mode ")],-1)),s("td",null,[n[79]||(n[79]=l(" 레버리지를 사용하여 거래할 때, 트레이더가 소유한 담보가 각 거래 쌍에 대해 공유될지 또는 격리될지를 결정합니다. ")),a(t,{to:"leverage"},{default:p(()=>n[78]||(n[78]=[l(" 레버리지 문서 ")])),_:1}),n[80]||(n[80]=l(" . ")),n[81]||(n[81]=s("br",null,null,-1)),n[82]||(n[82]=s("strong",null," 데이터 유형: ",-1)),n[83]||(n[83]=l(" 문자열 "))])]),s("tr",null,[n[93]||(n[93]=s("td",null,[s("code",null," liquidation_buffer ")],-1)),s("td",null,[n[86]||(n[86]=l(" 청산 가격과 손절매 사이에 안전망을 배치하여 포지션이 청산 가격에 도달하지 않도록 하는 비율입니다. ")),a(t,{to:"leverage"},{default:p(()=>n[85]||(n[85]=[l(" 레버리지 문서 ")])),_:1}),n[87]||(n[87]=l(" . ")),n[88]||(n[88]=s("br",null,null,-1)),n[89]||(n[89]=s("em",null,[l(" 기본값은 "),s("code",null," 0.05 "),l(" 입니다. ")],-1)),n[90]||(n[90]=s("br",null,null,-1)),n[91]||(n[91]=s("strong",null," 데이터 유형: ",-1)),n[92]||(n[92]=l(" 부동 소수점 "))])]),n[321]||(n[321]=s("tr",null,[s("td"),s("td",null,[s("strong",null," 미체결 시간 초과 ")])],-1)),n[322]||(n[322]=s("tr",null,[s("td",null,[s("code",null," unfilledtimeout.entry ")]),s("td",null,[s("strong",null," 필수. "),l(" 봇이 미체결 진입 주문이 완료되기를 기다리는 시간(분 또는 초)입니다. 그 후 주문이 취소됩니다. "),s("a",{href:"#parameters-in-the-strategy"}," 전략 덮어쓰기 "),l(" . "),s("br"),s("strong",null," 데이터 유형: "),l(" 정수 ")])],-1)),n[323]||(n[323]=s("tr",null,[s("td",null,[s("code",null," unfilledtimeout.exit ")]),s("td",null,[s("strong",null," 필수. "),l(" 봇이 미체결 종료 주문이 완료되기를 기다리는 시간(분 또는 초)입니다. 그 후 주문이 취소되고 신호가 있는 한 현재(새로운) 가격으로 반복됩니다. "),s("a",{href:"#parameters-in-the-strategy"}," 전략 덮어쓰기 "),l(" . "),s("br"),s("strong",null," 데이터 유형: "),l(" 정수 ")])],-1)),n[324]||(n[324]=s("tr",null,[s("td",null,[s("code",null," unfilledtimeout.unit ")]),s("td",null,[l(' unfilledtimeout 설정에서 사용할 단위입니다. 참고: unfilledtimeout.unit을 "초"로 설정한 경우, "internals.process_throttle_secs"는 시간 초과보다 작거나 같아야 합니다. '),s("a",{href:"#parameters-in-the-strategy"}," 전략 덮어쓰기 "),l(" . "),s("br"),s("em",null,[l(" 기본값은 "),s("code",null,' "minutes" '),l(" 입니다. ")]),s("br"),s("strong",null," 데이터 유형: "),l(" 문자열 ")])],-1)),n[325]||(n[325]=s("tr",null,[s("td",null,[s("code",null," unfilledtimeout.exit_timeout_count ")]),s("td",null,[l(" 종료 주문이 시간 초과될 수 있는 횟수입니다. 이 시간 초과 횟수에 도달하면 비상 종료가 트리거됩니다. 0으로 설정하여 무제한 주문 취소를 허용합니다. "),s("a",{href:"#parameters-in-the-strategy"}," 전략 덮어쓰기 "),l(" . "),s("br"),s("em",null,[l(" 기본값은 "),s("code",null," 0 "),l(" 입니다. ")]),s("br"),s("strong",null," 데이터 유형: "),l(" 정수 ")])],-1)),n[326]||(n[326]=s("tr",null,[s("td"),s("td",null,[s("strong",null," 가격 책정 ")])],-1)),n[327]||(n[327]=s("tr",null,[s("td",null,[s("code",null," entry_pricing.price_side ")]),s("td",null,[l(" 봇이 진입 가격을 얻기 위해 스프레드의 어느 쪽을 볼지 선택합니다. "),s("a",{href:"#entry-price"}," 자세한 정보는 아래 참조 "),l(" . "),s("br"),s("em",null,[l(" 기본값은 "),s("code",null,' "same" '),l(" 입니다. ")]),s("br"),s("strong",null," 데이터 유형: "),l(" 문자열(다음 중 하나: "),s("code",null," ask "),l(" , "),s("code",null," bid "),l(" , "),s("code",null," same "),l(" 또는 "),s("code",null," other "),l(" ). ")])],-1)),n[328]||(n[328]=s("tr",null,[s("td",null,[s("code",null," entry_pricing.price_last_balance ")]),s("td",null,[s("strong",null," 필수. "),l(" 입찰 가격을 보간합니다. 자세한 내용은 "),s("a",{href:"#entry-price-without-orderbook-enabled"}," 아래 참조 "),l(" . ")])],-1)),n[329]||(n[329]=s("tr",null,[s("td",null,[s("code",null," entry_pricing.use_order_book ")]),s("td",null,[s("a",{href:"#entry-price-with-orderbook-enabled"}," 주문서 진입 "),l(" 의 비율을 사용하여 진입을 활성화합니다. "),s("br"),s("em",null,[l(" 기본값은 "),s("code",null," true "),l(" 입니다. ")]),s("br"),s("strong",null," 데이터 유형: "),l(" 부울 ")])],-1)),n[330]||(n[330]=s("tr",null,[s("td",null,[s("code",null," entry_pricing.order_book_top ")]),s("td",null,[l(' 봇은 주문서 "price_side"의 상위 N 비율을 사용하여 거래에 진입합니다. 예를 들어, 값이 2인 경우 봇은 '),s("a",{href:"#entry-price-with-orderbook-enabled"}," 주문서 진입 "),l(" 에서 두 번째 진입을 선택할 수 있습니다. "),s("br"),s("em",null,[l(" 기본값은 "),s("code",null," 1 "),l(" 입니다. ")]),s("br"),s("strong",null," 데이터 유형: "),l(" 양의 정수 ")])],-1)),n[331]||(n[331]=s("tr",null,[s("td",null,[s("code",null," entry_pricing. check_depth_of_market.enabled ")]),s("td",null,[l(" 주문서에서 매수 주문과 매도 주문의 차이가 충족되면 진입하지 않습니다. "),s("a",{href:"#check-depth-of-market"}," 시장 깊이 확인 "),l(" . "),s("br"),s("em",null,[l(" 기본값은 "),s("code",null," false "),l(" 입니다. ")]),s("br"),s("strong",null," 데이터 유형: "),l(" 부울 ")])],-1)),n[332]||(n[332]=s("tr",null,[s("td",null,[s("code",null," entry_pricing. check_depth_of_market.bids_to_ask_delta ")]),s("td",null,[l(" 주문서에서 발견된 매수 주문과 매도 주문의 차이 비율입니다. 값이 1보다 작으면 매도 주문 크기가 더 크고, 값이 1보다 크면 매수 주문 크기가 더 큽니다. "),s("a",{href:"#check-depth-of-market"}," 시장 깊이 확인 "),s("br"),s("em",null,[l(" 기본값은 "),s("code",null," 0 "),l(" 입니다. ")]),s("br"),s("strong",null," 데이터 유형: "),l(" 비율로서의 부동 소수점 ")])],-1)),n[333]||(n[333]=s("tr",null,[s("td",null,[s("code",null," exit_pricing.price_side ")]),s("td",null,[l(" 봇이 거래 종료 가격을 얻기 위해 스프레드의 어느 쪽을 볼지 선택합니다. "),s("a",{href:"#exit-price-side"}," 자세한 정보는 아래 참조 "),l(" . "),s("br"),s("em",null,[l(" 기본값은 "),s("code",null,' "same" '),l(" 입니다. ")]),s("br"),s("strong",null," 데이터 유형: "),l(" 문자열(다음 중 하나: "),s("code",null," ask "),l(" , "),s("code",null," bid "),l(" , "),s("code",null," same "),l(" 또는 "),s("code",null," other "),l(" ). ")])],-1)),n[334]||(n[334]=s("tr",null,[s("td",null,[s("code",null," exit_pricing.price_last_balance ")]),s("td",null,[l(" 종료 가격을 보간합니다. 자세한 내용은 "),s("a",{href:"#exit-price-without-orderbook-enabled"}," 아래 참조 "),l(" . ")])],-1)),n[335]||(n[335]=s("tr",null,[s("td",null,[s("code",null," exit_pricing.use_order_book ")]),s("td",null,[s("a",{href:"#exit-price-with-orderbook-enabled"}," 주문서 종료 "),l(" 를 사용하여 열린 거래를 종료하는 것을 활성화합니다. "),s("br"),s("em",null,[l(" 기본값은 "),s("code",null," true "),l(" 입니다. ")]),s("br"),s("strong",null," 데이터 유형: "),l(" 부울 ")])],-1)),n[336]||(n[336]=s("tr",null,[s("td",null,[s("code",null," exit_pricing.order_book_top ")]),s("td",null,[l(' 봇은 주문서 "price_side"의 상위 N 비율을 사용하여 종료합니다. 예를 들어, 값이 2인 경우 봇은 '),s("a",{href:"#exit-price-with-orderbook-enabled"}," 주문서 종료 "),l(" 에서 두 번째 매도 비율을 선택할 수 있습니다. "),s("br"),s("em",null,[l(" 기본값은 "),s("code",null," 1 "),l(" 입니다. ")]),s("br"),s("strong",null," 데이터 유형: "),l(" 양의 정수 ")])],-1)),n[337]||(n[337]=s("tr",null,[s("td",null,[s("code",null," custom_price_max_distance_ratio ")]),s("td",null,[l(" 현재 가격과 사용자 지정 진입 또는 종료 가격 간의 최대 거리 비율을 구성합니다. "),s("br"),s("em",null,[l(" 기본값은 "),s("code",null," 0.02 "),l(" (2%)입니다. ")]),s("br"),s("strong",null," 데이터 유형: "),l(" 양의 부동 소수점 ")])],-1)),n[338]||(n[338]=s("tr",null,[s("td"),s("td",null,[s("strong",null," TODO ")])],-1)),n[339]||(n[339]=s("tr",null,[s("td",null,[s("code",null," use_exit_signal ")]),s("td",null,[s("code",null," minimal_roi "),l(" 외에도 전략에서 생성된 종료 신호를 사용합니다. "),s("br"),l(" 이를 "),s("code",null," false "),l(" 로 설정하면 "),s("code",null,' "exit_long" '),l(" 및 "),s("code",null,' "exit_short" '),l(" 열을 사용하는 것이 비활성화됩니다. 다른 종료 방법(손절매, ROI, 콜백)에는 영향을 미치지 않습니다. "),s("a",{href:"#parameters-in-the-strategy"}," 전략 덮어쓰기 "),l(" . "),s("br"),s("em",null,[l(" 기본값은 "),s("code",null," true "),l(" 입니다. ")]),s("br"),s("strong",null," 데이터 유형: "),l(" 부울 ")])],-1)),n[340]||(n[340]=s("tr",null,[s("td",null,[s("code",null," exit_profit_only ")]),s("td",null,[l(" 봇이 "),s("code",null," exit_profit_offset "),l(" 에 도달할 때까지 기다렸다가 종료 결정을 내립니다. "),s("a",{href:"#parameters-in-the-strategy"}," 전략 덮어쓰기 "),l(" . "),s("br"),s("em",null,[l(" 기본값은 "),s("code",null," false "),l(" 입니다. ")]),s("br"),s("strong",null," 데이터 유형: "),l(" 부울 ")])],-1)),n[341]||(n[341]=s("tr",null,[s("td",null,[s("code",null," exit_profit_offset ")]),s("td",null,[l(" 종료 신호는 이 값 이상에서만 활성화됩니다. "),s("code",null," exit_profit_only=True "),l(" 와 함께 사용됩니다. "),s("a",{href:"#parameters-in-the-strategy"}," 전략 덮어쓰기 "),l(" . "),s("br"),s("em",null,[l(" 기본값은 "),s("code",null," 0.0 "),l(" 입니다. ")]),s("br"),s("strong",null," 데이터 유형: "),l(" 비율로서의 부동 소수점 ")])],-1)),n[342]||(n[342]=s("tr",null,[s("td",null,[s("code",null," ignore_roi_if_entry_signal ")]),s("td",null,[l(" 진입 신호가 여전히 활성화된 경우 종료하지 않습니다. 이 설정은 "),s("code",null," minimal_roi "),l(" 및 "),s("code",null," use_exit_signal "),l(" 보다 우선합니다. "),s("a",{href:"#parameters-in-the-strategy"}," 전략 덮어쓰기 "),l(" . "),s("br"),s("em",null,[l(" 기본값은 "),s("code",null," false "),l(" 입니다. ")]),s("br"),s("strong",null," 데이터 유형: "),l(" 부울 ")])],-1)),n[343]||(n[343]=s("tr",null,[s("td",null,[s("code",null," ignore_buying_expired_candle_after ")]),s("td",null,[l(" 매수 신호가 더 이상 사용되지 않는 초 수를 지정합니다. "),s("br"),s("strong",null," 데이터 유형: "),l(" 정수 ")])],-1)),n[344]||(n[344]=s("tr",null,[s("td",null,[s("code",null," order_types ")]),s("td",null,[l(" 작업( "),s("code",null,' "entry" '),l(" , "),s("code",null,' "exit" '),l(" , "),s("code",null,' "stoploss" '),l(" , "),s("code",null,' "stoploss_on_exchange" '),l(" )에 따라 주문 유형을 구성합니다. "),s("a",{href:"#understand-order_types"}," 자세한 정보는 아래 참조 "),l(" . "),s("a",{href:"#parameters-in-the-strategy"}," 전략 덮어쓰기 "),l(" . "),s("br"),s("strong",null," 데이터 유형: "),l(" 사전 ")])],-1)),n[345]||(n[345]=s("tr",null,[s("td",null,[s("code",null," order_time_in_force ")]),s("td",null,[l(" 진입 및 종료 주문의 유효 기간을 구성합니다. "),s("a",{href:"#understand-order_time_in_force"}," 자세한 정보는 아래 참조 "),l(" . "),s("a",{href:"#parameters-in-the-strategy"}," 전략 덮어쓰기 "),l(" . "),s("br"),s("strong",null," 데이터 유형: "),l(" 사전 ")])],-1)),s("tr",null,[n[105]||(n[105]=s("td",null,[s("code",null," position_adjustment_enable ")],-1)),s("td",null,[n[95]||(n[95]=l(" 전략이 포지션 조정을 사용할 수 있도록 합니다(추가 매수 또는 매도). ")),a(t,{to:"strategy-callbacks"},{default:p(()=>n[94]||(n[94]=[l(" 자세한 정보는 여기 참조 ")])),_:1}),n[96]||(n[96]=l(" . ")),n[97]||(n[97]=s("br",null,null,-1)),n[98]||(n[98]=s("a",{href:"#parameters-in-the-strategy"}," 전략 덮어쓰기 ",-1)),n[99]||(n[99]=l(" . ")),n[100]||(n[100]=s("br",null,null,-1)),n[101]||(n[101]=s("em",null,[l(" 기본값은 "),s("code",null," false "),l(" 입니다. ")],-1)),n[102]||(n[102]=s("br",null,null,-1)),n[103]||(n[103]=s("strong",null," 데이터 유형: ",-1)),n[104]||(n[104]=l(" 부울 "))])]),s("tr",null,[n[119]||(n[119]=s("td",null,[s("code",null," max_entry_position_adjustment ")],-1)),s("td",null,[n[107]||(n[107]=l(" 첫 번째 진입 주문 외에 각 오픈 거래에 대한 최대 추가 주문 수입니다. ")),n[108]||(n[108]=s("code",null," -1 ",-1)),n[109]||(n[109]=l(" 로 설정하여 무제한 추가 주문을 허용합니다. ")),a(t,{to:"strategy-callbacks"},{default:p(()=>n[106]||(n[106]=[l(" 자세한 정보는 여기 참조 ")])),_:1}),n[110]||(n[110]=l(" . ")),n[111]||(n[111]=s("br",null,null,-1)),n[112]||(n[112]=s("a",{href:"#parameters-in-the-strategy"}," 전략 덮어쓰기 ",-1)),n[113]||(n[113]=l(" . ")),n[114]||(n[114]=s("br",null,null,-1)),n[115]||(n[115]=s("em",null,[l(" 기본값은 "),s("code",null," -1 "),l(" 입니다. ")],-1)),n[116]||(n[116]=s("br",null,null,-1)),n[117]||(n[117]=s("strong",null," 데이터 유형: ",-1)),n[118]||(n[118]=l(" 양의 정수 또는 -1 "))])]),n[346]||(n[346]=s("tr",null,[s("td"),s("td",null,[s("strong",null," 거래소 ")])],-1)),n[347]||(n[347]=s("tr",null,[s("td",null,[s("code",null," exchange.name ")]),s("td",null,[s("strong",null," 필수. "),l(" 사용할 거래소 클래스의 이름입니다. "),s("br"),s("strong",null," 데이터 유형: "),l(" 문자열 ")])],-1)),n[348]||(n[348]=s("tr",null,[s("td",null,[s("code",null," exchange.key ")]),s("td",null,[l(" 거래소에 사용할 API 키입니다. 프로덕션 모드일 때만 필요합니다. "),s("br"),s("strong",null," 비밀로 유지하고 공개하지 마세요. "),s("br"),s("strong",null," 데이터 유형: "),l(" 문자열 ")])],-1)),n[349]||(n[349]=s("tr",null,[s("td",null,[s("code",null," exchange.secret ")]),s("td",null,[l(" 거래소에 사용할 API 비밀입니다. 프로덕션 모드일 때만 필요합니다. "),s("br"),s("strong",null," 비밀로 유지하고 공개하지 마세요. "),s("br"),s("strong",null," 데이터 유형: "),l(" 문자열 ")])],-1)),n[350]||(n[350]=s("tr",null,[s("td",null,[s("code",null," exchange.password ")]),s("td",null,[l(" 거래소에 사용할 API 비밀번호입니다. 프로덕션 모드일 때만 필요하며, API 요청에 비밀번호를 사용하는 거래소에 필요합니다. "),s("br"),s("strong",null," 비밀로 유지하고 공개하지 마세요. "),s("br"),s("strong",null," 데이터 유형: "),l(" 문자열 ")])],-1)),n[351]||(n[351]=s("tr",null,[s("td",null,[s("code",null," exchange.uid ")]),s("td",null,[l(" 거래소에 사용할 API uid입니다. 프로덕션 모드일 때만 필요하며, API 요청에 uid를 사용하는 거래소에 필요합니다. "),s("br"),s("strong",null," 비밀로 유지하고 공개하지 마세요. "),s("br"),s("strong",null," 데이터 유형: "),l(" 문자열 ")])],-1)),s("tr",null,[n[128]||(n[128]=s("td",null,[s("code",null," exchange.pair_whitelist ")],-1)),s("td",null,[n[121]||(n[121]=l(" 봇이 거래에 사용할 쌍 목록 및 백테스팅 중 잠재적 거래를 확인할 쌍 목록입니다. 정규식 쌍을 지원합니다( ")),n[122]||(n[122]=s("code",null," .*/BTC ",-1)),n[123]||(n[123]=l(" ). VolumePairList에서는 사용되지 않습니다. ")),a(t,{to:"plugins"},{default:p(()=>n[120]||(n[120]=[l(" 자세한 정보는 여기 참조 ")])),_:1}),n[124]||(n[124]=l(" . ")),n[125]||(n[125]=s("br",null,null,-1)),n[126]||(n[126]=s("strong",null," 데이터 유형: ",-1)),n[127]||(n[127]=l(" 목록 "))])]),s("tr",null,[n[135]||(n[135]=s("td",null,[s("code",null," exchange.pair_blacklist ")],-1)),s("td",null,[n[130]||(n[130]=l(" 봇이 거래 및 백테스팅에서 절대 피해야 하는 쌍 목록입니다. ")),a(t,{to:"plugins"},{default:p(()=>n[129]||(n[129]=[l(" 자세한 정보는 여기 참조 ")])),_:1}),n[131]||(n[131]=l(" . ")),n[132]||(n[132]=s("br",null,null,-1)),n[133]||(n[133]=s("strong",null," 데이터 유형: ",-1)),n[134]||(n[134]=l(" 목록 "))])]),n[352]||(n[352]=s("tr",null,[s("td",null,[s("code",null," exchange.ccxt_config ")]),s("td",null,[l(" 동기 및 비동기 ccxt 인스턴스에 전달되는 추가 CCXT 매개변수입니다. 이는 추가 ccxt 구성을 위한 올바른 위치입니다. 매개변수는 거래소마다 다를 수 있으며 "),s("a",{href:"https://docs.ccxt.com/#/README?id=overriding-exchange-properties-upon-instantiation"}," ccxt 문서 "),l(" 에 문서화되어 있습니다. 여기에 거래소 비밀을 추가하지 마세요(대신 전용 필드를 사용하세요). 로그에 포함될 수 있습니다. "),s("br"),s("strong",null," 데이터 유형: "),l(" 사전 ")])],-1)),n[353]||(n[353]=s("tr",null,[s("td",null,[s("code",null," exchange.ccxt_sync_config ")]),s("td",null,[l(" 정기적인(동기) ccxt 인스턴스에 전달되는 추가 CCXT 매개변수입니다. 매개변수는 거래소마다 다를 수 있으며 "),s("a",{href:"https://docs.ccxt.com/#/README?id=overriding-exchange-properties-upon-instantiation"}," ccxt 문서 "),l(" 에 문서화되어 있습니다. "),s("br"),s("strong",null," 데이터 유형: "),l(" 사전 ")])],-1)),n[354]||(n[354]=s("tr",null,[s("td",null,[s("code",null," exchange.ccxt_async_config ")]),s("td",null,[l(" 비동기 ccxt 인스턴스에 전달되는 추가 CCXT 매개변수입니다. 매개변수는 거래소마다 다를 수 있으며 "),s("a",{href:"https://docs.ccxt.com/#/README?id=overriding-exchange-properties-upon-instantiation"}," ccxt 문서 "),l(" 에 문서화되어 있습니다. "),s("br"),s("strong",null," 데이터 유형: "),l(" 사전 ")])],-1)),n[355]||(n[355]=s("tr",null,[s("td",null,[s("code",null," exchange.enable_ws ")]),s("td",null,[l(" 거래소에 대한 웹소켓 사용을 활성화합니다. "),s("br"),s("a",{href:"#consuming-exchange-websockets"}," 자세한 정보는 여기 참조 "),l(" . "),s("br"),s("em",null,[l(" 기본값은 "),s("code",null," true "),l(" 입니다. ")]),s("br"),s("strong",null," 데이터 유형: "),l(" 부울 ")])],-1)),n[356]||(n[356]=s("tr",null,[s("td",null,[s("code",null," exchange.markets_refresh_interval ")]),s("td",null,[l(" 시장이 다시 로드되는 간격(분)입니다. "),s("br"),s("em",null,[l(" 기본값은 "),s("code",null," 60 "),l(" 분입니다. ")]),s("br"),s("strong",null," 데이터 유형: "),l(" 양의 정수 ")])],-1)),n[357]||(n[357]=s("tr",null,[s("td",null,[s("code",null," exchange.skip_open_order_update ")]),s("td",null,[l(" 거래소가 문제를 일으킬 경우 시작 시 오픈 주문 업데이트를 건너뜁니다. 라이브 조건에서만 관련이 있습니다. "),s("br"),s("em",null,[l(" 기본값은 "),s("code",null," false ")]),s("br"),s("strong",null," 데이터 유형: "),l(" 부울 ")])],-1)),n[358]||(n[358]=s("tr",null,[s("td",null,[s("code",null," exchange.unknown_fee_rate ")]),s("td",null,[l(' 거래 수수료를 계산할 때 사용할 대체 값입니다. 이는 거래할 수 없는 통화로 수수료가 있는 거래소에 유용할 수 있습니다. 여기 제공된 값은 "수수료 비용"과 곱해집니다. '),s("br"),s("em",null,[l(" 기본값은 "),s("code",null," 없음 "),l(" 입니다. "),s("br")]),s("em",null," 데이터 유형: "),l(" * 부동 소수점 ")])],-1)),n[359]||(n[359]=s("tr",null,[s("td",null,[s("code",null," exchange.log_responses ")]),s("td",null,[l(" 관련 거래소 응답을 기록합니다. 디버그 모드에서만 사용 - 주의해서 사용하세요. "),s("br"),s("em",null,[l(" 기본값은 "),s("code",null," false ")]),s("br"),s("strong",null," 데이터 유형: "),l(" 부울 ")])],-1)),n[360]||(n[360]=s("tr",null,[s("td",null,[s("code",null," exchange.only_from_ccxt ")]),s("td",null,[l(" data.binance.vision에서 데이터 다운로드를 방지합니다. 이를 false로 두면 다운로드 속도가 크게 빨라질 수 있지만, 사이트가 사용 불가능한 경우 문제가 발생할 수 있습니다. "),s("br"),s("em",null,[l(" 기본값은 "),s("code",null," false ")]),s("br"),s("strong",null," 데이터 유형: "),l(" 부울 ")])],-1)),n[361]||(n[361]=s("tr",null,[s("td",null,[s("code",null," experimental.block_bad_exchanges ")]),s("td",null,[l(" freqtrade와 작동하지 않는 것으로 알려진 거래소를 차단합니다. 해당 거래소가 작동하는지 테스트하려는 경우가 아니면 기본값으로 두세요. "),s("br"),s("em",null,[l(" 기본값은 "),s("code",null," true "),l(" 입니다. ")]),s("br"),s("strong",null," 데이터 유형: "),l(" 부울 ")])],-1)),n[362]||(n[362]=s("tr",null,[s("td"),s("td",null,[s("strong",null," 플러그인 ")])],-1)),s("tr",null,[n[139]||(n[139]=s("td",null,[s("code",null," edge.* ")],-1)),s("td",null,[n[137]||(n[137]=l(" 모든 가능한 설정 옵션에 대한 자세한 설명은 ")),a(t,{to:"edge"},{default:p(()=>n[136]||(n[136]=[l(" edge 설정 문서 ")])),_:1}),n[138]||(n[138]=l(" 를 참조하세요. "))])]),s("tr",null,[n[148]||(n[148]=s("td",null,[s("code",null," pairlists ")],-1)),s("td",null,[n[141]||(n[141]=l(" 사용할 하나 이상의 쌍 목록을 정의합니다. ")),a(t,{to:"plugins"},{default:p(()=>n[140]||(n[140]=[l(" 자세한 정보는 여기 참조 ")])),_:1}),n[142]||(n[142]=l(" . ")),n[143]||(n[143]=s("br",null,null,-1)),n[144]||(n[144]=s("em",null,[l(" 기본값은 "),s("code",null," StaticPairList "),l(" 입니다. ")],-1)),n[145]||(n[145]=s("br",null,null,-1)),n[146]||(n[146]=s("strong",null," 데이터 유형: ",-1)),n[147]||(n[147]=l(" 사전 목록 "))])]),n[363]||(n[363]=s("tr",null,[s("td"),s("td",null,[s("strong",null," 텔레그램 ")])],-1)),n[364]||(n[364]=s("tr",null,[s("td",null,[s("code",null," telegram.enabled ")]),s("td",null,[l(" 텔레그램 사용을 활성화합니다. "),s("br"),s("strong",null," 데이터 유형: "),l(" 부울 ")])],-1)),n[365]||(n[365]=s("tr",null,[s("td",null,[s("code",null," telegram.token ")]),s("td",null,[l(" 텔레그램 봇 토큰입니다. "),s("code",null," telegram.enabled "),l(" 가 "),s("code",null," true "),l(" 인 경우에만 필요합니다. "),s("br"),s("strong",null," 비밀로 유지하고 공개하지 마세요. "),s("br"),s("strong",null," 데이터 유형: "),l(" 문자열 ")])],-1)),n[366]||(n[366]=s("tr",null,[s("td",null,[s("code",null," telegram.chat_id ")]),s("td",null,[l(" 개인 텔레그램 계정 ID입니다. "),s("code",null," telegram.enabled "),l(" 가 "),s("code",null," true "),l(" 인 경우에만 필요합니다. "),s("br"),s("strong",null," 비밀로 유지하고 공개하지 마세요. "),s("br"),s("strong",null," 데이터 유형: "),l(" 문자열 ")])],-1)),n[367]||(n[367]=s("tr",null,[s("td",null,[s("code",null," telegram.balance_dust_level ")]),s("td",null,[l(" 먼지 수준(스테이크 통화 단위) - 잔액이 이 값보다 낮은 통화는 "),s("code",null," /balance "),l(" 에 표시되지 않습니다. "),s("br"),s("strong",null," 데이터 유형: "),l(" 부동 소수점 ")])],-1)),n[368]||(n[368]=s("tr",null,[s("td",null,[s("code",null," telegram.reload ")]),s("td",null,[l(' 텔레그램 메시지에 "reload" 버튼을 허용합니다. '),s("br"),s("em",null,[l(" 기본값은 "),s("code",null," true "),l(" 입니다. "),s("br")]),s("em",null," 데이터 유형: "),l(" * 부울 ")])],-1)),s("tr",null,[n[155]||(n[155]=s("td",null,[s("code",null," telegram.notification_settings.* ")],-1)),s("td",null,[n[150]||(n[150]=l(" 상세한 알림 설정. 자세한 내용은 ")),a(t,{to:"telegram-usage"},{default:p(()=>n[149]||(n[149]=[l(" 텔레그램 문서 ")])),_:1}),n[151]||(n[151]=l(" 를 참조하세요. ")),n[152]||(n[152]=s("br",null,null,-1)),n[153]||(n[153]=s("strong",null," 데이터 유형: ",-1)),n[154]||(n[154]=l(" 사전 "))])]),n[369]||(n[369]=s("tr",null,[s("td",null,[s("code",null," telegram.allow_custom_messages ")]),s("td",null,[l(" dataprovider.send_msg() 함수를 통해 전략에서 텔레그램 메시지 전송을 활성화합니다. "),s("br"),s("strong",null," 데이터 유형: "),l(" 부울 ")])],-1)),n[370]||(n[370]=s("tr",null,[s("td"),s("td",null,[s("strong",null," Webhook ")])],-1)),n[371]||(n[371]=s("tr",null,[s("td",null,[s("code",null," webhook.enabled ")]),s("td",null,[l(" Webhook 알림 사용을 활성화합니다. "),s("br"),s("strong",null," 데이터 유형: "),l(" 부울 ")])],-1)),s("tr",null,[n[166]||(n[166]=s("td",null,[s("code",null," webhook.url ")],-1)),s("td",null,[n[157]||(n[157]=l(" Webhook의 URL입니다. ")),n[158]||(n[158]=s("code",null," webhook.enabled ",-1)),n[159]||(n[159]=l(" 가 ")),n[160]||(n[160]=s("code",null," true ",-1)),n[161]||(n[161]=l(" 인 경우에만 필요합니다. 자세한 내용은 ")),a(t,{to:"webhook-config"},{default:p(()=>n[156]||(n[156]=[l("webhook 문서")])),_:1}),n[162]||(n[162]=l(" 를 참조하세요. ")),n[163]||(n[163]=s("br",null,null,-1)),n[164]||(n[164]=s("strong",null," 데이터 유형: ",-1)),n[165]||(n[165]=l(" 문자열 "))])]),s("tr",null,[n[177]||(n[177]=s("td",null,[s("code",null," webhook.entry ")],-1)),s("td",null,[n[168]||(n[168]=l(" 진입 시 전송할 페이로드입니다. ")),n[169]||(n[169]=s("code",null," webhook.enabled ",-1)),n[170]||(n[170]=l(" 가 ")),n[171]||(n[171]=s("code",null," true ",-1)),n[172]||(n[172]=l(" 인 경우에만 필요합니다. 자세한 내용은 ")),a(t,{to:"webhook-config"},{default:p(()=>n[167]||(n[167]=[l("webhook 문서")])),_:1}),n[173]||(n[173]=l(" 를 참조하세요. ")),n[174]||(n[174]=s("br",null,null,-1)),n[175]||(n[175]=s("strong",null," 데이터 유형: ",-1)),n[176]||(n[176]=l(" 문자열 "))])]),s("tr",null,[n[188]||(n[188]=s("td",null,[s("code",null," webhook.entry_cancel ")],-1)),s("td",null,[n[179]||(n[179]=l(" 진입 주문 취소 시 전송할 페이로드입니다. ")),n[180]||(n[180]=s("code",null," webhook.enabled ",-1)),n[181]||(n[181]=l(" 가 ")),n[182]||(n[182]=s("code",null," true ",-1)),n[183]||(n[183]=l(" 인 경우에만 필요합니다. 자세한 내용은 ")),a(t,{to:"webhook-config"},{default:p(()=>n[178]||(n[178]=[l("webhook 문서")])),_:1}),n[184]||(n[184]=l(" 를 참조하세요. ")),n[185]||(n[185]=s("br",null,null,-1)),n[186]||(n[186]=s("strong",null," 데이터 유형: ",-1)),n[187]||(n[187]=l(" 문자열 "))])]),s("tr",null,[n[199]||(n[199]=s("td",null,[s("code",null," webhook.entry_fill ")],-1)),s("td",null,[n[190]||(n[190]=l(" 진입 주문이 체결될 때 전송할 페이로드입니다. ")),n[191]||(n[191]=s("code",null," webhook.enabled ",-1)),n[192]||(n[192]=l(" 가 ")),n[193]||(n[193]=s("code",null," true ",-1)),n[194]||(n[194]=l(" 인 경우에만 필요합니다. 자세한 내용은 ")),a(t,{to:"webhook-config"},{default:p(()=>n[189]||(n[189]=[l("webhook 문서")])),_:1}),n[195]||(n[195]=l(" 를 참조하세요. ")),n[196]||(n[196]=s("br",null,null,-1)),n[197]||(n[197]=s("strong",null," 데이터 유형: ",-1)),n[198]||(n[198]=l(" 문자열 "))])]),s("tr",null,[n[210]||(n[210]=s("td",null,[s("code",null," webhook.exit ")],-1)),s("td",null,[n[201]||(n[201]=l(" 종료 시 전송할 페이로드입니다. ")),n[202]||(n[202]=s("code",null," webhook.enabled ",-1)),n[203]||(n[203]=l(" 가 ")),n[204]||(n[204]=s("code",null," true ",-1)),n[205]||(n[205]=l(" 인 경우에만 필요합니다. 자세한 내용은 ")),a(t,{to:"webhook-config"},{default:p(()=>n[200]||(n[200]=[l("webhook 문서")])),_:1}),n[206]||(n[206]=l(" 를 참조하세요. ")),n[207]||(n[207]=s("br",null,null,-1)),n[208]||(n[208]=s("strong",null," 데이터 유형: ",-1)),n[209]||(n[209]=l(" 문자열 "))])]),s("tr",null,[n[221]||(n[221]=s("td",null,[s("code",null," webhook.exit_cancel ")],-1)),s("td",null,[n[212]||(n[212]=l(" 종료 주문 취소 시 전송할 페이로드입니다. ")),n[213]||(n[213]=s("code",null," webhook.enabled ",-1)),n[214]||(n[214]=l(" 가 ")),n[215]||(n[215]=s("code",null," true ",-1)),n[216]||(n[216]=l(" 인 경우에만 필요합니다. 자세한 내용은 ")),a(t,{to:"webhook-config"},{default:p(()=>n[211]||(n[211]=[l("webhook 문서")])),_:1}),n[217]||(n[217]=l(" 를 참조하세요. ")),n[218]||(n[218]=s("br",null,null,-1)),n[219]||(n[219]=s("strong",null," 데이터 유형: ",-1)),n[220]||(n[220]=l(" 문자열 "))])]),s("tr",null,[n[232]||(n[232]=s("td",null,[s("code",null," webhook.exit_fill ")],-1)),s("td",null,[n[223]||(n[223]=l(" 종료 주문이 체결될 때 전송할 페이로드입니다. ")),n[224]||(n[224]=s("code",null," webhook.enabled ",-1)),n[225]||(n[225]=l(" 가 ")),n[226]||(n[226]=s("code",null," true ",-1)),n[227]||(n[227]=l(" 인 경우에만 필요합니다. 자세한 내용은 ")),a(t,{to:"webhook-config"},{default:p(()=>n[222]||(n[222]=[l("webhook 문서")])),_:1}),n[228]||(n[228]=l(" 를 참조하세요. ")),n[229]||(n[229]=s("br",null,null,-1)),n[230]||(n[230]=s("strong",null," 데이터 유형: ",-1)),n[231]||(n[231]=l(" 문자열 "))])]),s("tr",null,[n[243]||(n[243]=s("td",null,[s("code",null," webhook.status ")],-1)),s("td",null,[n[234]||(n[234]=l(" 상태 호출 시 전송할 페이로드입니다. ")),n[235]||(n[235]=s("code",null," webhook.enabled ",-1)),n[236]||(n[236]=l(" 가 ")),n[237]||(n[237]=s("code",null," true ",-1)),n[238]||(n[238]=l(" 인 경우에만 필요합니다. 자세한 내용은 ")),a(t,{to:"webhook-config"},{default:p(()=>n[233]||(n[233]=[l("webhook 문서")])),_:1}),n[239]||(n[239]=l(" 를 참조하세요. ")),n[240]||(n[240]=s("br",null,null,-1)),n[241]||(n[241]=s("strong",null," 데이터 유형: ",-1)),n[242]||(n[242]=l(" 문자열 "))])]),n[372]||(n[372]=s("tr",null,[s("td",null,[s("code",null," webhook.allow_custom_messages ")]),s("td",null,[l(" dataprovider.send_msg() 함수를 통해 전략에서 Webhook 메시지 전송을 활성화합니다. "),s("br"),s("strong",null," 데이터 유형: "),l(" 부울 ")])],-1)),n[373]||(n[373]=s("tr",null,[s("td"),s("td",null,[s("strong",null," Rest API / FreqUI / Producer-Consumer ")])],-1)),s("tr",null,[n[250]||(n[250]=s("td",null,[s("code",null," api_server.enabled ")],-1)),s("td",null,[n[245]||(n[245]=l(" API 서버 사용을 활성화합니다. 자세한 내용은 ")),a(t,{to:"rest-api"},{default:p(()=>n[244]||(n[244]=[l("API 서버 문서")])),_:1}),n[246]||(n[246]=l(" 를 참조하세요. ")),n[247]||(n[247]=s("br",null,null,-1)),n[248]||(n[248]=s("strong",null," 데이터 유형: ",-1)),n[249]||(n[249]=l(" 부울 "))])]),s("tr",null,[n[257]||(n[257]=s("td",null,[s("code",null," api_server.listen_ip_address ")],-1)),s("td",null,[n[252]||(n[252]=l(" 바인드 IP 주소입니다. 자세한 내용은 ")),a(t,{to:"rest-api"},{default:p(()=>n[251]||(n[251]=[l("API 서버 문서")])),_:1}),n[253]||(n[253]=l(" 를 참조하세요. ")),n[254]||(n[254]=s("br",null,null,-1)),n[255]||(n[255]=s("strong",null," 데이터 유형: ",-1)),n[256]||(n[256]=l(" IPv4 "))])]),s("tr",null,[n[264]||(n[264]=s("td",null,[s("code",null," api_server.listen_port ")],-1)),s("td",null,[n[259]||(n[259]=l(" 바인드 포트입니다. 자세한 내용은 ")),a(t,{to:"rest-api"},{default:p(()=>n[258]||(n[258]=[l("API 서버 문서")])),_:1}),n[260]||(n[260]=l(" 를 참조하세요. ")),n[261]||(n[261]=s("br",null,null,-1)),n[262]||(n[262]=s("strong",null," 데이터 유형: ",-1)),n[263]||(n[263]=l(" 1024에서 65535 사이의 정수 "))])]),n[374]||(n[374]=s("tr",null,[s("td",null,[s("code",null," api_server.verbosity ")]),s("td",null,[l(" 로깅 상세 수준입니다. "),s("code",null," info "),l(' 는 모든 RPC 호출을 출력하며, "error"는 오류만 표시합니다. '),s("br"),s("strong",null," 데이터 유형: "),l(" 열거형, 다음 중 하나: "),s("code",null," info "),l(" 또는 "),s("code",null," error "),l(" . 기본값은 "),s("code",null," info "),l(" 입니다. ")])],-1)),s("tr",null,[n[273]||(n[273]=s("td",null,[s("code",null," api_server.username ")],-1)),s("td",null,[n[266]||(n[266]=l(" API 서버의 사용자 이름입니다. 자세한 내용은 ")),a(t,{to:"rest-api"},{default:p(()=>n[265]||(n[265]=[l("API 서버 문서")])),_:1}),n[267]||(n[267]=l(" 를 참조하세요. ")),n[268]||(n[268]=s("br",null,null,-1)),n[269]||(n[269]=s("strong",null," 비밀로 유지하고 공개하지 마세요. ",-1)),n[270]||(n[270]=s("br",null,null,-1)),n[271]||(n[271]=s("strong",null," 데이터 유형: ",-1)),n[272]||(n[272]=l(" 문자열 "))])]),s("tr",null,[n[282]||(n[282]=s("td",null,[s("code",null," api_server.password ")],-1)),s("td",null,[n[275]||(n[275]=l(" API 서버의 비밀번호입니다. 자세한 내용은 ")),a(t,{to:"rest-api"},{default:p(()=>n[274]||(n[274]=[l("API 서버 문서")])),_:1}),n[276]||(n[276]=l(" 를 참조하세요. ")),n[277]||(n[277]=s("br",null,null,-1)),n[278]||(n[278]=s("strong",null," 비밀로 유지하고 공개하지 마세요. ",-1)),n[279]||(n[279]=s("br",null,null,-1)),n[280]||(n[280]=s("strong",null," 데이터 유형: ",-1)),n[281]||(n[281]=l(" 문자열 "))])]),s("tr",null,[n[291]||(n[291]=s("td",null,[s("code",null," api_server.ws_token ")],-1)),s("td",null,[n[284]||(n[284]=l(" 메시지 웹소켓의 API 토큰입니다. 자세한 내용은 ")),a(t,{to:"rest-api"},{default:p(()=>n[283]||(n[283]=[l("API 서버 문서")])),_:1}),n[285]||(n[285]=l(" 를 참조하세요. ")),n[286]||(n[286]=s("br",null,null,-1)),n[287]||(n[287]=s("strong",null," 비밀로 유지하고 공개하지 마세요. ",-1)),n[288]||(n[288]=s("br",null,null,-1)),n[289]||(n[289]=s("strong",null," 데이터 유형: ",-1)),n[290]||(n[290]=l(" 문자열 "))])]),n[375]||(n[375]=s("tr",null,[s("td",null,[s("code",null," bot_name ")]),s("td",null,[l(" 봇의 이름입니다. API를 통해 클라이언트에 전달되며, 봇을 구분하거나 이름을 지정하는 데 사용할 수 있습니다. "),s("br"),s("em",null,[l(" 기본값은 "),s("code",null," freqtrade ")]),s("br"),s("strong",null," 데이터 유형: "),l(" 문자열 ")])],-1)),s("tr",null,[n[297]||(n[297]=s("td",null,[s("code",null," external_message_consumer ")],-1)),s("td",null,[a(t,{to:"producer-consumer"},{default:p(()=>n[292]||(n[292]=[l(" Producer/Consumer 모드 ")])),_:1}),n[293]||(n[293]=l(" 를 활성화합니다. 자세한 내용은 여기 참조. ")),n[294]||(n[294]=s("br",null,null,-1)),n[295]||(n[295]=s("strong",null," 데이터 유형: ",-1)),n[296]||(n[296]=l(" 사전 "))])]),n[376]||(n[376]=s("tr",null,[s("td"),s("td",null,[s("strong",null," 기타 ")])],-1)),n[377]||(n[377]=s("tr",null,[s("td",null,[s("code",null," initial_state ")]),s("td",null,[l(" 초기 애플리케이션 상태를 정의합니다. 중지로 설정된 경우, 봇은 "),s("code",null," /start "),l(" RPC 명령을 통해 명시적으로 시작해야 합니다. "),s("br"),s("em",null,[l(" 기본값은 "),s("code",null," stopped "),l(" 입니다. ")]),s("br"),s("strong",null," 데이터 유형: "),l(" 열거형, 다음 중 하나: "),s("code",null," stopped "),l(" 또는 "),s("code",null," running ")])],-1)),n[378]||(n[378]=s("tr",null,[s("td",null,[s("code",null," force_entry_enable ")]),s("td",null,[l(" 거래 진입을 강제하는 RPC 명령을 활성화합니다. 자세한 내용은 아래 참조. "),s("br"),s("strong",null," 데이터 유형: "),l(" 부울 ")])],-1)),n[379]||(n[379]=s("tr",null,[s("td",null,[s("code",null," disable_dataframe_checks ")]),s("td",null,[l(" 전략 메서드에서 반환된 OHLCV 데이터 프레임의 올바름을 확인하는 것을 비활성화합니다. 데이터 프레임을 의도적으로 변경하고 있는 경우에만 사용하세요. "),s("a",{href:"#parameters-in-the-strategy"}," 전략 덮어쓰기 "),l(" . "),s("br"),s("em",null,[l(" 기본값은 "),s("code",null," False ")]),l(" . "),s("br"),s("strong",null," 데이터 유형: "),l(" 부울 ")])],-1)),n[380]||(n[380]=s("tr",null,[s("td",null,[s("code",null," internals.process_throttle_secs ")]),s("td",null,[l(" 프로세스 스로틀 또는 하나의 봇 반복 루프에 대한 최소 루프 지속 시간을 설정합니다. 값은 초 단위입니다. "),s("br"),s("em",null,[l(" 기본값은 "),s("code",null," 5 "),l(" 초입니다. ")]),s("br"),s("strong",null," 데이터 유형: "),l(" 양의 정수 ")])],-1)),n[381]||(n[381]=s("tr",null,[s("td",null,[s("code",null," internals.heartbeat_interval ")]),s("td",null,[l(" N 초마다 하트비트 메시지를 출력합니다. 하트비트 메시지를 비활성화하려면 0으로 설정하세요. "),s("br"),s("em",null,[l(" 기본값은 "),s("code",null," 60 "),l(" 초입니다. ")]),s("br"),s("strong",null," 데이터 유형: "),l(" 양의 정수 또는 0 ")])],-1)),s("tr",null,[n[304]||(n[304]=s("td",null,[s("code",null," internals.sd_notify ")],-1)),s("td",null,[n[299]||(n[299]=l(" sd_notify 프로토콜을 사용하여 봇 상태 변경 및 유지 관리 핑을 시스템 관리자에게 알립니다. 자세한 내용은 ")),a(t,{to:"advanced-setup"},{default:p(()=>n[298]||(n[298]=[l(" 여기 ")])),_:1}),n[300]||(n[300]=l(" 를 참조하세요. ")),n[301]||(n[301]=s("br",null,null,-1)),n[302]||(n[302]=s("strong",null," 데이터 유형: ",-1)),n[303]||(n[303]=l(" 부울 "))])]),n[382]||(n[382]=s("tr",null,[s("td",null,[s("code",null," strategy ")]),s("td",null,[s("strong",null," 필수 "),l(" 사용할 전략 클래스를 정의합니다. "),s("code",null," --strategy NAME "),l(" 을 통해 설정하는 것이 좋습니다. "),s("br"),s("strong",null," 데이터 유형: "),l(" 클래스 이름 ")])],-1)),n[383]||(n[383]=s("tr",null,[s("td",null,[s("code",null," strategy_path ")]),s("td",null,[l(" 추가 전략 검색 경로를 추가합니다(디렉토리여야 함). "),s("br"),s("strong",null," 데이터 유형: "),l(" 문자열 ")])],-1)),n[384]||(n[384]=s("tr",null,[s("td",null,[s("code",null," recursive_strategy_search ")]),s("td",null,[s("code",null," user_data/strategies "),l(" 내 하위 디렉토리를 재귀적으로 검색하려면 "),s("code",null," true "),l(" 로 설정합니다. "),s("br"),s("strong",null," 데이터 유형: "),l(" 부울 ")])],-1)),n[385]||(n[385]=s("tr",null,[s("td",null,[s("code",null," user_data_dir ")]),s("td",null,[l(" 사용자 데이터를 포함하는 디렉토리입니다. "),s("br"),s("em",null,[l(" 기본값은 "),s("code",null," ./user_data/ ")]),l(" . "),s("br"),s("strong",null," 데이터 유형: "),l(" 문자열 ")])],-1)),n[386]||(n[386]=s("tr",null,[s("td",null,[s("code",null," db_url ")]),s("td",null,[l(" 사용할 데이터베이스 URL을 선언합니다. 참고: 이는 "),s("code",null," dry_run "),l(" 이 "),s("code",null," true "),l(" 인 경우 "),s("code",null," sqlite:///tradesv3.dryrun.sqlite "),l(" 로 기본 설정되며, 프로덕션 인스턴스의 경우 "),s("code",null," sqlite:///tradesv3.sqlite "),l(" 로 기본 설정됩니다. "),s("br"),s("strong",null," 데이터 유형: "),l(" 문자열, SQLAlchemy 연결 문자열 ")])],-1)),n[387]||(n[387]=s("tr",null,[s("td",null,[s("code",null," logfile ")]),s("td",null,[l(" 로그 파일 이름을 지정합니다. 파일당 1MB 제한으로 10개의 파일에 대한 롤링 전략을 사용합니다. "),s("br"),s("strong",null," 데이터 유형: "),l(" 문자열 ")])],-1)),n[388]||(n[388]=s("tr",null,[s("td",null,[s("code",null," add_config_files ")]),s("td",null,[l(" 추가 설정 파일입니다. 이러한 파일은 로드되어 현재 설정 파일과 병합됩니다. 파일은 초기 파일을 기준으로 해석됩니다. "),s("br"),s("em",null,[l(" 기본값은 "),s("code",null," [] ")]),l(" . "),s("br"),s("strong",null," 데이터 유형: "),l(" 문자열 목록 ")])],-1)),n[389]||(n[389]=s("tr",null,[s("td",null,[s("code",null," dataformat_ohlcv ")]),s("td",null,[l(" 역사적 캔들(OHLCV) 데이터를 저장하는 데 사용할 데이터 형식입니다. "),s("br"),s("em",null,[l(" 기본값은 "),s("code",null," feather ")]),l(" . "),s("br"),s("strong",null," 데이터 유형: "),l(" 문자열 ")])],-1)),n[390]||(n[390]=s("tr",null,[s("td",null,[s("code",null," dataformat_trades ")]),s("td",null,[l(" 역사적 거래 데이터를 저장하는 데 사용할 데이터 형식입니다. "),s("br"),s("em",null,[l(" 기본값은 "),s("code",null," feather ")]),l(" . "),s("br"),s("strong",null," 데이터 유형: "),l(" 문자열 ")])],-1)),n[391]||(n[391]=s("tr",null,[s("td",null,[s("code",null," reduce_df_footprint ")]),s("td",null,[l(" 모든 숫자 열을 float32/int32로 재캐스트하여 RAM/디스크 사용량을 줄이고 FreqAI에서 훈련/추론 시간을 단축하는 것을 목표로 합니다. (현재는 FreqAI 사용 사례에만 영향을 미침) "),s("br"),s("strong",null," 데이터 유형: "),l(" 부울. "),s("br"),l(" 기본값: "),s("code",null," False "),l(" . ")])],-1))])]),n[428]||(n[428]=o(`<h3 id="parameters-in-the-strategy"> 전략의 매개변수 <a class="headerlink" href="#parameters-in-the-strategy" title="영구 링크"></a></h3><p>다음 매개변수는 설정 파일 또는 전략에서 설정할 수 있습니다. 설정 파일에 설정된 값은 전략에 설정된 값을 항상 덮어씁니다.</p><ul><li><code> minimal_roi </code></li><li><code> timeframe </code></li><li><code> stoploss </code></li><li><code> max_open_trades </code></li><li><code> trailing_stop </code></li><li><code> trailing_stop_positive </code></li><li><code> trailing_stop_positive_offset </code></li><li><code> trailing_only_offset_is_reached </code></li><li><code> use_custom_stoploss </code></li><li><code> process_only_new_candles </code></li><li><code> order_types </code></li><li><code> order_time_in_force </code></li><li><code> unfilledtimeout </code></li><li><code> disable_dataframe_checks </code></li><li><code> use_exit_signal </code></li><li><code> exit_profit_only </code></li><li><code> exit_profit_offset </code></li><li><code> ignore_roi_if_entry_signal </code></li><li><code> ignore_buying_expired_candle_after </code></li><li><code> position_adjustment_enable </code></li><li><code> max_entry_position_adjustment </code></li></ul><h3 id="configuring-amount-per-trade"> 거래당 금액 구성 <a class="headerlink" href="#configuring-amount-per-trade" title="영구 링크"></a></h3><p> 봇이 거래에 진입할 때 사용할 스테이크 통화의 양을 구성하는 여러 가지 방법이 있습니다. 모든 방법은 아래 설명된 대로 <a href="#tradable-balance"> 사용 가능한 잔액 구성 </a> 을 준수합니다. </p><h4 id="minimum-trade-stake"> 최소 거래 스테이크 <a class="headerlink" href="#minimum-trade-stake" title="영구 링크"></a></h4><p>최소 스테이크 금액은 거래소와 쌍에 따라 다르며, 일반적으로 거래소 지원 페이지에 나열됩니다.</p><p> XRP/USD의 최소 거래 가능 금액이 20 XRP(거래소에서 제공)이고, 가격이 0.6$인 경우, 이 쌍을 구매하기 위한 최소 스테이크 금액은 <code> 20 * 0.6 ~= 12 </code> 입니다. 이 거래소에는 USD에 대한 제한도 있으며, 모든 주문은 10$ 이상이어야 하지만, 이 경우에는 적용되지 않습니다. </p><p> 안전한 실행을 보장하기 위해 freqtrade는 10.1$의 스테이크 금액으로 구매를 허용하지 않으며, 쌍 아래에 손절매를 배치할 충분한 공간이 있는지 확인합니다(기본값은 <code> amount_reserve_percent </code> 로 정의된 오프셋 포함, 기본값은 5%). </p><p> 5%의 예약으로 최소 스테이크 금액은 약 12.6$( <code> 12 * (1 + 0.05) </code> )입니다. 여기에 10%의 손절매를 추가하면 약 14$( <code> 12.6 / (1 - 0.1) </code> )입니다. </p><p>큰 손절매 값의 경우 이 계산을 제한하기 위해, 계산된 최소 스테이크 한도는 실제 한도보다 50% 이상 높지 않습니다.</p><div class="admonition warning"><p class="admonition-title">경고</p><p>거래소의 제한은 일반적으로 안정적이며 자주 업데이트되지 않으므로, 일부 쌍은 최소 한도가 매우 높을 수 있습니다. 이는 가격이 마지막으로 거래소에서 한도를 조정한 이후 크게 상승했기 때문입니다. freqtrade는 계산된/원하는 스테이크 금액보다 30% 이상인 경우 거래를 거부합니다.</p></div><h4 id="dry-run-wallet"> 드라이런 지갑 <a class="headerlink" href="#dry-run-wallet" title="영구 링크"></a></h4><p> 드라이런 모드에서 실행할 때, 봇은 거래를 실행하기 위해 시뮬레이션 지갑을 사용합니다. 이 지갑의 시작 잔액은 <code> dry_run_wallet </code> 에 의해 정의됩니다(기본값은 1000). 더 복잡한 시나리오의 경우, 사전을 <code> dry_run_wallet </code> 에 할당하여 각 통화의 시작 잔액을 정의할 수 있습니다. </p><div class="highlight"><pre><code><span class="nt">&quot;dry_run_wallet&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;BTC&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">0.01</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;ETH&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;USDT&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">1000</span>
<span class="p">}</span>
</code></pre></div><p> 명령줄 옵션( <code> --dry-run-wallet </code> )을 사용하여 구성 값을 재정의할 수 있지만, 부동 소수점 값에만 해당됩니다. 사전을 사용하려면 설정 파일을 조정하세요. </p><div class="admonition note"><p class="admonition-title">참고</p><p>스테이크 통화가 아닌 잔액은 거래에 사용되지 않지만, 지갑 잔액의 일부로 표시됩니다. 크로스 마진 거래소에서는 지갑 잔액이 거래에 사용할 수 있는 담보를 계산하는 데 사용될 수 있습니다.</p></div><h4 id="tradable-balance"> 거래 가능한 잔액 <a class="headerlink" href="#tradable-balance" title="영구 링크"></a></h4><p> 기본적으로 봇은 <code> 전체 금액 - 1% </code> 을 사용할 수 있다고 가정하며, <a href="#dynamic-stake-amount"> 동적 스테이크 금액 </a> 을 사용할 때, 전체 잔액을 <code> max_open_trades </code> 버킷으로 나눕니다. freqtrade는 거래에 진입할 때 수수료를 위해 1%를 예약하므로 기본적으로 이를 사용하지 않습니다. </p><p> &quot;손대지 않은&quot; 금액을 구성하려면 <code> tradable_balance_ratio </code> 설정을 사용하세요. </p><p> 예를 들어, 거래소 지갑에 10 ETH가 있고 <code> tradable_balance_ratio=0.5 </code> (50%)인 경우, 봇은 최대 5 ETH를 거래에 사용할 수 있으며, 이를 사용 가능한 잔액으로 간주합니다. 나머지 지갑은 거래에 사용되지 않습니다. </p><div class="admonition danger"><p class="admonition-title">위험</p><p> 이 설정은 동일한 계정에서 여러 봇을 실행할 때 사용해서는 안 됩니다. 대신 <a href="#assign-available-capital"> 봇에 사용할 수 있는 자본 할당 </a> 을 참조하세요. </p></div><div class="admonition warning"><p class="admonition-title">경고</p><p><code> tradable_balance_ratio </code> 설정은 현재 잔액(사용 가능한 잔액 + 거래에 묶인 잔액)에 적용됩니다. 따라서 시작 잔액이 1000인 경우, <code> tradable_balance_ratio=0.99 </code> 구성을 사용하면 거래소에 항상 10 통화 단위가 남아 있음을 보장하지 않습니다. 예를 들어, 자유 금액은 총 잔액이 500으로 감소하면 5 단위로 줄어들 수 있습니다(연속 손실 또는 잔액 인출로 인해). </p></div><h4 id="assign-available-capital"> 사용 가능한 자본 할당 <a class="headerlink" href="#assign-available-capital" title="영구 링크"></a></h4><p> 동일한 거래소 계정에서 여러 봇을 사용할 때 복리 수익을 최대한 활용하려면 각 봇을 특정 시작 잔액으로 제한해야 합니다. 이를 위해 <code> available_capital </code> 을 원하는 시작 잔액으로 설정하세요. </p><p> 계정에 10000 USDT가 있고 이 거래소에서 두 가지 다른 전략을 실행하려는 경우, <code> available_capital=5000 </code> 을 설정하여 각 봇에 5000 USDT의 초기 자본을 부여합니다. 봇은 이 시작 잔액을 <code> max_open_trades </code> 버킷으로 균등하게 나눕니다. 수익성 있는 거래는 이 봇의 스테이크 크기를 증가시키며, 다른 봇의 스테이크 크기에는 영향을 미치지 않습니다. </p><p><code> available_capital </code> 을 조정하려면 구성을 다시 로드해야 합니다. <code> available_capital </code> 을 조정하면 이전 <code> available_capital </code> 과 새로운 <code> available_capital </code> 의 차이가 추가됩니다. 거래가 열려 있을 때 사용 가능한 자본을 줄이면 거래를 종료하지 않습니다. 차이는 거래가 종료될 때 지갑으로 반환됩니다. 이 결과는 조정과 거래 종료 사이의 가격 변동에 따라 다릅니다. </p><div class="admonition warning"><p class="admonition-title"><code> tradable_balance_ratio </code> 와 호환되지 않음 </p><p> 이 옵션을 설정하면 <code> tradable_balance_ratio </code> 구성이 대체됩니다. </p></div><h4 id="amend-last-stake-amount"> 마지막 스테이크 금액 수정 <a class="headerlink" href="#amend-last-stake-amount" title="영구 링크"></a></h4><p> 거래 가능한 잔액이 1000 USDT, <code> stake_amount=400 </code> , <code> max_open_trades=3 </code> 인 경우를 가정합니다. 봇은 2개의 거래를 열고, 요청된 400 USDT가 더 이상 사용 가능하지 않으므로 마지막 거래 슬롯을 채울 수 없습니다. 이는 800 USDT가 이미 다른 거래에 묶여 있기 때문입니다. </p><p> 이를 극복하기 위해 <code> amend_last_stake_amount </code> 옵션을 <code> True </code> 로 설정하여 봇이 마지막 거래 슬롯을 채우기 위해 사용 가능한 잔액으로 스테이크 금액을 줄일 수 있습니다. </p><p>위 예제에서는 다음과 같습니다:</p><ul><li>거래1: 400 USDT</li><li>거래2: 400 USDT</li><li>거래3: 200 USDT</li></ul><div class="admonition note"><p class="admonition-title">참고</p><p> 이 옵션은 <a href="#static-stake-amount"> 정적 스테이크 금액 </a> 에서만 적용됩니다. 이는 <a href="#dynamic-stake-amount"> 동적 스테이크 금액 </a> 이 잔액을 균등하게 나누기 때문입니다. </p></div><div class="admonition note"><p class="admonition-title">참고</p><p> 최소 마지막 스테이크 금액은 <code> last_stake_amount_min_ratio </code> 를 사용하여 구성할 수 있으며, 기본값은 0.5(50%)입니다. 이는 사용되는 최소 스테이크 금액이 <code> stake_amount * 0.5 </code> 임을 의미합니다. 이는 쌍의 최소 거래 가능 금액에 가까운 매우 낮은 스테이크 금액을 방지하며, 거래소에서 거부될 수 있습니다. </p></div><h4 id="static-stake-amount"> 정적 스테이크 금액 <a class="headerlink" href="#static-stake-amount" title="영구 링크"></a></h4><p><code> stake_amount </code> 구성은 봇이 각 거래에 사용할 스테이크 통화의 양을 정적으로 구성합니다. </p><p>최소 구성 값은 0.0001이지만, 문제를 피하기 위해 사용하는 스테이크 통화의 거래소 최소 한도를 확인하세요.</p><p> 이 설정은 <code> max_open_trades </code> 와 함께 작동합니다. 거래에 사용되는 최대 자본은 <code> stake_amount * max_open_trades </code> 입니다. 예를 들어, 봇은 최대 (0.05 BTC x 3) = 0.15 BTC를 사용합니다. 이는 <code> max_open_trades=3 </code> 및 <code> stake_amount=0.05 </code> 구성의 경우입니다. </p><div class="admonition note"><p class="admonition-title">참고</p><p> 이 설정은 <a href="#tradable-balance"> 사용 가능한 잔액 구성 </a> 을 준수합니다. </p></div><h4 id="dynamic-stake-amount"> 동적 스테이크 금액 <a class="headerlink" href="#dynamic-stake-amount" title="영구 링크"></a></h4><p> 대안으로, 동적 스테이크 금액을 사용할 수 있으며, 이는 거래소에서 사용 가능한 잔액을 사용하고, 허용된 거래 수( <code> max_open_trades </code> )로 균등하게 나눕니다. </p><p> 이를 구성하려면 <code> stake_amount=&quot;unlimited&quot; </code> 로 설정하세요. 또한 <code> tradable_balance_ratio=0.99 </code> (99%)로 설정하여 수수료를 위한 최소 잔액을 유지하는 것이 좋습니다. </p><p>이 경우 거래 금액은 다음과 같이 계산됩니다:</p><div class="highlight"><pre><code><span class="n">currency_balance</span> <span class="o">/</span> <span class="p">(</span><span class="n">max_open_trades</span> <span class="o">-</span> <span class="n">current_open_trades</span><span class="p">)</span>
</code></pre></div><p> 봇이 계정의 모든 사용 가능한 <code> stake_currency </code> 를 거래하도록 하려면( <code> tradable_balance_ratio </code> 제외) 다음과 같이 설정하세요: </p><div class="highlight"><pre><code><span class="nt">&quot;stake_amount&quot;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;unlimited&quot;</span><span class="p">,</span>
<span class="nt">&quot;tradable_balance_ratio&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">0.99</span><span class="p">,</span>
</code></pre></div><div class="admonition tip"><p class="admonition-title">복리 수익</p><p>이 구성은 봇의 성능에 따라 스테이크를 증가/감소시킬 수 있으며(봇이 손실을 입으면 낮은 스테이크, 승리 기록이 있으면 높은 스테이크), 복리 수익을 초래합니다.</p></div><div class="admonition note"><p class="admonition-title">드라이런 모드 사용 시</p><p><code> &quot;stake_amount&quot; : &quot;unlimited&quot;, </code> 를 드라이런, 백테스팅 또는 하이퍼옵트와 함께 사용할 때, 잔액은 <code> dry_run_wallet </code> 로 시작하여 시뮬레이션됩니다. 따라서 <code> dry_run_wallet </code> 을 적절한 값으로 설정하는 것이 중요합니다(예: BTC의 경우 0.05 또는 0.01, USDT의 경우 1000 또는 100). 그렇지 않으면 한 번에 100 BTC(또는 그 이상) 또는 0.05 USDT(또는 그 이하)로 거래를 시뮬레이션할 수 있으며, 이는 실제 사용 가능한 잔액에 해당하지 않거나 스테이크 통화의 거래소 최소 한도보다 적을 수 있습니다. </p></div><h4 id="dynamic-stake-amount-with-position-adjustment"> 포지션 조정이 있는 동적 스테이크 금액 <a class="headerlink" href="#dynamic-stake-amount-with-position-adjustment" title="영구 링크"></a></h4><p> 무제한 스테이크로 포지션 조정을 사용하려면, 전략에 따라 값을 반환하는 <code> custom_stake_amount </code> 도 구현해야 합니다. 일반적인 값은 제안된 스테이크의 25% - 50% 범위에 해당하지만, 전략과 포지션 조정 버퍼로 지갑에 남기려는 양에 따라 크게 다릅니다. </p><p>예를 들어, 포지션 조정이 동일한 스테이크 금액으로 2개의 추가 매수를 가정하는 경우, 버퍼는 제안된 무제한 스테이크 금액의 66.6667%여야 합니다.</p><p> 또 다른 예로, 포지션 조정이 원래 스테이크 금액의 3배로 1개의 추가 매수를 가정하는 경우, <code> custom_stake_amount </code> 는 제안된 스테이크 금액의 25%를 반환하고, 나머지 75%는 나중에 포지션 조정을 위해 남겨둬야 합니다. </p><h2 id="prices-used-for-orders"> 주문에 사용되는 가격 <a class="headerlink" href="#prices-used-for-orders" title="영구 링크"></a></h2><p> 일반 주문의 가격은 거래 진입을 위한 <code> entry_pricing </code> 및 거래 종료를 위한 <code> exit_pricing </code> 매개변수 구조를 통해 제어할 수 있습니다. 가격은 주문이 게시되기 직전에 항상 검색되며, 거래소 티커를 쿼리하거나 주문서 데이터를 사용하여 검색됩니다. </p><div class="admonition note"><p class="admonition-title">참고</p><p> freqtrade에서 사용하는 주문서 데이터는 ccxt의 <code> fetch_order_book() </code> 함수를 통해 거래소에서 검색된 데이터입니다. 이는 일반적으로 L2-집계된 주문서 데이터입니다. 티커 데이터는 ccxt의 <code> fetch_ticker() </code> / <code> fetch_tickers() </code> 함수가 반환하는 구조입니다. 자세한 내용은 ccxt 라이브러리 <a href="https://github.com/ccxt/ccxt/wiki/Manual#market-data"> 문서 </a> 를 참조하세요. </p></div><div class="admonition warning"><p class="admonition-title">시장가 주문 사용</p><p> 시장가 주문을 사용할 때 <a href="#market-order-pricing"> 시장가 주문 가격 책정 </a> 섹션을 주의 깊게 읽으세요. </p></div><h3 id="entry-price"> 진입 가격 <a class="headerlink" href="#entry-price" title="영구 링크"></a></h3><h4 id="enter-price-side"> 진입 가격 측면 <a class="headerlink" href="#enter-price-side" title="영구 링크"></a></h4><p> 구성 설정 <code> entry_pricing.price_side </code> 는 봇이 구매할 때 주문서의 어느 쪽을 볼지 정의합니다. </p><p>다음은 주문서를 표시합니다.</p><div class="highlight"><pre><code>...
103
102
101  # ask
-------------Current spread
99   # bid
98
97
...
</code></pre></div><p><code> entry_pricing.price_side </code>가 <code> &quot;bid&quot; </code>로 설정된 경우, 봇은 99를 진입 가격으로 사용합니다. <br> 이에 따라 <code> entry_pricing.price_side </code>가 <code> &quot;ask&quot; </code>로 설정된 경우, 봇은 101을 진입 가격으로 사용합니다. <br></p><p> 주문 방향( <em> long </em> / <em> short </em> )에 따라 다른 결과를 초래할 수 있습니다. 따라서 이 구성을 위해 <code> &quot;same&quot; </code> 또는 <code> &quot;other&quot; </code> 를 사용하는 것이 좋습니다. 이는 다음과 같은 가격 책정 매트릭스를 초래합니다: </p><table><thead><tr><th>방향</th><th>주문</th><th>설정</th><th>가격</th><th>스프레드 교차</th></tr></thead><tbody><tr><td>long</td><td>구매</td><td>ask</td><td>101</td><td>예</td></tr><tr><td>long</td><td>구매</td><td>bid</td><td>99</td><td>아니요</td></tr><tr><td>long</td><td>구매</td><td>same</td><td>99</td><td>아니요</td></tr><tr><td>long</td><td>구매</td><td>other</td><td>101</td><td>예</td></tr><tr><td>short</td><td>판매</td><td>ask</td><td>101</td><td>아니요</td></tr><tr><td>short</td><td>판매</td><td>bid</td><td>99</td><td>예</td></tr><tr><td>short</td><td>판매</td><td>same</td><td>101</td><td>아니요</td></tr><tr><td>short</td><td>판매</td><td>other</td><td>99</td><td>예</td></tr></tbody></table><p>주문서의 다른 쪽을 사용하는 것은 종종 더 빠른 주문 체결을 보장하지만, 봇이 필요 이상으로 지불할 수도 있습니다. 제작자 수수료 대신 수수료가 적용될 가능성이 높습니다. 또한, 스프레드의 &quot;다른&quot; 쪽 가격은 주문서의 &quot;bid&quot; 쪽 가격보다 높으므로, 주문은 시장가 주문과 유사하게 작동합니다(단, 최대 가격이 있음).</p><h4 id="entry-price-with-orderbook-enabled"> 주문서가 활성화된 진입 가격 <a class="headerlink" href="#entry-price-with-orderbook-enabled" title="영구 링크"></a></h4><p> 주문서가 활성화된 상태에서 거래에 진입할 때( <code> entry_pricing.use_order_book=True </code> ), freqtrade는 주문서에서 <code> entry_pricing.order_book_top </code> 항목을 가져와 구성된 측면( <code> entry_pricing.price_side </code> )의 주문서에서 <code> entry_pricing.order_book_top </code> 에 지정된 항목을 사용합니다. 1은 주문서의 최상위 항목을 지정하며, 2는 주문서의 두 번째 항목을 사용합니다. </p><h4 id="entry-price-without-orderbook-enabled"> 주문서가 활성화되지 않은 진입 가격 <a class="headerlink" href="#entry-price-without-orderbook-enabled" title="영구 링크"></a></h4><p> 다음 섹션에서는 구성된 <code> entry_pricing.price_side </code> (기본값은 <code> &quot;same&quot; </code> )을 사용합니다. </p><p> 주문서를 사용하지 않을 때( <code> entry_pricing.use_order_book=False </code> ), freqtrade는 티커의 <code> last </code> 거래 가격보다 낮은 경우 티커의 최상의 <code> side </code> 가격을 사용합니다. 그렇지 않은 경우( <code> side </code> 가격이 <code> last </code> 가격보다 높은 경우), <code> entry_pricing.price_last_balance </code> 기반으로 <code> side </code> 와 <code> last </code> 가격 사이의 비율을 계산합니다. </p><p><code> entry_pricing.price_last_balance </code> 구성 매개변수가 이를 제어합니다. <code> 0.0 </code> 값은 <code> side </code> 가격을 사용하며, <code> 1.0 </code> 값은 <code> last </code> 가격을 사용합니다. 그 사이의 값은 ask와 last 가격 사이를 보간합니다. </p><h4 id="check-depth-of-market"> 시장 깊이 확인 <a class="headerlink" href="#check-depth-of-market" title="영구 링크"></a></h4><p> 시장 깊이 확인이 활성화된 경우( <code> entry_pricing.check_depth_of_market.enabled=True </code> ), 진입 신호는 주문서 깊이(각 주문서 측면의 모든 금액 합계)를 기반으로 필터링됩니다. </p><p> 주문서 <code> bid </code> (매수) 측면 깊이는 주문서 <code> ask </code> (매도) 측면 깊이로 나누어지며, 결과 델타는 <code> entry_pricing.check_depth_of_market.bids_to_ask_delta </code> 매개변수 값과 비교됩니다. 주문서 델타가 구성된 델타 값보다 크거나 같은 경우에만 진입 주문이 실행됩니다. </p><div class="admonition note"><p class="admonition-title">참고</p><p> 델타 값이 1보다 작으면 <code> ask </code> (매도) 주문서 측면 깊이가 <code> bid </code> (매수) 주문서 측면 깊이보다 크며, 값이 1보다 크면 반대(매수 측면 깊이가 매도 측면 깊이보다 큼)를 의미합니다. </p></div><h3 id="exit-price"> 종료 가격 <a class="headerlink" href="#exit-price" title="영구 링크"></a></h3><h4 id="exit-price-side"> 종료 가격 측면 <a class="headerlink" href="#exit-price-side" title="영구 링크"></a></h4><p> 구성 설정 <code> exit_pricing.price_side </code> 는 봇이 거래를 종료할 때 스프레드의 어느 쪽을 볼지 정의합니다. </p><p>다음은 주문서를 표시합니다:</p><div class="highlight"><pre><code>...
103
102
101  # ask
-------------Current spread
99   # bid
98
97
...
</code></pre></div><p><code> exit_pricing.price_side </code>가 <code> &quot;ask&quot; </code>로 설정된 경우, 봇은 101을 종료 가격으로 사용합니다. <br> 이에 따라 <code> exit_pricing.price_side </code>가 <code> &quot;bid&quot; </code>로 설정된 경우, 봇은 99를 종료 가격으로 사용합니다. <br></p><p> 주문 방향( <em> long </em> / <em> short </em> )에 따라 다른 결과를 초래할 수 있습니다. 따라서 이 구성을 위해 <code> &quot;same&quot; </code> 또는 <code> &quot;other&quot; </code> 를 사용하는 것이 좋습니다. 이는 다음과 같은 가격 책정 매트릭스를 초래합니다: </p><table><thead><tr><th>방향</th><th>주문</th><th>설정</th><th>가격</th><th>스프레드 교차</th></tr></thead><tbody><tr><td>long</td><td>판매</td><td>ask</td><td>101</td><td>아니요</td></tr><tr><td>long</td><td>판매</td><td>bid</td><td>99</td><td>예</td></tr><tr><td>long</td><td>판매</td><td>same</td><td>101</td><td>아니요</td></tr><tr><td>long</td><td>판매</td><td>other</td><td>99</td><td>예</td></tr><tr><td>short</td><td>구매</td><td>ask</td><td>101</td><td>예</td></tr><tr><td>short</td><td>구매</td><td>bid</td><td>99</td><td>아니요</td></tr><tr><td>short</td><td>구매</td><td>same</td><td>99</td><td>아니요</td></tr><tr><td>short</td><td>구매</td><td>other</td><td>101</td><td>예</td></tr></tbody></table><h4 id="exit-price-with-orderbook-enabled"> 주문서가 활성화된 종료 가격 <a class="headerlink" href="#exit-price-with-orderbook-enabled" title="영구 링크"></a></h4><p> 주문서가 활성화된 상태에서 종료할 때( <code> exit_pricing.use_order_book=True </code> ), freqtrade는 주문서에서 <code> exit_pricing.order_book_top </code> 항목을 가져와 구성된 측면( <code> exit_pricing.price_side </code> )의 주문서에서 <code> exit_pricing.order_book_top </code> 에 지정된 항목을 사용합니다. </p><p>1은 주문서의 최상위 항목을 지정하며, 2는 주문서의 두 번째 항목을 사용합니다.</p><h4 id="exit-price-without-orderbook-enabled"> 주문서가 활성화되지 않은 종료 가격 <a class="headerlink" href="#exit-price-without-orderbook-enabled" title="영구 링크"></a></h4><p> 다음 섹션에서는 구성된 <code> exit_pricing.price_side </code> (기본값은 <code> &quot;ask&quot; </code> )을 사용합니다. </p><p> 주문서를 사용하지 않을 때( <code> exit_pricing.use_order_book=False </code> ), freqtrade는 티커의 <code> last </code> 거래 가격보다 높은 경우 티커의 최상의 <code> side </code> 가격을 사용합니다. 그렇지 않은 경우( <code> side </code> 가격이 <code> last </code> 가격보다 낮은 경우), <code> exit_pricing.price_last_balance </code> 기반으로 <code> side </code> 와 <code> last </code> 가격 사이의 비율을 계산합니다. </p><p><code> exit_pricing.price_last_balance </code> 구성 매개변수가 이를 제어합니다. <code> 0.0 </code> 값은 <code> side </code> 가격을 사용하며, <code> 1.0 </code> 값은 <code> last </code> 가격을 사용합니다. 그 사이의 값은 <code> side </code> 와 <code> last </code> 가격 사이를 보간합니다. </p><h3 id="market-order-pricing"> 시장가 주문 가격 책정 <a class="headerlink" href="#market-order-pricing" title="영구 링크"></a></h3><p>시장가 주문을 사용할 때, 현실적인 가격 감지를 허용하기 위해 &quot;올바른&quot; 주문서 측면을 사용하도록 가격을 구성해야 합니다. 진입 및 종료가 모두 시장가 주문을 사용하는 경우, 다음과 유사한 구성을 사용해야 합니다:</p><div class="highlight"><pre><code>  &quot;order_types&quot;: {
    &quot;entry&quot;: &quot;market&quot;,
    &quot;exit&quot;: &quot;market&quot;
    // ...
  },
  &quot;entry_pricing&quot;: {
    &quot;price_side&quot;: &quot;other&quot;,
    // ...
  },
  &quot;exit_pricing&quot;:{
    &quot;price_side&quot;: &quot;other&quot;,
    // ...
  },
</code></pre></div><p>물론, 한쪽만 지정가 주문을 사용하는 경우, 다른 가격 조합을 사용할 수 있습니다.</p><h2 id="further-configuration-details"> 추가 구성 세부 정보 <a class="headerlink" href="#further-configuration-details" title="영구 링크"></a></h2><h3 id="understand-minimal_roi"> minimal_roi 이해하기 <a class="headerlink" href="#understand-minimal_roi" title="영구 링크"></a></h3><p><code> minimal_roi </code> 구성 매개변수는 JSON 객체로, 키는 기간(분)이고 값은 최소 ROI 비율입니다. 아래 예제를 참조하세요: </p><div class="highlight"><pre><code><span class="nt">&quot;minimal_roi&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;40&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w">    </span><span class="err">#</span><span class="w"> </span><span class="err">Exi</span><span class="kc">t</span><span class="w"> </span><span class="err">a</span><span class="kc">fter</span><span class="w"> </span><span class="mi">40</span><span class="w"> </span><span class="err">mi</span><span class="kc">nutes</span><span class="w"> </span><span class="err">i</span><span class="kc">f</span><span class="w"> </span><span class="kc">t</span><span class="err">he</span><span class="w"> </span><span class="err">pro</span><span class="kc">f</span><span class="err">i</span><span class="kc">t</span><span class="w"> </span><span class="err">is</span><span class="w"> </span><span class="kc">n</span><span class="err">o</span><span class="kc">t</span><span class="w"> </span><span class="kc">ne</span><span class="err">ga</span><span class="kc">t</span><span class="err">ive</span>
<span class="w">    </span><span class="nt">&quot;30&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">0.01</span><span class="p">,</span><span class="w">   </span><span class="err">#</span><span class="w"> </span><span class="err">Exi</span><span class="kc">t</span><span class="w"> </span><span class="err">a</span><span class="kc">fter</span><span class="w"> </span><span class="mi">30</span><span class="w"> </span><span class="err">mi</span><span class="kc">nutes</span><span class="w"> </span><span class="err">i</span><span class="kc">f</span><span class="w"> </span><span class="kc">t</span><span class="err">here</span><span class="w"> </span><span class="err">is</span><span class="w"> </span><span class="err">a</span><span class="kc">t</span><span class="w"> </span><span class="err">leas</span><span class="kc">t</span><span class="w"> </span><span class="mi">1</span><span class="err">%</span><span class="w"> </span><span class="err">pro</span><span class="kc">f</span><span class="err">i</span><span class="kc">t</span>
<span class="w">    </span><span class="nt">&quot;20&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">0.02</span><span class="p">,</span><span class="w">   </span><span class="err">#</span><span class="w"> </span><span class="err">Exi</span><span class="kc">t</span><span class="w"> </span><span class="err">a</span><span class="kc">fter</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="err">mi</span><span class="kc">nutes</span><span class="w"> </span><span class="err">i</span><span class="kc">f</span><span class="w"> </span><span class="kc">t</span><span class="err">here</span><span class="w"> </span><span class="err">is</span><span class="w"> </span><span class="err">a</span><span class="kc">t</span><span class="w"> </span><span class="err">leas</span><span class="kc">t</span><span class="w"> </span><span class="mi">2</span><span class="err">%</span><span class="w"> </span><span class="err">pro</span><span class="kc">f</span><span class="err">i</span><span class="kc">t</span>
<span class="w">    </span><span class="nt">&quot;0&quot;</span><span class="p">:</span><span class="w">  </span><span class="mf">0.04</span><span class="w">    </span><span class="err">#</span><span class="w"> </span><span class="err">Exi</span><span class="kc">t</span><span class="w"> </span><span class="err">immedia</span><span class="kc">tel</span><span class="err">y</span><span class="w"> </span><span class="err">i</span><span class="kc">f</span><span class="w"> </span><span class="kc">t</span><span class="err">here</span><span class="w"> </span><span class="err">is</span><span class="w"> </span><span class="err">a</span><span class="kc">t</span><span class="w"> </span><span class="err">leas</span><span class="kc">t</span><span class="w"> </span><span class="mi">4</span><span class="err">%</span><span class="w"> </span><span class="err">pro</span><span class="kc">f</span><span class="err">i</span><span class="kc">t</span>
<span class="p">},</span>
</code></pre></div><p> 대부분의 전략 파일에는 이미 최적의 <code> minimal_roi </code> 값이 포함되어 있습니다. 이 매개변수는 전략 또는 설정 파일에 설정할 수 있습니다. 설정 파일에서 사용하면 전략 파일의 <code> minimal_roi </code> 값을 덮어씁니다. 전략 또는 설정 파일에 설정되지 않은 경우, 기본값은 1000%( <code> {&quot;0&quot;: 10} </code> )이며, 거래가 1000% 수익을 생성하지 않는 한 최소 ROI가 비활성화됩니다. </p><div class="admonition note"><p class="admonition-title">특정 시간 후 강제 종료</p><p> 특수한 경우는 <code> &quot;&lt;N&gt;&quot;: -1 </code> 을 ROI로 사용하는 것입니다. 이는 N 분 후에 거래를 종료하도록 봇을 강제하며, 이는 긍정적이든 부정적이든 상관없이 시간 제한 강제 종료를 나타냅니다. </p></div><h3 id="understand-force_entry_enable"> force_entry_enable 이해하기 <a class="headerlink" href="#understand-force_entry_enable" title="영구 링크"></a></h3><p><code> force_entry_enable </code> 구성 매개변수는 텔레그램 및 REST API를 통해 강제 진입( <code> /forcelong </code> , <code> /forceshort </code> ) 명령의 사용을 활성화합니다. 보안상의 이유로 기본적으로 비활성화되어 있으며, 활성화된 경우 freqtrade는 시작 시 경고 메시지를 표시합니다. 예를 들어, 봇에 <code> /forceenter ETH/BTC </code> 를 보내면 freqtrade가 쌍을 구매하고, 정기적인 종료 신호(ROI, 손절매, /forceexit)가 나타날 때까지 보유합니다. </p><p>일부 전략에서는 위험할 수 있으므로 주의해서 사용하세요.</p>`,104)),s("p",null,[n[394]||(n[394]=l(" 사용에 대한 자세한 내용은 ")),a(t,{to:"telegram-usage"},{default:p(()=>n[393]||(n[393]=[l(" 텔레그램 문서 ")])),_:1}),n[395]||(n[395]=l(" 를 참조하세요. "))]),n[429]||(n[429]=o(`<h3 id="ignoring-expired-candles"> 만료된 캔들 무시 <a class="headerlink" href="#ignoring-expired-candles" title="영구 링크"></a></h3><p> 더 큰 시간 프레임(예: 1시간 이상)을 사용하고 <code> max_open_trades </code> 값이 낮은 경우, 거래 슬롯이 사용 가능해지면 마지막 캔들이 처리될 수 있습니다. 마지막 캔들을 처리할 때, 해당 캔들에서 매수 신호를 사용하는 것이 바람직하지 않을 수 있습니다. 예를 들어, 전략에서 교차 조건을 사용하는 경우, 해당 지점이 너무 오래되어 거래를 시작하기에 적합하지 않을 수 있습니다. </p><p> 이러한 상황에서는 매수 신호가 만료된 후 더 이상 사용되지 않도록 <code> ignore_buying_expired_candle_after </code> 를 양수로 설정하여 기능을 활성화할 수 있습니다. </p><p>예를 들어, 전략이 1시간 시간 프레임을 사용하고, 새로운 캔들이 들어올 때 처음 5분 이내에 매수하려는 경우, 전략에 다음 구성을 추가할 수 있습니다:</p><div class="highlight"><pre><code><span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="c1">//...</span>
<span class="w">    </span><span class="nt">&quot;ignore_buying_expired_candle_after&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">300</span><span class="p">,</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="w">  </span><span class="p">}</span>
</code></pre></div><div class="admonition note"><p class="admonition-title">참고</p><p>이 설정은 각 새로운 캔들마다 재설정되므로, 신호가 활성화된 2번째 또는 3번째 캔들에서 실행되는 것을 방지하지 않습니다. 신호가 한 캔들 동안만 활성화되는 &quot;트리거&quot; 선택기를 사용하는 것이 좋습니다.</p></div><h3 id="understand-order_types"> order_types 이해하기 <a class="headerlink" href="#understand-order_types" title="영구 링크"></a></h3><p><code> order_types </code> 구성 매개변수는 작업( <code> entry </code> , <code> exit </code> , <code> stoploss </code> , <code> emergency_exit </code> , <code> force_exit </code> , <code> force_entry </code> )을 주문 유형( <code> market </code> , <code> limit </code> , ...)에 매핑하고, 거래소에서 손절매를 설정하며, 거래소에서 손절매 업데이트 간격을 초 단위로 정의합니다. </p><p>이를 통해 지정가 주문을 사용하여 진입하고, 지정가 주문을 사용하여 종료하며, 시장가 주문을 사용하여 손절매를 생성할 수 있습니다. 또한 손절매를 &quot;거래소에서&quot; 설정할 수 있으며, 이는 매수 주문이 체결되면 즉시 손절매 주문이 게시됨을 의미합니다.</p><p> 구성 파일에 설정된 <code> order_types </code> 는 전략에 설정된 값을 전체적으로 덮어쓰므로, <code> order_types </code> 사전을 한 곳에 구성해야 합니다. </p><p> 이것이 구성된 경우, <code> entry </code> , <code> exit </code> , <code> stoploss </code> 및 <code> stoploss_on_exchange </code> 의 4가지 값이 모두 있어야 하며, 그렇지 않으면 봇이 시작되지 않습니다. </p>`,11)),s("p",null,[n[397]||(n[397]=l(" ( ")),n[398]||(n[398]=s("code",null," emergency_exit ",-1)),n[399]||(n[399]=l(" , ")),n[400]||(n[400]=s("code",null," force_exit ",-1)),n[401]||(n[401]=l(" , ")),n[402]||(n[402]=s("code",null," force_entry ",-1)),n[403]||(n[403]=l(" , ")),n[404]||(n[404]=s("code",null," stoploss_on_exchange ",-1)),n[405]||(n[405]=l(" , ")),n[406]||(n[406]=s("code",null," stoploss_on_exchange_interval ",-1)),n[407]||(n[407]=l(" , ")),n[408]||(n[408]=s("code",null," stoploss_on_exchange_limit_ratio ",-1)),n[409]||(n[409]=l(" )에 대한 정보는 손절매 문서 ")),a(t,{to:"stoploss"},{default:p(()=>n[396]||(n[396]=[l(" 거래소에서 손절매 ")])),_:1}),n[410]||(n[410]=l(" 를 참조하세요. "))]),n[430]||(n[430]=o(`<p>전략의 구문:</p><div class="highlight"><pre><code><span class="n">order_types</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;entry&quot;</span><span class="p">:</span> <span class="s2">&quot;limit&quot;</span><span class="p">,</span>
    <span class="s2">&quot;exit&quot;</span><span class="p">:</span> <span class="s2">&quot;limit&quot;</span><span class="p">,</span>
    <span class="s2">&quot;emergency_exit&quot;</span><span class="p">:</span> <span class="s2">&quot;market&quot;</span><span class="p">,</span>
    <span class="s2">&quot;force_entry&quot;</span><span class="p">:</span> <span class="s2">&quot;market&quot;</span><span class="p">,</span>
    <span class="s2">&quot;force_exit&quot;</span><span class="p">:</span> <span class="s2">&quot;market&quot;</span><span class="p">,</span>
    <span class="s2">&quot;stoploss&quot;</span><span class="p">:</span> <span class="s2">&quot;market&quot;</span><span class="p">,</span>
    <span class="s2">&quot;stoploss_on_exchange&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
    <span class="s2">&quot;stoploss_on_exchange_interval&quot;</span><span class="p">:</span> <span class="mi">60</span><span class="p">,</span>
    <span class="s2">&quot;stoploss_on_exchange_limit_ratio&quot;</span><span class="p">:</span> <span class="mf">0.99</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div><p>구성:</p><div class="highlight"><pre><code><span class="nt">&quot;order_types&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;entry&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;limit&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;exit&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;limit&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;emergency_exit&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;market&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;force_entry&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;market&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;force_exit&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;market&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;stoploss&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;market&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;stoploss_on_exchange&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;stoploss_on_exchange_interval&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">60</span>
<span class="p">}</span>
</code></pre></div><div class="admonition note"><p class="admonition-title">시장가 주문 지원</p><p> 모든 거래소가 &quot;시장&quot; 주문을 지원하는 것은 아닙니다. 거래소가 시장가 주문을 지원하지 않는 경우 다음 메시지가 표시됩니다: <code> &quot;Exchange &lt;yourexchange&gt; does not support market orders.&quot; </code> 봇이 시작되지 않습니다. </p></div><div class="admonition warning"><p class="admonition-title">시장가 주문 사용</p><p> 시장가 주문을 사용할 때 <a href="#market-order-pricing"> 시장가 주문 가격 책정 </a> 섹션을 주의 깊게 읽으세요. </p></div>`,6)),s("div",q,[n[415]||(n[415]=s("p",{class:"admonition-title"},"거래소에서 손절매",-1)),s("p",null,[n[412]||(n[412]=s("code",null," order_types.stoploss_on_exchange_interval ",-1)),n[413]||(n[413]=l(" 은 필수 항목이 아닙니다. 무엇을 하는지 확신하지 않는 한 값을 변경하지 마세요. 손절매가 작동하는 방식에 대한 자세한 내용은 ")),a(t,{to:"stoploss"},{default:p(()=>n[411]||(n[411]=[l("손절매 문서")])),_:1}),n[414]||(n[414]=l(" 를 참조하세요. "))]),n[416]||(n[416]=s("p",null,[s("code",null," order_types.stoploss_on_exchange "),l(" 가 활성화되고 손절매가 거래소에서 수동으로 취소된 경우, 봇은 새로운 손절매 주문을 생성합니다. ")],-1))]),n[431]||(n[431]=o(`<div class="admonition warning"><p class="admonition-title">경고: order_types.stoploss_on_exchange 실패</p><p> 손절매가 거래소에서 생성되지 않는 경우, &quot;비상 종료&quot;가 시작됩니다. 기본적으로 이는 시장가 주문을 사용하여 거래를 종료합니다. 비상 종료의 주문 유형은 <code> emergency_exit </code> 값을 <code> order_types </code> 사전에 설정하여 변경할 수 있지만, 이는 권장되지 않습니다. </p></div><h3 id="understand-order_time_in_force"> order_time_in_force 이해하기 <a class="headerlink" href="#understand-order_time_in_force" title="영구 링크"></a></h3><p><code> order_time_in_force </code> 구성 매개변수는 주문이 거래소에서 실행되는 정책을 정의합니다. 일반적으로 사용되는 유효 기간은 다음과 같습니다: </p><p><strong> GTC (Good Till Canceled): </strong></p><p>이는 대부분의 경우 기본 유효 기간입니다. 이는 사용자가 취소할 때까지 주문이 거래소에 남아 있음을 의미합니다. 완전히 또는 부분적으로 체결될 수 있습니다. 부분적으로 체결된 경우, 나머지는 취소될 때까지 거래소에 남아 있습니다.</p><p><strong> FOK (Fill Or Kill): </strong></p><p>이는 주문이 즉시 AND 완전히 실행되지 않으면 거래소에서 취소됨을 의미합니다.</p><p><strong> IOC (Immediate Or Canceled): </strong></p><p>이는 FOK(위)와 동일하지만 부분적으로 체결될 수 있습니다. 나머지 부분은 거래소에서 자동으로 취소됩니다.</p><p><strong> PO (Post only): </strong></p><p>게시 전용 주문입니다. 주문은 제작자 주문으로 게시되거나 취소됩니다. 이는 주문이 미체결 상태로 주문서에 게시되어야 함을 의미합니다.</p><h4 id="time_in_force-config"> time_in_force 구성 <a class="headerlink" href="#time_in_force-config" title="영구 링크"></a></h4><p><code> order_time_in_force </code> 매개변수는 진입 및 종료 유효 기간 정책 값을 포함하는 사전을 포함합니다. 이는 구성 파일 또는 전략에서 설정할 수 있습니다. 구성 파일에 설정된 값은 전략에 설정된 값을 덮어씁니다. </p><p> 가능한 값은 다음과 같습니다: <code> GTC </code> (기본값), <code> FOK </code> 또는 <code> IOC </code> . </p><div class="highlight"><pre><code><span class="s2">&quot;order_time_in_force&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">&quot;entry&quot;</span><span class="p">:</span> <span class="s2">&quot;GTC&quot;</span><span class="p">,</span>
    <span class="s2">&quot;exit&quot;</span><span class="p">:</span> <span class="s2">&quot;GTC&quot;</span>
<span class="p">},</span>
</code></pre></div><div class="admonition warning"><p class="admonition-title">경고</p><p>이 작업은 진행 중입니다. 현재는 binance, gate 및 kucoin에서만 지원됩니다. 기본값을 변경하지 마세요. 특정 거래소에 대한 다른 값을 사용하는 영향을 조사한 경우에만 변경하세요.</p></div><h3 id="fiat-conversion"> 법정 화폐 변환 <a class="headerlink" href="#fiat-conversion" title="영구 링크"></a></h3><p> freqtrade는 Coingecko API를 사용하여 텔레그램 보고서에서 코인 값을 해당 법정 화폐 값으로 변환합니다. 법정 화폐는 구성 파일에서 <code> fiat_display_currency </code> 로 설정할 수 있습니다. </p><p> 구성에서 <code> fiat_display_currency </code> 를 완전히 제거하면 coingecko 초기화가 건너뛰어지며, 법정 화폐 변환이 표시되지 않습니다. 이는 봇의 올바른 작동에 중요하지 않습니다. </p><h4 id="what-values-can-be-used-for-fiat_display_currency"> fiat_display_currency에 사용할 수 있는 값은 무엇입니까? <a class="headerlink" href="#what-values-can-be-used-for-fiat_display_currency" title="영구 링크"></a></h4><p><code> fiat_display_currency </code> 구성 매개변수는 봇 텔레그램 보고서에서 코인에서 법정 화폐로 변환하는 기본 통화를 설정합니다. </p><p>유효한 값은 다음과 같습니다:</p><div class="highlight"><pre><code><span class="s2">&quot;AUD&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;BRL&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;CAD&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;CHF&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;CLP&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;CNY&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;CZK&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;DKK&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;EUR&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;GBP&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;HKD&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;HUF&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;IDR&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;ILS&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;INR&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;JPY&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;KRW&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;MXN&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;MYR&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;NOK&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;NZD&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;PHP&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;PKR&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;PLN&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;RUB&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;SEK&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;SGD&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;THB&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;TRY&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;TWD&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;ZAR&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;USD&quot;</span>
</code></pre></div><p>법정 화폐 외에도 다양한 암호화폐가 지원됩니다.</p><p>유효한 값은 다음과 같습니다:</p><div class="highlight"><pre><code><span class="s2">&quot;BTC&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;ETH&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;XRP&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;LTC&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;BCH&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;BNB&quot;</span>
</code></pre></div><h4 id="coingecko-rate-limit-problems"> Coingecko 속도 제한 문제 <a class="headerlink" href="#coingecko-rate-limit-problems" title="영구 링크"></a></h4><p>일부 IP 범위에서는 coingecko가 심하게 속도 제한을 하고 있습니다. 이 경우 구성에 coingecko API 키를 추가하는 것이 좋습니다.</p><div class="highlight"><pre><code><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;fiat_display_currency&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;USD&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;coingecko&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nt">&quot;api_key&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;your-api&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="nt">&quot;is_demo&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>freqtrade는 데모 및 프로 coingecko API 키를 모두 지원합니다.</p><p>봇이 올바르게 작동하기 위해 Coingecko API 키가 필요하지 않습니다. 이는 텔레그램 보고서에서 코인에서 법정 화폐로 변환하는 데만 사용되며, 일반적으로 API 키 없이도 작동합니다.</p><h2 id="consuming-exchange-websockets"> 거래소 웹소켓 사용 <a class="headerlink" href="#consuming-exchange-websockets" title="영구 링크"></a></h2><p>freqtrade는 ccxt.pro를 통해 웹소켓을 사용할 수 있습니다.</p><p>freqtrade는 데이터가 항상 사용 가능하도록 보장하는 것을 목표로 합니다. 웹소켓 연결이 실패하거나 비활성화된 경우, 봇은 REST API 호출로 대체됩니다.</p><p> 웹소켓으로 인해 문제가 발생한다고 의심되는 경우, <code> exchange.enable_ws </code> 설정을 통해 이를 비활성화할 수 있습니다. 기본값은 true입니다. </p><div class="highlight"><pre><code>&quot;exchange&quot;: {
    // ...
    &quot;enable_ws&quot;: false,
    // ...
}
</code></pre></div><p> 프록시를 사용해야 하는 경우, 자세한 내용은 <a href="#using-proxy-with-freqtrade"> 프록시 섹션 </a> 을 참조하세요. </p><div class="admonition info"><p class="admonition-title">배포</p><p>우리는 안정성을 보장하기 위해 이를 천천히 구현하고 있습니다. 현재 사용은 ohlcv 데이터 스트림으로 제한됩니다. 또한 몇몇 거래소로 제한되며, 새로운 거래소가 지속적으로 추가되고 있습니다.</p></div><h2 id="using-dry-run-mode"> 드라이런 모드 사용 <a class="headerlink" href="#using-dry-run-mode" title="영구 링크"></a></h2><p>봇이 어떻게 작동하고 전략의 성능이 어떤지 확인하려면 드라이런 모드에서 봇을 시작하는 것이 좋습니다. 드라이런 모드에서는 봇이 실제 돈을 사용하지 않습니다. 대신 거래소에서 거래를 생성하지 않고 라이브 시뮬레이션을 실행합니다.</p><ol><li><code> config.json </code> 구성 파일을 편집합니다. </li><li><code> dry-run </code> 을 <code> true </code> 로 전환하고, 지속성 데이터베이스를 위한 <code> db_url </code> 을 지정합니다. </li></ol><div class="highlight"><pre><code><span class="nt">&quot;dry_run&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="nt">&quot;db_url&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;sqlite:///tradesv3.dryrun.sqlite&quot;</span><span class="p">,</span>
</code></pre></div><ol><li>거래소 API 키와 비밀을 제거합니다(빈 값이나 가짜 자격 증명으로 변경):</li></ol><div class="highlight"><pre><code><span class="nt">&quot;exchange&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;binance&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;key&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;key&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;secret&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;secret&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="err">...</span>
<span class="p">}</span>
</code></pre></div><p>드라이런 모드에서 봇의 성능에 만족하면 프로덕션 모드로 전환할 수 있습니다.</p><div class="admonition note"><p class="admonition-title">참고</p><p>드라이런 모드에서는 시뮬레이션 지갑이 사용 가능하며, 1000의 시작 자본을 가정합니다.</p></div><h3 id="considerations-for-dry-run"> 드라이런에 대한 고려 사항 <a class="headerlink" href="#considerations-for-dry-run" title="영구 링크"></a></h3><ul><li>API 키는 제공할 수도 있고 제공하지 않을 수도 있습니다. 드라이런 모드에서는 계정 상태를 변경하지 않는 읽기 전용 작업만 수행됩니다.</li><li> 지갑( <code> /balance </code> )은 <code> dry_run_wallet </code> 기반으로 시뮬레이션됩니다. </li><li>주문은 시뮬레이션되며, 거래소에 게시되지 않습니다.</li><li>시장가 주문은 주문이 게시되는 순간 주문서 볼륨을 기반으로 체결되며, 최대 5%의 슬리피지가 있습니다.</li><li> 지정가 주문은 정의된 수준에 도달하면 체결되며, <code> unfilledtimeout </code> 설정에 따라 시간 초과됩니다. </li><li>지정가 주문이 가격을 1% 이상 초과하면 시장가 주문으로 변환되며, 일반적인 시장가 주문 규칙에 따라 즉시 체결됩니다(위의 시장가 주문에 대한 점 참조).</li><li><code> stoploss_on_exchange </code> 와 함께 사용하면 손절매 가격이 체결된 것으로 가정됩니다. </li><li>오픈 주문(거래가 아닌, 데이터베이스에 저장된 거래)은 봇이 다시 시작된 후에도 열려 있으며, 오프라인 상태에서 체결되지 않은 것으로 가정됩니다.</li></ul><h2 id="switch-to-production-mode"> 프로덕션 모드로 전환 <a class="headerlink" href="#switch-to-production-mode" title="영구 링크"></a></h2><p>프로덕션 모드에서는 봇이 실제 돈을 사용합니다. 잘못된 전략은 모든 돈을 잃을 수 있으므로 주의하세요. 프로덕션 모드에서 실행할 때는 신중하게 행동하세요.</p><p>프로덕션 모드로 전환할 때, 드라이런 거래가 거래소 돈과 혼동되지 않도록 다른/새로운 데이터베이스를 사용하는 것이 좋습니다.</p><h3 id="setup-your-exchange-account"> 거래소 계정 설정 <a class="headerlink" href="#setup-your-exchange-account" title="영구 링크"></a></h3><p> 거래소 웹사이트에서 API 키(일반적으로 <code> key </code> 와 <code> secret </code> 를 얻으며, 일부 거래소는 추가로 <code> password </code> 를 요구함)를 생성하고, 이를 적절한 필드에 삽입해야 합니다. API 키는 일반적으로 라이브 거래(실제 돈으로 거래, &quot;프로덕션 모드&quot;에서 봇 실행, 거래소에서 실제 주문 실행)에만 필요하며, 드라이런(거래 시뮬레이션) 모드에서 봇을 실행할 때는 필요하지 않습니다. 드라이런 모드에서 봇을 설정할 때는 이러한 필드를 빈 값으로 채울 수 있습니다. </p><h3 id="to-switch-your-bot-in-production-mode"> 봇을 프로덕션 모드로 전환하려면 <a class="headerlink" href="#to-switch-your-bot-in-production-mode" title="영구 링크"></a></h3><p><strong><code> config.json </code> 파일을 편집합니다. </strong></p><p><strong> dry-run을 false로 전환하고, 설정된 경우 데이터베이스 URL을 조정하는 것을 잊지 마세요: </strong></p><div class="highlight"><pre><code><span class="nt">&quot;dry_run&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span>
</code></pre></div><p><strong> 거래소 API 키를 삽입합니다(가짜 API 키로 변경): </strong></p><div class="highlight"><pre><code><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;exchange&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;binance&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="nt">&quot;key&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;af8ddd35195e9dc500b9a6f799f6f5c93d89193b&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="nt">&quot;secret&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;08a9dc6db3d7b53e1acebd9275677f4b0a04f1a5&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="c1">//&quot;password&quot;: &quot;&quot;, // Optional, not needed by all exchanges)</span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">//...</span>
<span class="p">}</span>
</code></pre></div>`,59)),s("p",null,[n[418]||(n[418]=l(" 거래소에 대한 잠재적인 구성 세부 사항을 인식하기 위해 ")),a(t,{to:"exchanges"},{default:p(()=>n[417]||(n[417]=[l(" 거래소 ")])),_:1}),n[419]||(n[419]=l(" 섹션을 읽는 것이 좋습니다. "))]),n[432]||(n[432]=o(`<div class="admonition hint"><p class="admonition-title">비밀을 비밀로 유지</p><p> 비밀을 비밀로 유지하려면 API 키에 대한 두 번째 구성을 사용하는 것이 좋습니다. 위의 스니펫을 새 구성 파일(예: <code> config-private.json </code> )에 사용하고, 설정을 이 파일에 유지하세요. 그런 다음 <code> freqtrade trade --config user_data/config.json --config user_data/config-private.json &lt;...&gt; </code> 로 봇을 시작하여 키를 로드할 수 있습니다. </p><p><strong> 절대 </strong> 개인 구성 파일이나 거래소 키를 누구와도 공유하지 마세요! </p></div><h2 id="using-a-proxy-with-freqtrade"> freqtrade에서 프록시 사용 <a class="headerlink" href="#using-a-proxy-with-freqtrade" title="영구 링크"></a></h2><p> freqtrade에서 프록시를 사용하려면 적절한 값으로 설정된 <code> &quot;HTTP_PROXY&quot; </code> 및 <code> &quot;HTTPS_PROXY&quot; </code> 변수를 사용하여 프록시 설정을 내보내세요. 이렇게 하면 거래소 요청을 제외한 모든 항목(텔레그램, coingecko, ...)에 프록시 설정이 적용됩니다. </p><div class="highlight"><pre><code><span class="nb">export</span><span class="w"> </span><span class="nv">HTTP_PROXY</span><span class="o">=</span><span class="s2">&quot;http://addr:port&quot;</span>
<span class="nb">export</span><span class="w"> </span><span class="nv">HTTPS_PROXY</span><span class="o">=</span><span class="s2">&quot;http://addr:port&quot;</span>
freqtrade
</code></pre></div><h3 id="proxy-exchange-requests"> 프록시 거래소 요청 <a class="headerlink" href="#proxy-exchange-requests" title="영구 링크"></a></h3><p>거래소 연결에 프록시를 사용하려면 프록시를 ccxt 구성의 일부로 정의해야 합니다.</p><div class="highlight"><pre><code><span class="p">{</span><span class="w"> </span>
<span class="w">  </span><span class="nt">&quot;exchange&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;ccxt_config&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;httpsProxy&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;http://addr:port&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;wsProxy&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;http://addr:port&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p> 사용 가능한 프록시 유형에 대한 자세한 내용은 <a href="https://docs.ccxt.com/#/README?id=proxy"> ccxt 프록시 문서 </a> 를 참조하세요. </p><h2 id="next-step"> 다음 단계 <a class="headerlink" href="#next-step" title="영구 링크"></a></h2>`,9)),s("p",null,[n[421]||(n[421]=l(" 이제 ")),n[422]||(n[422]=s("code",null," config.json ",-1)),n[423]||(n[423]=l(" 을 구성했으므로, 다음 단계는 ")),a(t,{to:"bot-usage"},{default:p(()=>n[420]||(n[420]=[l(" 봇 시작 ")])),_:1}),n[424]||(n[424]=l(" 입니다. "))])])}const y=e(i,[["render",b]]);export{y as default};
