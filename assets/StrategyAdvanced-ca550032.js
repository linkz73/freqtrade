import{r as e,o as t,c as o,b as n,d as a,e as c,w as l,a as r}from"./index-f254d819.js";const i={class:"md-content__inner md-typeset"},f={__name:"StrategyAdvanced",setup(d){return(m,s)=>{const p=e("router-link");return t(),o("article",i,[s[8]||(s[8]=n("h1",{id:"advanced-strategies"},[a(" 고급 전략 "),n("a",{class:"headerlink",href:"#advanced-strategies",title:"영구 링크"}," ¶ ")],-1)),n("p",null,[s[2]||(s[2]=a(" 이 페이지는 전략에 사용할 수 있는 몇 가지 고급 개념을 설명합니다. 시작하려면 먼저 ")),c(p,{to:"bot-basics"},{default:l(()=>s[0]||(s[0]=[a(" Freqtrade 기본 ")])),_:1}),s[3]||(s[3]=a(" 및 ")),c(p,{to:"strategy-customization"},{default:l(()=>s[1]||(s[1]=[a(" 전략 커스터마이징 ")])),_:1}),s[4]||(s[4]=a(" 에 설명된 방법을 숙지하십시오. "))]),n("p",null,[s[6]||(s[6]=a(" 여기에 설명된 메서드의 호출 순서는 ")),c(p,{to:"bot-basics"},{default:l(()=>s[5]||(s[5]=[a(" 봇 실행 로직 ")])),_:1}),s[7]||(s[7]=a(" 에서 다룹니다. 이 문서는 사용자 정의 요구에 가장 적합한 메서드를 결정하는 데에도 유용합니다. "))]),s[9]||(s[9]=r(`<div class="admonition note"><p class="admonition-title">참고</p><p> 콜백 메서드는 전략이 이를 사용하는 경우에만 <em> 구현 </em> 해야 합니다. </p></div><div class="admonition tip"><p class="admonition-title">팁</p><p><code> freqtrade new-strategy --strategy MyAwesomeStrategy --template advanced </code> 를 실행하여 모든 사용 가능한 콜백 메서드가 포함된 전략 템플릿으로 시작하십시오. </p></div><h2 id="storing-information-persistent"> 정보 저장 (영구적) <a class="headerlink" href="#storing-information-persistent" title="영구 링크"> ¶ </a></h2><p>Freqtrade는 특정 거래와 관련된 사용자 정의 정보를 데이터베이스에 저장/검색할 수 있도록 허용합니다.</p><p> 거래 객체를 사용하여 <code> trade.set_custom_data(key=&#39;my_key&#39;, value=my_value) </code> 를 통해 정보를 저장하고 <code> trade.get_custom_data(key=&#39;my_key&#39;) </code> 를 통해 검색할 수 있습니다. 각 데이터 항목은 거래 및 사용자 제공 키(유형: <code> string </code> )와 연결됩니다. 이는 거래 객체를 제공하는 콜백에서만 사용할 수 있음을 의미합니다. </p><p>데이터를 데이터베이스에 저장하려면 Freqtrade가 데이터를 직렬화해야 합니다. 이는 데이터를 JSON 형식의 문자열로 변환하여 수행됩니다. Freqtrade는 검색 시 이 작업을 역으로 수행하려고 시도하므로 전략 관점에서는 관련이 없습니다.</p><div class="highlight"><pre><code><span class="kn">from</span><span class="w"> </span><span class="nn">freqtrade.persistence</span><span class="w"> </span><span class="kn">import</span> <span class="n">Trade</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">timedelta</span>

<span class="k">class</span><span class="w"> </span><span class="nc">AwesomeStrategy</span><span class="p">(</span><span class="n">IStrategy</span><span class="p">):</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">bot_loop_start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">trade</span> <span class="ow">in</span> <span class="n">Trade</span><span class="o">.</span><span class="n">get_open_order_trades</span><span class="p">():</span>
            <span class="n">fills</span> <span class="o">=</span> <span class="n">trade</span><span class="o">.</span><span class="n">select_filled_orders</span><span class="p">(</span><span class="n">trade</span><span class="o">.</span><span class="n">entry_side</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">trade</span><span class="o">.</span><span class="n">pair</span> <span class="o">==</span> <span class="s1">&#39;ETH/USDT&#39;</span><span class="p">:</span>
                <span class="n">trade_entry_type</span> <span class="o">=</span> <span class="n">trade</span><span class="o">.</span><span class="n">get_custom_data</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="s1">&#39;entry_type&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">trade_entry_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">trade_entry_type</span> <span class="o">=</span> <span class="s1">&#39;breakout&#39;</span> <span class="k">if</span> <span class="s1">&#39;entry_1&#39;</span> <span class="ow">in</span> <span class="n">trade</span><span class="o">.</span><span class="n">enter_tag</span> <span class="k">else</span> <span class="s1">&#39;dip&#39;</span>
                <span class="k">elif</span> <span class="n">fills</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">trade_entry_type</span> <span class="o">=</span> <span class="s1">&#39;buy_up&#39;</span>
                <span class="n">trade</span><span class="o">.</span><span class="n">set_custom_data</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="s1">&#39;entry_type&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">trade_entry_type</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">bot_loop_start</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">adjust_entry_price</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trade</span><span class="p">:</span> <span class="n">Trade</span><span class="p">,</span> <span class="n">order</span><span class="p">:</span> <span class="n">Order</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">pair</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                           <span class="n">current_time</span><span class="p">:</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">proposed_rate</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">current_order_rate</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                           <span class="n">entry_tag</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">side</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="c1"># Limit orders to use and follow SMA200 as price target for the first 10 minutes since entry trigger for BTC/USDT pair.</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">pair</span> <span class="o">==</span> <span class="s1">&#39;BTC/USDT&#39;</span> 
            <span class="ow">and</span> <span class="n">entry_tag</span> <span class="o">==</span> <span class="s1">&#39;long_sma200&#39;</span> 
            <span class="ow">and</span> <span class="n">side</span> <span class="o">==</span> <span class="s1">&#39;long&#39;</span> 
            <span class="ow">and</span> <span class="p">(</span><span class="n">current_time</span> <span class="o">-</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">minutes</span><span class="o">=</span><span class="mi">10</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">trade</span><span class="o">.</span><span class="n">open_date_utc</span> 
            <span class="ow">and</span> <span class="n">order</span><span class="o">.</span><span class="n">filled</span> <span class="o">==</span> <span class="mf">0.0</span>
        <span class="p">):</span>
            <span class="n">dataframe</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dp</span><span class="o">.</span><span class="n">get_analyzed_dataframe</span><span class="p">(</span><span class="n">pair</span><span class="o">=</span><span class="n">pair</span><span class="p">,</span> <span class="n">timeframe</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">timeframe</span><span class="p">)</span>
            <span class="n">current_candle</span> <span class="o">=</span> <span class="n">dataframe</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="c1"># store information about entry adjustment</span>
            <span class="n">existing_count</span> <span class="o">=</span> <span class="n">trade</span><span class="o">.</span><span class="n">get_custom_data</span><span class="p">(</span><span class="s1">&#39;num_entry_adjustments&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">existing_count</span><span class="p">:</span>
                <span class="n">existing_count</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">existing_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">trade</span><span class="o">.</span><span class="n">set_custom_data</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="s1">&#39;num_entry_adjustments&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">existing_count</span><span class="p">)</span>

            <span class="c1"># adjust order price</span>
            <span class="k">return</span> <span class="n">current_candle</span><span class="p">[</span><span class="s1">&#39;sma_200&#39;</span><span class="p">]</span>

        <span class="c1"># default: maintain existing order</span>
        <span class="k">return</span> <span class="n">current_order_rate</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">custom_exit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pair</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">trade</span><span class="p">:</span> <span class="n">Trade</span><span class="p">,</span> <span class="n">current_time</span><span class="p">:</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">current_rate</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">current_profit</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="n">entry_adjustment_count</span> <span class="o">=</span> <span class="n">trade</span><span class="o">.</span><span class="n">get_custom_data</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="s1">&#39;num_entry_adjustments&#39;</span><span class="p">)</span>
        <span class="n">trade_entry_type</span> <span class="o">=</span> <span class="n">trade</span><span class="o">.</span><span class="n">get_custom_data</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="s1">&#39;entry_type&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">entry_adjustment_count</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">current_profit</span> <span class="o">&gt;</span> <span class="mf">0.01</span> <span class="ow">and</span> <span class="p">(</span><span class="n">current_time</span> <span class="o">-</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">minutes</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">trade</span><span class="o">.</span><span class="n">open_date_utc</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;exit_1&#39;</span>
        <span class="k">else</span>
            <span class="k">if</span> <span class="n">entry_adjustment_count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="k">if</span> <span class="n">current_profit</span> <span class="o">&gt;</span> <span class="mf">0.05</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;exit_2&#39;</span>
            <span class="k">if</span> <span class="n">trade_entry_type</span> <span class="o">==</span> <span class="s1">&#39;breakout&#39;</span> <span class="ow">and</span> <span class="n">current_profit</span> <span class="o">&gt;</span> <span class="mf">0.1</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;exit_3</span>

        <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span>
</code></pre></div><p>위의 예는 간단한 예입니다. 진입 조정과 같은 거래 데이터를 검색하는 더 간단한 방법이 있습니다.</p><div class="admonition note"><p class="admonition-title">참고</p><p> 간단한 데이터 유형 <code> [bool, int, float, str] </code> 을 사용하여 저장해야 하는 데이터를 직렬화할 때 문제가 없도록 하는 것이 좋습니다. 많은 양의 데이터를 저장하면 데이터베이스가 커지고(결과적으로 느려짐) 의도하지 않은 부작용이 발생할 수 있습니다. </p></div><div class="admonition warning"><p class="admonition-title">직렬화할 수 없는 데이터</p><p> 제공된 데이터를 직렬화할 수 없는 경우 경고가 기록되고 지정된 <code> key </code> 에 대한 항목에 <code> None </code> 데이터가 포함됩니다. </p></div><details class="note"><summary>모든 속성</summary><p> 사용자 정의 데이터는 거래 객체(아래에서 <code> trade </code> 로 가정)를 통해 다음 접근자를 갖습니다: </p><ul><li><code> trade.get_custom_data(key=&#39;something&#39;, default=0) </code> - 제공된 유형으로 실제 값을 반환합니다. </li><li><code> trade.get_custom_data_entry(key=&#39;something&#39;) </code> - 메타데이터를 포함한 항목을 반환합니다. 값은 <code> .value </code> 속성을 통해 액세스할 수 있습니다. </li><li><code> trade.set_custom_data(key=&#39;something&#39;, value={&#39;some&#39;: &#39;value&#39;}) </code> - 이 거래에 대한 해당 키를 설정하거나 업데이트합니다. 값은 직렬화 가능해야 하며 저장된 데이터를 상대적으로 작게 유지하는 것이 좋습니다. </li></ul><p>&quot;값&quot;은 설정 및 수신 시 모든 유형일 수 있지만 JSON 직렬화 가능해야 합니다.</p></details><h2 id="storing-information-non-persistent"> 정보 저장 (비영구적) <a class="headerlink" href="#storing-information-non-persistent" title="영구 링크"> ¶ </a></h2><div class="admonition warning"><p class="admonition-title">사용 중단됨</p><p> 이 정보 저장 방법은 사용 중단되었으며 비영구적 저장소 사용을 권장하지 않습니다. <br> 대신 <a href="#storing-information-persistent"> 영구 저장소 </a> 를 사용하십시오. </p><p>따라서 내용이 축소되었습니다.</p></div><details class="abstract"><summary>정보 저장</summary><p>정보 저장은 전략 클래스 내에 새 사전을 생성하여 수행할 수 있습니다.</p><p> 변수 이름은 임의로 선택할 수 있지만 미리 정의된 전략 변수와의 이름 충돌을 피하기 위해 <code> custom_ </code> 접두사를 붙여야 합니다. </p><div class="highlight"><pre><code><span class="k">class</span><span class="w"> </span><span class="nc">AwesomeStrategy</span><span class="p">(</span><span class="n">IStrategy</span><span class="p">):</span>
    <span class="c1"># 사용자 정의 사전 생성</span>
    <span class="n">custom_info</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">populate_indicators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">metadata</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="c1"># 항목이 이미 있는지 확인</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;pair&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_info</span><span class="p">:</span>
            <span class="c1"># 이 쌍에 대한 빈 항목 생성</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">custom_info</span><span class="p">[</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;pair&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="s2">&quot;crosstime&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_info</span><span class="p">[</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;pair&quot;</span><span class="p">]]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">custom_info</span><span class="p">[</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;pair&quot;</span><span class="p">]][</span><span class="s2">&quot;crosstime&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">custom_info</span><span class="p">[</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;pair&quot;</span><span class="p">]][</span><span class="s2">&quot;crosstime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div><div class="admonition warning"><p class="admonition-title">경고</p><p>데이터는 봇 재시작(또는 구성 재로드) 후에도 유지되지 않습니다. 또한 데이터 양이 많아지면 봇이 많은 메모리를 소비하기 시작하고 결국 메모리가 부족하여 충돌할 수 있습니다.</p></div><div class="admonition note"><p class="admonition-title">참고</p><p>데이터가 쌍별로 특정한 경우 사전의 키 중 하나로 쌍을 사용해야 합니다.</p></div></details><h2 id="dataframe-access"> 데이터프레임 접근 <a class="headerlink" href="#dataframe-access" title="영구 링크"> ¶ </a></h2><p>데이터프레임은 데이터 제공자에서 쿼리하여 다양한 전략 함수에서 액세스할 수 있습니다.</p><div class="highlight"><pre><code><span class="kn">from</span><span class="w"> </span><span class="nn">freqtrade.exchange</span><span class="w"> </span><span class="kn">import</span> <span class="n">timeframe_to_prev_date</span>

<span class="k">class</span><span class="w"> </span><span class="nc">AwesomeStrategy</span><span class="p">(</span><span class="n">IStrategy</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">confirm_trade_exit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pair</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">trade</span><span class="p">:</span> <span class="s1">&#39;Trade&#39;</span><span class="p">,</span> <span class="n">order_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                           <span class="n">rate</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">time_in_force</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">exit_reason</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                           <span class="n">current_time</span><span class="p">:</span> <span class="s1">&#39;datetime&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># 쌍 데이터프레임 가져오기.</span>
        <span class="n">dataframe</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dp</span><span class="o">.</span><span class="n">get_analyzed_dataframe</span><span class="p">(</span><span class="n">pair</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeframe</span><span class="p">)</span>

        <span class="c1"># 마지막 사용 가능한 캔들 가져오기. 현재 시간은 현재 완료되지 않은 캔들을 가리키므로 최신 캔들을 찾는 데 사용하지 마십시오.</span>
        <span class="n">last_candle</span> <span class="o">=</span> <span class="n">dataframe</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="c1"># &lt;...&gt;</span>

        <span class="c1"># 드라이/라이브 실행에서는 거래 오픈 날짜가 캔들 오픈 날짜와 일치하지 않으므로 반올림해야 합니다.</span>
        <span class="n">trade_date</span> <span class="o">=</span> <span class="n">timeframe_to_prev_date</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timeframe</span><span class="p">,</span> <span class="n">trade</span><span class="o">.</span><span class="n">open_date_utc</span><span class="p">)</span>
        <span class="c1"># 거래 캔들 찾기.</span>
        <span class="n">trade_candle</span> <span class="o">=</span> <span class="n">dataframe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">trade_date</span><span class="p">]</span>
        <span class="c1"># 거래가 막 열렸기 때문에 거래 캔들이 비어 있을 수 있습니다.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">trade_candle</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="n">trade_candle</span> <span class="o">=</span> <span class="n">trade_candle</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="c1"># &lt;...&gt;</span>
</code></pre></div><div class="admonition warning"><p class="admonition-title">.iloc[-1] 사용</p><p><code> .iloc[-1] </code> 을 사용할 수 있습니다. <code> get_analyzed_dataframe() </code> 는 백테스팅이 볼 수 있는 캔들만 반환하기 때문입니다. 이는 <code> populate_* </code> 메서드에서는 작동하지 않으므로 해당 영역에서 <code> .iloc[] </code> 을 사용하지 마십시오. 또한, 이는 2021.5 버전부터 작동합니다. </p></div><hr><h2 id="enter-tag"> 진입 태그 <a class="headerlink" href="#enter-tag" title="영구 링크"> ¶ </a></h2><p> 전략에 여러 매수 신호가 있는 경우 트리거된 신호에 이름을 지정할 수 있습니다. 그런 다음 <code> custom_exit </code> 에서 매수 신호에 액세스할 수 있습니다. </p><div class="highlight"><pre><code><span class="k">def</span><span class="w"> </span><span class="nf">populate_entry_trend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">metadata</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
    <span class="n">dataframe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
        <span class="p">(</span>
            <span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;rsi&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">35</span><span class="p">)</span> <span class="o">&amp;</span>
            <span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;volume&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">),</span>
        <span class="p">[</span><span class="s1">&#39;enter_long&#39;</span><span class="p">,</span> <span class="s1">&#39;enter_tag&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;buy_signal_rsi&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dataframe</span>

<span class="k">def</span><span class="w"> </span><span class="nf">custom_exit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pair</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">trade</span><span class="p">:</span> <span class="n">Trade</span><span class="p">,</span> <span class="n">current_time</span><span class="p">:</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">current_rate</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                <span class="n">current_profit</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">dataframe</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dp</span><span class="o">.</span><span class="n">get_analyzed_dataframe</span><span class="p">(</span><span class="n">pair</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeframe</span><span class="p">)</span>
    <span class="n">last_candle</span> <span class="o">=</span> <span class="n">dataframe</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">trade</span><span class="o">.</span><span class="n">enter_tag</span> <span class="o">==</span> <span class="s1">&#39;buy_signal_rsi&#39;</span> <span class="ow">and</span> <span class="n">last_candle</span><span class="p">[</span><span class="s1">&#39;rsi&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">80</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;sell_signal_rsi&#39;</span>
    <span class="k">return</span> <span class="kc">None</span>
</code></pre></div><div class="admonition note"><p class="admonition-title">참고</p><p><code> enter_tag </code> 는 100자로 제한되며 나머지 데이터는 잘립니다. </p></div><div class="admonition warning"><p class="admonition-title">경고</p><p><code> enter_tag </code> 열은 롱 및 숏 거래 모두에 사용됩니다. 결과적으로 이 열은 &quot;마지막 쓰기 우선&quot;으로 처리해야 합니다(결국 데이터프레임 열일 뿐입니다). 여러 신호가 충돌하는 상황(또는 다른 조건에 따라 신호가 비활성화되는 경우)에서는 마지막 태그가 적용되어 전략이 이전 태그를 덮어쓰는 결과가 발생할 수 있습니다. 이러한 결과는 전략이 이전 태그를 덮어쓰는 결과로 인해 발생하며, 마지막 태그가 &quot;고정&quot;되고 Freqtrade가 사용할 태그가 됩니다. </p></div><h2 id="exit-tag"> 종료 태그 <a class="headerlink" href="#exit-tag" title="영구 링크"> ¶ </a></h2><p><a href="#enter-tag"> 진입 태그 </a> 와 유사하게 종료 태그도 지정할 수 있습니다. </p><div class="highlight"><pre><code><span class="k">def</span><span class="w"> </span><span class="nf">populate_exit_trend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">metadata</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
    <span class="n">dataframe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
        <span class="p">(</span>
            <span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;rsi&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">70</span><span class="p">)</span> <span class="o">&amp;</span>
            <span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;volume&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">),</span>
        <span class="p">[</span><span class="s1">&#39;exit_long&#39;</span><span class="p">,</span> <span class="s1">&#39;exit_tag&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;exit_rsi&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dataframe</span>
</code></pre></div><p>제공된 종료 태그는 매도 이유로 사용되며 백테스트 결과에 그렇게 표시됩니다.</p><div class="admonition note"><p class="admonition-title">참고</p><p><code> exit_reason </code> 은 100자로 제한되며 나머지 데이터는 잘립니다. </p></div><h2 id="strategy-version"> 전략 버전 <a class="headerlink" href="#strategy-version" title="영구 링크"> ¶ </a></h2><p>&quot;version&quot; 메서드를 사용하여 사용자 정의 전략 버전을 구현하고 이 전략에 원하는 버전을 반환할 수 있습니다.</p><div class="highlight"><pre><code><span class="k">def</span><span class="w"> </span><span class="nf">version</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    전략 버전을 반환합니다.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="s2">&quot;1.1&quot;</span>
</code></pre></div><div class="admonition note"><p class="admonition-title">참고</p><p>Freqtrade는 전략의 이전 버전을 유지하지 않으므로 적절한 버전 관리를 구현해야 합니다(예: git 저장소). 따라서 사용자가 이전 버전의 전략으로 롤백할 수 있어야 합니다.</p></div><h2 id="derived-strategies"> 파생 전략 <a class="headerlink" href="#derived-strategies" title="영구 링크"> ¶ </a></h2><p>전략은 다른 전략에서 파생될 수 있습니다. 이를 통해 사용자 정의 전략 코드를 중복하지 않고도 주요 전략의 일부를 재정의할 수 있습니다:</p><div class="highlight"><span class="filename"> user_data/strategies/myawesomestrategy.py </span><pre><code><span class="k">class</span><span class="w"> </span><span class="nc">MyAwesomeStrategy</span><span class="p">(</span><span class="n">IStrategy</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="n">stoploss</span> <span class="o">=</span> <span class="mf">0.13</span>
    <span class="n">trailing_stop</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># 모든 다른 속성과 메서드는 여기에 있으며</span>
    <span class="c1"># 사용자 정의 전략에 있어야 합니다...</span>
    <span class="o">...</span>
</code></pre></div><div class="highlight"><span class="filename"> user_data/strategies/MyAwesomeStrategy2.py </span><pre><code><span class="kn">from</span><span class="w"> </span><span class="nn">myawesomestrategy</span><span class="w"> </span><span class="kn">import</span> <span class="n">MyAwesomeStrategy</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MyAwesomeStrategy2</span><span class="p">(</span><span class="n">MyAwesomeStrategy</span><span class="p">):</span>
    <span class="c1"># 무언가 재정의</span>
    <span class="n">stoploss</span> <span class="o">=</span> <span class="mf">0.08</span>
    <span class="n">trailing_stop</span> <span class="o">=</span> <span class="kc">True</span>
</code></pre></div><p>속성과 메서드 모두 재정의할 수 있으며 원래 전략의 동작을 필요한 방식으로 변경할 수 있습니다.</p><p>하위 클래스를 동일한 파일에 유지하는 것은 기술적으로 가능하지만 하이퍼옵트 매개변수 파일과 관련된 몇 가지 문제가 발생할 수 있으므로 별도의 전략 파일을 사용하고 위에 표시된 대로 상위 전략을 가져오는 것이 좋습니다.</p><h2 id="embedding-strategies"> 전략 임베딩 <a class="headerlink" href="#embedding-strategies" title="영구 링크"> ¶ </a></h2><p>Freqtrade는 구성 파일에 전략을 쉽게 임베드할 수 있는 방법을 제공합니다. 이는 BASE64 인코딩을 사용하고 선택한 구성 파일의 전략 구성 필드에 이 문자열을 제공하여 수행됩니다.</p><h3 id="encoding-a-string-as-base64"> 문자열을 BASE64로 인코딩 <a class="headerlink" href="#encoding-a-string-as-base64" title="영구 링크"> ¶ </a></h3><p>다음은 Python에서 BASE64 문자열을 생성하는 간단한 예입니다.</p><div class="highlight"><pre><code><span class="kn">from</span><span class="w"> </span><span class="nn">base64</span><span class="w"> </span><span class="kn">import</span> <span class="n">urlsafe_b64encode</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">content</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="n">content</span> <span class="o">=</span> <span class="n">urlsafe_b64encode</span><span class="p">(</span><span class="n">content</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
</code></pre></div><p>변수 &#39;content&#39;에는 BASE64로 인코딩된 전략 파일이 포함됩니다. 이제 다음과 같이 구성 파일에 설정할 수 있습니다.</p><div class="highlight"><pre><code><span class="nt">&quot;strategy&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;NameOfStrategy:BASE64String&quot;</span>
</code></pre></div><p>&#39;NameOfStrategy&#39;가 전략 이름과 동일한지 확인하십시오!</p><h2 id="performance-warning"> 성능 경고 <a class="headerlink" href="#performance-warning" title="영구 링크"> ¶ </a></h2><p>전략을 실행할 때 때때로 로그에서 다음과 같은 메시지를 볼 수 있습니다.</p><blockquote><p>PerformanceWarning: DataFrame is highly fragmented.</p></blockquote><p> 이는 <a href="https://github.com/pandas-dev/pandas"><code> pandas </code></a> 의 경고이며 경고가 계속해서 말하듯이: <code> pd.concat(axis=1) </code> 을 사용하십시오. 이는 주로 하이퍼옵트(지표 최적화 시)에서만 성능에 약간의 영향을 미칠 수 있습니다. </p><p>예를 들어:</p><div class="highlight"><pre><code><span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">buy_ema_short</span><span class="o">.</span><span class="n">range</span><span class="p">:</span>
    <span class="n">dataframe</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;ema_short_</span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">EMA</span><span class="p">(</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">timeperiod</span><span class="o">=</span><span class="n">val</span><span class="p">)</span>
</code></pre></div><p>다음과 같이 다시 작성해야 합니다.</p><div class="highlight"><pre><code><span class="n">frames</span> <span class="o">=</span> <span class="p">[</span><span class="n">dataframe</span><span class="p">]</span>
<span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">buy_ema_short</span><span class="o">.</span><span class="n">range</span><span class="p">:</span>
    <span class="n">frames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">DataFrame</span><span class="p">({</span>
        <span class="sa">f</span><span class="s1">&#39;ema_short_</span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">:</span> <span class="n">ta</span><span class="o">.</span><span class="n">EMA</span><span class="p">(</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">timeperiod</span><span class="o">=</span><span class="n">val</span><span class="p">)</span>
    <span class="p">}))</span>

<span class="c1"># 모든 데이터프레임을 결합하고 원래 데이터프레임 열을 다시 할당합니다.</span>
<span class="n">dataframe</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div><p> Freqtrade는 <code> populate_indicators() </code> 메서드 바로 후에 데이터프레임에서 <code> dataframe.copy() </code> 를 실행하여 이를 방지하므로 성능에 미치는 영향은 거의 없거나 전혀 없을 것입니다. </p>`,56))])}}};export{f as default};
