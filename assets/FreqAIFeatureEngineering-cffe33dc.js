import{r as o,o as d,c as i,a as p,b as n,d as a,e as l,w as c,u as t}from"./index-ff969378.js";const r="/assets/freqai_weight-factor-e9a6175a.jpg",u="/assets/freqai_DI-00563bb2.jpg",m="/assets/freqai_dbscan-62bae1e8.jpg";const f={class:"md-content__inner md-typeset"},h=["src"],q={class:"admonition note"},_=["src"],g=["src"],v={__name:"FreqAIFeatureEngineering",setup(w){return(b,s)=>{const e=o("router-link");return d(),i("article",f,[s[18]||(s[18]=p(`<h1 id="feature-engineering"> 특징 엔지니어링 <a class="headerlink" href="#feature-engineering" title="영구 링크"> ¶ </a></h1><h2 id="defining-the-features"> 특징 정의하기 <a class="headerlink" href="#defining-the-features" title="영구 링크"> ¶ </a></h2><p>낮은 수준의 특징 엔지니어링은 사용자 전략 내의 <code>feature_engineering_*</code> 함수 집합에서 수행됩니다. 이 함수들은 <code>RSI</code>, <code>MFI</code>, <code>EMA</code>, <code>SMA</code>, 시간, 거래량 등과 같은 <code>기본 특징</code>을 설정합니다. 기본 특징은 사용자 정의 지표일 수도 있고, 기술 분석 라이브러리에서 가져올 수도 있습니다. FreqAI는 대규모 특징 엔지니어링을 간소화하기 위한 함수 집합을 제공합니다:</p><table><thead><tr><th>Function</th><th>Description</th></tr></thead><tbody><tr><td><code>feature_engineering_expand_all()</code></td><td>이 선택적 함수는 설정에서 정의된 <code>indicator_periods_candles</code>, <code>include_timeframes</code>, <code>include_shifted_candles</code>, <code>include_corr_pairs</code>에 따라 정의된 특징을 자동으로 확장합니다.</td></tr><tr><td><code>feature_engineering_expand_basic()</code></td><td>이 선택적 함수는 설정에서 정의된 <code>include_timeframes</code>, <code>include_shifted_candles</code>, <code>include_corr_pairs</code>에 따라 정의된 특징을 자동으로 확장합니다. 참고: 이 함수는 <code>indicator_periods_candles</code>에 대해 확장하지 <em>않습니다</em>.</td></tr><tr><td><code>feature_engineering_standard()</code></td><td>이 선택적 함수는 기본 시간 프레임의 데이터프레임과 함께 한 번 호출됩니다. 이는 마지막으로 호출되는 함수이므로, 이 함수에 입력되는 데이터프레임에는 다른 <code>feature_engineering_expand</code> 함수들에 의해 생성된 기본 자산의 모든 특징과 열이 포함됩니다. 이 함수는 사용자 정의 고급 특징 추출(예: tsfresh)을 수행하기에 좋은 장소입니다. 또한 자동 확장이 필요하지 않은 특징(예: 요일)을 정의하기에도 적합합니다.</td></tr><tr><td><code>set_freqai_targets()</code></td><td>모델의 타겟을 설정하기 위한 필수 함수입니다. 모든 타겟은 FreqAI 내부에서 인식되도록 <code>&amp;</code>로 시작해야 합니다.</td></tr></tbody></table><p>한편, 고수준 특징 엔지니어링은 FreqAI 설정의 <code>&quot;feature_parameters&quot;:{}</code> 내에서 처리됩니다. 이 파일 내에서 &quot;상관된 쌍 포함&quot; 또는 &quot;정보성 시간 프레임 포함&quot; 또는 심지어 &quot;최근 캔들 포함&quot;과 같은 <code>base_features</code> 위에 대규모 특징 확장을 결정할 수 있습니다.</p><p>특징 정의가 올바른 규칙을 따르도록 하기 위해 소스에서 제공된 예제 전략( <code>templates/FreqaiExampleStrategy.py</code> 에서 찾을 수 있음)의 <code>feature_engineering_*</code> 템플릿 함수부터 시작하는 것이 좋습니다. 다음은 전략에서 지표와 레이블을 설정하는 방법의 예입니다:</p><div class="highlight"><pre><code>    <span class="k">def</span><span class="w"> </span><span class="nf">feature_engineering_expand_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Only functional with FreqAI enabled strategies*</span>
<span class="sd">        This function will automatically expand the defined features on the config defined</span>
<span class="sd">        \`indicator_periods_candles\`, \`include_timeframes\`, \`include_shifted_candles\`, and</span>
<span class="sd">        \`include_corr_pairs\`. In other words, a single feature defined in this function</span>
<span class="sd">        will automatically expand to a total of</span>
<span class="sd">        \`indicator_periods_candles\` * \`include_timeframes\` * \`include_shifted_candles\` *</span>
<span class="sd">        \`include_corr_pairs\` numbers of features added to the model.</span>

<span class="sd">        All features must be prepended with \`%\` to be recognized by FreqAI internals.</span>

<span class="sd">        Access metadata such as the current pair/timeframe/period with:</span>

<span class="sd">        \`metadata[&quot;pair&quot;]\` \`metadata[&quot;tf&quot;]\`  \`metadata[&quot;period&quot;]\`</span>

<span class="sd">        :param df: strategy dataframe which will receive the features</span>
<span class="sd">        :param period: period of the indicator - usage example:</span>
<span class="sd">        :param metadata: metadata of current pair</span>
<span class="sd">        dataframe[&quot;%-ema-period&quot;] = ta.EMA(dataframe, timeperiod=period)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">%-r</span><span class="s2">si-period&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">RSI</span><span class="p">(</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">timeperiod</span><span class="o">=</span><span class="n">period</span><span class="p">)</span>
        <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;%-mfi-period&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">MFI</span><span class="p">(</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">timeperiod</span><span class="o">=</span><span class="n">period</span><span class="p">)</span>
        <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">%-a</span><span class="s2">dx-period&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">ADX</span><span class="p">(</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">timeperiod</span><span class="o">=</span><span class="n">period</span><span class="p">)</span>
        <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">%-s</span><span class="s2">ma-period&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">SMA</span><span class="p">(</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">timeperiod</span><span class="o">=</span><span class="n">period</span><span class="p">)</span>
        <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">%-e</span><span class="s2">ma-period&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">EMA</span><span class="p">(</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">timeperiod</span><span class="o">=</span><span class="n">period</span><span class="p">)</span>

        <span class="n">bollinger</span> <span class="o">=</span> <span class="n">qtpylib</span><span class="o">.</span><span class="n">bollinger_bands</span><span class="p">(</span>
            <span class="n">qtpylib</span><span class="o">.</span><span class="n">typical_price</span><span class="p">(</span><span class="n">dataframe</span><span class="p">),</span> <span class="n">window</span><span class="o">=</span><span class="n">period</span><span class="p">,</span> <span class="n">stds</span><span class="o">=</span><span class="mf">2.2</span>
        <span class="p">)</span>
        <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;bb_lowerband-period&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bollinger</span><span class="p">[</span><span class="s2">&quot;lower&quot;</span><span class="p">]</span>
        <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;bb_middleband-period&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bollinger</span><span class="p">[</span><span class="s2">&quot;mid&quot;</span><span class="p">]</span>
        <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;bb_upperband-period&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bollinger</span><span class="p">[</span><span class="s2">&quot;upper&quot;</span><span class="p">]</span>

        <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">%-bb_width-period&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;bb_upperband-period&quot;</span><span class="p">]</span>
            <span class="o">-</span> <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;bb_lowerband-period&quot;</span><span class="p">]</span>
        <span class="p">)</span> <span class="o">/</span> <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;bb_middleband-period&quot;</span><span class="p">]</span>
        <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">%-c</span><span class="s2">lose-bb_lower-period&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;close&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;bb_lowerband-period&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">%-r</span><span class="s2">oc-period&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">ROC</span><span class="p">(</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">timeperiod</span><span class="o">=</span><span class="n">period</span><span class="p">)</span>

        <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">%-r</span><span class="s2">elative_volume-period&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;volume&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;volume&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="n">period</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">dataframe</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">feature_engineering_expand_basic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Only functional with FreqAI enabled strategies*</span>
<span class="sd">        This function will automatically expand the defined features on the config defined</span>
<span class="sd">        \`include_timeframes\`, \`include_shifted_candles\`, and \`include_corr_pairs\`.</span>
<span class="sd">        In other words, a single feature defined in this function</span>
<span class="sd">        will automatically expand to a total of</span>
<span class="sd">        \`include_timeframes\` * \`include_shifted_candles\` * \`include_corr_pairs\`</span>
<span class="sd">        numbers of features added to the model.</span>

<span class="sd">        Features defined here will *not* be automatically duplicated on user defined</span>
<span class="sd">        \`indicator_periods_candles\`</span>

<span class="sd">        Access metadata such as the current pair/timeframe with:</span>

<span class="sd">        \`metadata[&quot;pair&quot;]\` \`metadata[&quot;tf&quot;]\`</span>

<span class="sd">        All features must be prepended with \`%\` to be recognized by FreqAI internals.</span>

<span class="sd">        :param df: strategy dataframe which will receive the features</span>
<span class="sd">        :param metadata: metadata of current pair</span>
<span class="sd">        dataframe[&quot;%-pct-change&quot;] = dataframe[&quot;close&quot;].pct_change()</span>
<span class="sd">        dataframe[&quot;%-ema-200&quot;] = ta.EMA(dataframe, timeperiod=200)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;%-pct-change&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;close&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">pct_change</span><span class="p">()</span>
        <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">%-r</span><span class="s2">aw_volume&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;volume&quot;</span><span class="p">]</span>
        <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">%-r</span><span class="s2">aw_price&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;close&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">dataframe</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">feature_engineering_standard</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Only functional with FreqAI enabled strategies*</span>
<span class="sd">        This optional function will be called once with the dataframe of the base timeframe.</span>
<span class="sd">        This is the final function to be called, which means that the dataframe entering this</span>
<span class="sd">        function will contain all the features and columns created by all other</span>
<span class="sd">        freqai_feature_engineering_* functions.</span>

<span class="sd">        This function is a good place to do custom exotic feature extractions (e.g. tsfresh).</span>
<span class="sd">        This function is a good place for any feature that should not be auto-expanded upon</span>
<span class="sd">        (e.g. day of the week).</span>

<span class="sd">        Access metadata such as the current pair with:</span>

<span class="sd">        \`metadata[&quot;pair&quot;]\`</span>

<span class="sd">        All features must be prepended with \`%\` to be recognized by FreqAI internals.</span>

<span class="sd">        :param df: strategy dataframe which will receive the features</span>
<span class="sd">        :param metadata: metadata of current pair</span>
<span class="sd">        usage example: dataframe[&quot;%-day_of_week&quot;] = (dataframe[&quot;date&quot;].dt.dayofweek + 1) / 7</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">%-d</span><span class="s2">ay_of_week&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;date&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">dayofweek</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">7</span>
        <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">%-ho</span><span class="s2">ur_of_day&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;date&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">hour</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">25</span>
        <span class="k">return</span> <span class="n">dataframe</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">set_freqai_targets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Only functional with FreqAI enabled strategies*</span>
<span class="sd">        Required function to set the targets for the model.</span>
<span class="sd">        All targets must be prepended with \`&amp;\` to be recognized by the FreqAI internals.</span>

<span class="sd">        Access metadata such as the current pair with:</span>

<span class="sd">        \`metadata[&quot;pair&quot;]\`</span>

<span class="sd">        :param df: strategy dataframe which will receive the targets</span>
<span class="sd">        :param metadata: metadata of current pair</span>
<span class="sd">        usage example: dataframe[&quot;&amp;-target&quot;] = dataframe[&quot;close&quot;].shift(-1) / dataframe[&quot;close&quot;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;&amp;-s_close&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;close&quot;</span><span class="p">]</span>
            <span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">freqai_info</span><span class="p">[</span><span class="s2">&quot;feature_parameters&quot;</span><span class="p">][</span><span class="s2">&quot;label_period_candles&quot;</span><span class="p">])</span>
            <span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">freqai_info</span><span class="p">[</span><span class="s2">&quot;feature_parameters&quot;</span><span class="p">][</span><span class="s2">&quot;label_period_candles&quot;</span><span class="p">])</span>
            <span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="o">/</span> <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;close&quot;</span><span class="p">]</span>
            <span class="o">-</span> <span class="mi">1</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">dataframe</span>
</code></pre></div><p> In the presented example, the user does not wish to pass the <code> bb_lowerband </code> as a feature to the model, and has therefore not prepended it with <code> % </code> . The user does, however, wish to pass <code> bb_width </code> to the model for training/prediction and has therefore prepended it with <code> % </code> . </p><p> After having defined the <code> base features </code> , the next step is to expand upon them using the powerful <code> feature_parameters </code> in the configuration file: </p><div class="highlight"><pre><code><span class="w">    </span><span class="nt">&quot;freqai&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">//...</span>
<span class="w">        </span><span class="nt">&quot;feature_parameters&quot;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nt">&quot;include_timeframes&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;5m&quot;</span><span class="p">,</span><span class="s2">&quot;15m&quot;</span><span class="p">,</span><span class="s2">&quot;4h&quot;</span><span class="p">],</span>
<span class="w">            </span><span class="nt">&quot;include_corr_pairlist&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">                </span><span class="s2">&quot;ETH/USD&quot;</span><span class="p">,</span>
<span class="w">                </span><span class="s2">&quot;LINK/USD&quot;</span><span class="p">,</span>
<span class="w">                </span><span class="s2">&quot;BNB/USD&quot;</span>
<span class="w">            </span><span class="p">],</span>
<span class="w">            </span><span class="nt">&quot;label_period_candles&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">24</span><span class="p">,</span>
<span class="w">            </span><span class="nt">&quot;include_shifted_candles&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">            </span><span class="nt">&quot;indicator_periods_candles&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">]</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="c1">//...</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div><p> The <code> include_timeframes </code> in the config above are the timeframes ( <code> tf </code> ) of each call to <code> feature_engineering_expand_*() </code> in the strategy. In the presented case, the user is asking for the <code> 5m </code> , <code> 15m </code> , and <code> 4h </code> timeframes of the <code> rsi </code> , <code> mfi </code> , <code> roc </code> , and <code> bb_width </code> to be included in the feature set. </p><p> You can ask for each of the defined features to be included also for informative pairs using the <code> include_corr_pairlist </code> . This means that the feature set will include all the features from <code> feature_engineering_expand_*() </code> on all the <code> include_timeframes </code> for each of the correlated pairs defined in the config ( <code> ETH/USD </code> , <code> LINK/USD </code> , and <code> BNB/USD </code> in the presented example). </p><p><code> include_shifted_candles </code> indicates the number of previous candles to include in the feature set. For example, <code> include_shifted_candles: 2 </code> tells FreqAI to include the past 2 candles for each of the features in the feature set. </p><p> In total, the number of features the user of the presented example strategy has created is: length of <code> include_timeframes </code> * no. features in <code> feature_engineering_expand_*() </code> * length of <code> include_corr_pairlist </code> * no. <code> include_shifted_candles </code> * length of <code> indicator_periods_candles </code><span class="arithmatex"> \\(= 3 * 3 * 3 * 2 * 2 = 108\\) </span> . </p><p> !!! note &quot;Learn more about creative feature engineering&quot; Check out our <a href="https://emergentmethods.medium.com/freqai-from-price-to-prediction-6fadac18b665"> medium article </a> geared toward helping users learn how to creatively engineer features. </p><h3 id="gain-finer-control-over-feature_engineering_-functions-with-metadata"> Gain finer control over <code> feature_engineering_* </code> functions with <code> metadata </code><a class="headerlink" href="#gain-finer-control-over-feature_engineering_-functions-with-metadata" title="Permanent link"> ¶ </a></h3><p> All <code> feature_engineering_* </code> 및 <code> set_freqai_targets() </code> 함수는 <code> metadata </code> 사전을 전달받아 FreqAI가 특징 빌딩을 자동화하는 <code> pair </code> , <code> tf </code> (시간 프레임), 및 <code> period </code> 에 대한 정보를 포함합니다. 따라서 사용자는 <code> feature_engineering_* </code> 함수 내에서 <code> metadata </code> 를 사용하여 특정 시간 프레임, 기간, 쌍 등에 대한 특징을 차단/예약하는 기준으로 사용할 수 있습니다. </p><div class="highlight"><pre><code><span class="k">def</span><span class="w"> </span><span class="nf">feature_engineering_expand_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;tf&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;1h&quot;</span><span class="p">:</span>
        <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">%-r</span><span class="s2">oc-period&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">ROC</span><span class="p">(</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">timeperiod</span><span class="o">=</span><span class="n">period</span><span class="p">)</span>
</code></pre></div><p> 이렇게 하면 <code> ta.ROC() </code> 가 <code> &quot;1h&quot; </code> 이외의 시간 프레임에 추가되지 않도록 차단됩니다. </p><h3 id="returning-additional-info-from-training"> 훈련에서 추가 정보 반환 <a class="headerlink" href="#returning-additional-info-from-training" title="영구 링크"> ¶ </a></h3><p> 중요한 메트릭은 사용자 정의 예측 모델 클래스 내에서 <code> dk.data[&#39;extra_returns_per_train&#39;][&#39;my_new_value&#39;] = XYZ </code> 에 할당하여 각 모델 훈련이 끝날 때 전략에 반환될 수 있습니다. </p>`,21)),n("p",null,[s[1]||(s[1]=a(" FreqAI는 이 사전에 할당된 ")),s[2]||(s[2]=n("code",null," my_new_value ",-1)),s[3]||(s[3]=a(" 를 가져와 전략에 반환되는 데이터 프레임에 맞게 확장합니다. 그런 다음 ")),s[4]||(s[4]=n("code",null," dataframe['my_new_value'] ",-1)),s[5]||(s[5]=a(" 를 통해 전략에서 반환된 메트릭을 사용할 수 있습니다. FreqAI에서 반환 값을 사용하는 예는 ")),s[6]||(s[6]=n("code",null," &*_mean ",-1)),s[7]||(s[7]=a(" 및 ")),s[8]||(s[8]=n("code",null," &*_std ",-1)),s[9]||(s[9]=a(" 값을 사용하여 ")),l(e,{to:"freqai-configuration"},{default:c(()=>s[0]||(s[0]=[a(" 동적 목표 임계값을 생성 ")])),_:1}),s[10]||(s[10]=a(" 하는 것입니다. "))]),s[19]||(s[19]=p(`<p>또 다른 예로, 사용자가 거래 데이터베이스의 실시간 메트릭을 사용하려는 경우는 다음과 같습니다:</p><div class="highlight"><pre><code><span class="w">    </span><span class="nt">&quot;freqai&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nt">&quot;extra_returns_per_train&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="nt">&quot;total_profit&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">4</span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div><p>표준 사전을 구성에 설정하여 FreqAI가 적절한 데이터 프레임 모양을 반환할 수 있도록 해야 합니다. 이러한 값은 예측 모델에 의해 덮어쓰여질 가능성이 높지만, 모델이 아직 설정하지 않았거나 기본 초기 값이 필요한 경우 사전 설정된 값이 반환됩니다.</p><h3 id="weighting-features-for-temporal-importance"> 시간적 중요성을 위한 특징 가중치 부여 <a class="headerlink" href="#weighting-features-for-temporal-importance" title="영구 링크"> ¶ </a></h3><p> FreqAI는 최근 데이터를 과거 데이터보다 더 강하게 가중치 부여하기 위해 <code> weight_factor </code> 를 설정할 수 있습니다: </p><div class="arithmatex">\\[ W_i = \\exp(\\frac{-i}{\\alpha*n}) \\]</div><p> 여기서 <span class="arithmatex"> \\(W_i\\) </span> 는 총 <span class="arithmatex"> \\(n\\) </span> 데이터 포인트 집합에서 데이터 포인트 <span class="arithmatex"> \\(i\\) </span> 의 가중치입니다. 아래는 다양한 가중치 계수를 데이터 포인트에 적용한 결과를 보여주는 그림입니다. </p>`,7)),n("img",{alt:"가중치 계수",src:t(r)},null,8,h),s[20]||(s[20]=p('<h2 id="building-the-data-pipeline"> 데이터 파이프라인 구축 <a class="headerlink" href="#building-the-data-pipeline" title="영구 링크"> ¶ </a></h2><p> 기본적으로 FreqAI는 사용자 구성 설정을 기반으로 동적 파이프라인을 구축합니다. 기본 설정은 다양한 방법에 맞게 설계된 견고한 설정입니다. 이 두 단계는 <code> MinMaxScaler(-1,1) </code> 와 <code> VarianceThreshold </code> 로, 0 분산을 가진 열을 제거합니다. 사용자는 더 많은 구성 매개변수를 통해 다른 단계를 활성화할 수 있습니다. 예를 들어, 사용자가 <code> use_SVM_to_remove_outliers: true </code> 를 <code> freqai </code> 구성에 추가하면 FreqAI는 자동으로 파이프라인에 <a href="#identifying-outliers-using-a-support-vector-machine-svm"><code> SVMOutlierExtractor </code></a> 를 추가합니다. 마찬가지로 사용자는 <code> principal_component_analysis: true </code> 를 <code> freqai </code> 구성에 추가하여 PCA를 활성화할 수 있습니다. <a href="#identifying-outliers-with-the-dissimilarity-index-di"> DissimilarityIndex </a> 는 <code> DI_threshold: 1 </code> 로 활성화됩니다. 마지막으로, 데이터에 노이즈를 추가할 수도 있습니다 <code> noise_standard_deviation: 0.1 </code> . 마지막으로 사용자는 <a href="#identifying-outliers-with-dbscan"> DBSCAN </a> 이상치 제거를 <code> use_DBSCAN_to_remove_outliers: true </code> 로 추가할 수 있습니다. </p>',2)),n("div",q,[s[14]||(s[14]=n("p",{class:"admonition-title"},"추가 정보",-1)),n("p",null,[s[12]||(s[12]=a(" 이러한 매개변수에 대한 자세한 내용은 ")),l(e,{to:"freqai-parameter-table"},{default:c(()=>s[11]||(s[11]=[a(" 매개변수 표 ")])),_:1}),s[13]||(s[13]=a(" 를 참조하십시오. "))])]),s[21]||(s[21]=p(`<h3 id="customizing-the-pipeline"> 파이프라인 사용자 정의 <a class="headerlink" href="#customizing-the-pipeline" title="영구 링크"> ¶ </a></h3><p> 사용자는 자신의 필요에 맞게 데이터 파이프라인을 사용자 정의하도록 권장됩니다. 이는 <code> IFreqaiModel </code><code> train() </code> 함수 내에서 <code> dk.feature_pipeline </code> 을 원하는 <code> Pipeline </code> 객체로 설정하거나, 또는 <code> train() </code> 함수를 건드리지 않으려면 <code> IFreqaiModel </code> 의 <code> define_data_pipeline </code> / <code> define_label_pipeline </code> 함수를 재정의하여 수행할 수 있습니다: </p><div class="admonition note"><p class="admonition-title">추가 정보</p><p> FreqAI는 SKlearn 파이프라인 API를 따르지만, X, y 및 sample_weight 벡터 포인트 제거, 특징 제거, 특징 이름 추적 등을 추가하는 <a href="https://github.com/emergentmethods/datasieve"><code> DataSieve </code></a> 파이프라인을 사용합니다. </p></div><div class="highlight"><pre><code><span class="kn">from</span><span class="w"> </span><span class="nn">datasieve.transforms</span><span class="w"> </span><span class="kn">import</span> <span class="n">SKLearnWrapper</span><span class="p">,</span> <span class="n">DissimilarityIndex</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datasieve.pipeline</span><span class="w"> </span><span class="kn">import</span> <span class="n">Pipeline</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.preprocessing</span><span class="w"> </span><span class="kn">import</span> <span class="n">QuantileTransformer</span><span class="p">,</span> <span class="n">StandardScaler</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">freqai.base_models</span><span class="w"> </span><span class="kn">import</span> <span class="n">BaseRegressionModel</span>


<span class="k">class</span><span class="w"> </span><span class="nc">MyFreqaiModel</span><span class="p">(</span><span class="n">BaseRegressionModel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Some cool custom model</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dictionary</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">dk</span><span class="p">:</span> <span class="n">FreqaiDataKitchen</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        My custom fit function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">cool_model</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">model</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">define_data_pipeline</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Pipeline</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        User defines their custom feature pipeline here (if they wish)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">feature_pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">([</span>
            <span class="p">(</span><span class="s1">&#39;qt&#39;</span><span class="p">,</span> <span class="n">SKLearnWrapper</span><span class="p">(</span><span class="n">QuantileTransformer</span><span class="p">(</span><span class="n">output_distribution</span><span class="o">=</span><span class="s1">&#39;normal&#39;</span><span class="p">))),</span>
            <span class="p">(</span><span class="s1">&#39;di&#39;</span><span class="p">,</span> <span class="n">ds</span><span class="o">.</span><span class="n">DissimilarityIndex</span><span class="p">(</span><span class="n">di_threshold</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="p">])</span>

        <span class="k">return</span> <span class="n">feature_pipeline</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">define_label_pipeline</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Pipeline</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        User defines their custom label pipeline here (if they wish)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">label_pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">([</span>
            <span class="p">(</span><span class="s1">&#39;qt&#39;</span><span class="p">,</span> <span class="n">SKLearnWrapper</span><span class="p">(</span><span class="n">StandardScaler</span><span class="p">())),</span>
        <span class="p">])</span>

        <span class="k">return</span> <span class="n">label_pipeline</span>
</code></pre></div><p> 여기서 사용자는 훈련 및 예측 중에 특징 세트에 사용할 정확한 파이프라인을 정의합니다. 위에서 보여준 것처럼 <code> SKLearnWrapper </code> 클래스로 래핑하여 <em> 대부분의 </em> SKLearn 변환 단계를 사용할 수 있습니다. 또한 <a href="https://github.com/emergentmethods/datasieve"><code> DataSieve </code> 라이브러리 </a> 에서 사용할 수 있는 모든 변환을 사용할 수 있습니다. </p><p><code> BaseTransform </code> 에서 상속받아 <code> fit() </code> , <code> transform() </code> 및 <code> inverse_transform() </code> 메서드를 구현하여 자신의 변환을 쉽게 추가할 수 있습니다: </p><div class="highlight"><pre><code><span class="kn">from</span><span class="w"> </span><span class="nn">datasieve.transforms.base_transform</span><span class="w"> </span><span class="kn">import</span> <span class="n">BaseTransform</span>
<span class="c1"># import whatever else you need</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MyCoolTransform</span><span class="p">(</span><span class="n">BaseTransform</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param1</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;param1&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">feature_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># do something with X, y, sample_weight, or/and feature_list</span>
        <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_weight</span><span class="p">,</span> <span class="n">feature_list</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">feature_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">outlier_check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># do something with X, y, sample_weight, or/and feature_list</span>
        <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_weight</span><span class="p">,</span> <span class="n">feature_list</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">inverse_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">feature_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># do/dont do something with X, y, sample_weight, or/and feature_list</span>
        <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_weight</span><span class="p">,</span> <span class="n">feature_list</span>
</code></pre></div><div class="admonition note"><p class="admonition-title">힌트</p><p> 이 사용자 정의 클래스를 <code> IFreqaiModel </code> 과 동일한 파일에 정의할 수 있습니다. </p></div><h3 id="migrating-a-custom-ifreqaimodel-to-the-new-pipeline"> 새로운 파이프라인으로 사용자 정의 <code> IFreqaiModel </code> 마이그레이션 <a class="headerlink" href="#migrating-a-custom-ifreqaimodel-to-the-new-pipeline" title="영구 링크"> ¶ </a></h3><p> 사용자 정의 <code> IFreqaiModel </code> 을 생성하고 사용자 정의 <code> train() </code> / <code> predict() </code> 함수를 사용하면서 <code> data_cleaning_train/predict() </code> 에 의존하는 경우, 새로운 파이프라인으로 마이그레이션해야 합니다. 모델이 <code> data_cleaning_train/predict() </code> 에 의존하지 않는 경우, 이 마이그레이션에 대해 걱정할 필요가 없습니다. </p>`,10)),n("p",null,[s[16]||(s[16]=a(" 마이그레이션에 대한 자세한 내용은 ")),l(e,{to:"strategy-migration"},{default:c(()=>s[15]||(s[15]=[a(" 여기 ")])),_:1}),s[17]||(s[17]=a(" 에서 확인할 수 있습니다. "))]),s[22]||(s[22]=p(`<h2 id="outlier-detection"> 이상치 탐지 <a class="headerlink" href="#outlier-detection" title="영구 링크"> ¶ </a></h2><p>주식 및 암호화폐 시장은 이상치 데이터 포인트 형태의 높은 수준의 비패턴화된 노이즈로 고통받습니다. FreqAI는 이러한 이상치를 식별하고 위험을 완화하기 위한 다양한 방법을 구현합니다.</p><h3 id="identifying-outliers-with-the-dissimilarity-index-di"> 유사성 지수(DI)를 사용한 이상치 식별 <a class="headerlink" href="#identifying-outliers-with-the-dissimilarity-index-di" title="영구 링크"> ¶ </a></h3><p>유사성 지수(DI)는 모델이 수행하는 각 예측과 관련된 불확실성을 정량화하는 것을 목표로 합니다.</p><p>구성에 다음 문구를 포함하여 DI를 사용하여 훈련/테스트 데이터 세트에서 이상치 데이터를 제거하도록 FreqAI에 지시할 수 있습니다:</p><div class="highlight"><pre><code><span class="w">    </span><span class="nt">&quot;freqai&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nt">&quot;feature_parameters&quot;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nt">&quot;DI_threshold&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div><p> 이렇게 하면 <code> DissimilarityIndex </code> 단계가 <code> feature_pipeline </code> 에 추가되고 임계값이 1로 설정됩니다. DI는 모델 특징 공간에 존재하지 않는 예측을 낮은 수준의 확실성으로 인해 버리도록 허용합니다. 이를 위해 FreqAI는 각 훈련 데이터 포인트(특징 벡터) <span class="arithmatex"> \\(X_{a}\\) </span> 와 다른 모든 훈련 데이터 포인트 간의 거리를 측정합니다: </p><div class="arithmatex">\\[ d_{ab} = \\sqrt{\\sum_{j=1}^p(X_{a,j}-X_{b,j})^2} \\]</div><p> 여기서 <span class="arithmatex"> \\(d_{ab}\\) </span> 는 정규화된 포인트 <span class="arithmatex"> \\(a\\) </span> 와 <span class="arithmatex"> \\(b\\) </span> 간의 거리이며, <span class="arithmatex"> \\(p\\) </span> 는 벡터 <span class="arithmatex"> \\(X\\) </span> 의 길이인 특징 수입니다. 훈련 데이터 포인트 집합의 특성 거리는 평균 거리를 평균한 값입니다: </p><div class="arithmatex">\\[ \\overline{d} = \\sum_{a=1}^n(\\sum_{b=1}^n(d_{ab}/n)/n) \\]</div><p><span class="arithmatex"> \\(\\overline{d}\\) </span> 는 훈련 데이터의 분산을 정량화하며, 이는 새로운 예측 특징 벡터 <span class="arithmatex"> \\(X_k\\) </span> 와 모든 훈련 데이터 간의 거리와 비교됩니다: </p><div class="arithmatex">\\[ d_k = \\arg \\min d_{k,i} \\]</div><p>이를 통해 유사성 지수를 다음과 같이 추정할 수 있습니다:</p><div class="arithmatex">\\[ DI_k = d_k/\\overline{d} \\]</div><p><code> DI_threshold </code> 를 통해 DI를 조정하여 훈련된 모델의 외삽을 증가시키거나 감소시킬 수 있습니다. 더 높은 <code> DI_threshold </code> 는 DI가 더 관대해져 훈련 데이터에서 더 멀리 떨어진 예측을 허용하는 반면, 더 낮은 <code> DI_threshold </code> 는 반대 효과를 가지며 더 많은 예측을 버립니다. </p><p>아래는 3D 데이터 세트에 대한 DI를 설명하는 그림입니다.</p>`,16)),n("img",{alt:"DI",src:t(u)},null,8,_),s[23]||(s[23]=p(`<h3 id="identifying-outliers-using-a-support-vector-machine-svm"> 서포트 벡터 머신(SVM)을 사용한 이상치 식별 <a class="headerlink" href="#identifying-outliers-using-a-support-vector-machine-svm" title="영구 링크"> ¶ </a></h3><p>구성에 다음 문구를 포함하여 서포트 벡터 머신(SVM)을 사용하여 훈련/테스트 데이터 세트에서 이상치 데이터를 제거하도록 FreqAI에 지시할 수 있습니다:</p><div class="highlight"><pre><code><span class="w">    </span><span class="nt">&quot;freqai&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nt">&quot;feature_parameters&quot;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nt">&quot;use_SVM_to_remove_outliers&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div><p> 이렇게 하면 <code> SVMOutlierExtractor </code> 단계가 <code> feature_pipeline </code> 에 추가됩니다. SVM은 훈련 데이터에 대해 훈련되며, SVM이 특징 공간을 벗어난 것으로 간주하는 데이터 포인트는 제거됩니다. </p><p><code> feature_parameters.svm_params </code> 사전에서 <code> shuffle </code> 및 <code> nu </code> 와 같은 추가 매개변수를 제공할 수 있습니다. </p><p><code> shuffle </code> 매개변수는 기본적으로 <code> False </code> 로 설정되어 일관된 결과를 보장합니다. 이를 <code> True </code> 로 설정하면 동일한 데이터 세트에서 SVM을 여러 번 실행할 때 알고리즘이 요구하는 <code> tol </code> 에 도달하기 위해 <code> max_iter </code> 가 너무 낮아 다른 결과가 나올 수 있습니다. <code> max_iter </code> 를 증가시키면 이 문제가 해결되지만 절차가 더 오래 걸립니다. </p><p><code> nu </code> 매개변수는 매우 넓게 보면 이상치로 간주해야 하는 데이터 포인트의 양을 나타내며 0과 1 사이여야 합니다. </p><h3 id="identifying-outliers-with-dbscan"> DBSCAN을 사용한 이상치 식별 <a class="headerlink" href="#identifying-outliers-with-dbscan" title="영구 링크"> ¶ </a></h3><p> 구성에서 <code> use_DBSCAN_to_remove_outliers </code> 를 활성화하여 DBSCAN을 사용하여 훈련/테스트 데이터 세트 또는 예측에서 들어오는 이상치를 클러스터링하고 제거하도록 FreqAI를 구성할 수 있습니다: </p><div class="highlight"><pre><code><span class="w">    </span><span class="nt">&quot;freqai&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nt">&quot;feature_parameters&quot;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nt">&quot;use_DBSCAN_to_remove_outliers&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div><p> 이렇게 하면 <code> DataSieveDBSCAN </code> 단계가 <code> feature_pipeline </code> 에 추가됩니다. 이는 클러스터 수를 알 필요 없이 데이터를 클러스터링하는 비지도 학습 알고리즘입니다. </p><p> 데이터 포인트 수 <span class="arithmatex"> \\(N\\) </span> 와 거리 <span class="arithmatex"> \\(\\varepsilon\\) </span> 가 주어지면 DBSCAN은 <span class="arithmatex"> \\(N-1\\) </span> 개의 다른 데이터 포인트가 <span class="arithmatex"> \\(\\varepsilon\\) </span> 거리 내에 있는 모든 데이터 포인트를 <em> 핵심 포인트 </em> 로 설정하여 데이터 세트를 클러스터링합니다. <em> 핵심 포인트 </em> 에서 <span class="arithmatex"> \\(\\varepsilon\\) </span> 거리 내에 있지만 <span class="arithmatex"> \\(N-1\\) </span> 개의 다른 데이터 포인트가 <span class="arithmatex"> \\(\\varepsilon\\) </span> 거리 내에 없는 데이터 포인트는 <em> 가장자리 포인트 </em> 로 간주됩니다. 클러스터는 <em> 핵심 포인트 </em> 와 <em> 가장자리 포인트 </em> 의 집합입니다. <span class="arithmatex"> \\(&lt;\\varepsilon\\) </span> 거리 내에 다른 데이터 포인트가 없는 데이터 포인트는 이상치로 간주됩니다. 아래 그림은 <code>N = 3</code> 인 클러스터를 보여줍니다. </p>`,12)),n("img",{alt:"DBSCAN",src:t(m)},null,8,g),s[24]||(s[24]=p(`<p> FreqAI는 <code> sklearn.cluster.DBSCAN </code> (자세한 내용은 scikit-learn의 웹페이지 <a href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.DBSCAN.html"> 여기 </a> (외부 웹사이트)에서 확인할 수 있습니다)를 사용하며, <code> min_samples </code> ( <span class="arithmatex"> \\(N\\) </span> )은 특징 세트의 시간 포인트(캔들) 수의 ¼로 설정됩니다. <code> eps </code> ( <span class="arithmatex"> \\(\\varepsilon\\) </span> )은 특징 세트의 모든 데이터 포인트의 쌍별 거리에서 최근접 이웃의 <em> k-거리 그래프 </em> 에서 엘보 포인트로 자동 계산됩니다. </p><h3 id="data-dimensionality-reduction-with-principal-component-analysis"> 주성분 분석을 통한 데이터 차원 축소 <a class="headerlink" href="#data-dimensionality-reduction-with-principal-component-analysis" title="영구 링크"> ¶ </a></h3><p>구성에서 주성분 분석을 활성화하여 특징의 차원을 줄일 수 있습니다:</p><div class="highlight"><pre><code><span class="w">    </span><span class="nt">&quot;freqai&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nt">&quot;feature_parameters&quot;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nt">&quot;principal_component_analysis&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div><p>이렇게 하면 특징에 대해 PCA를 수행하고 데이터 세트의 설명된 분산이 0.999 이상이 되도록 차원을 줄입니다. 데이터 차원을 줄이면 모델 훈련이 더 빨라져 더 최신의 모델을 사용할 수 있습니다.</p>`,5))])}}};export{v as default};
