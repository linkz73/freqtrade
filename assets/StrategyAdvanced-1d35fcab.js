import{_ as e}from"./_plugin-vue_export-helper-c27b6911.js";import{r as t,o,c as r,b as n,d as a,e as c,w as l,a as d}from"./index-ff969378.js";const i={},m={class:"md-content__inner md-typeset"};function _(u,s){const p=t("router-link");return o(),r("article",m,[s[8]||(s[8]=n("h1",{id:"advanced-strategies"},[a(" 고급 전략 "),n("a",{class:"headerlink",href:"#advanced-strategies",title:"영구 링크"}," ¶ ")],-1)),n("p",null,[s[2]||(s[2]=a(" 이 페이지는 전략에 사용할 수 있는 몇 가지 고급 개념을 설명합니다. 시작하려면 먼저 ")),c(p,{to:"bot-basics"},{default:l(()=>s[0]||(s[0]=[a("Freqtrade 기본")])),_:1}),s[3]||(s[3]=a(" 및 ")),c(p,{to:"strategy-customization"},{default:l(()=>s[1]||(s[1]=[a("전략 커스터마이징")])),_:1}),s[4]||(s[4]=a(" 에 설명된 방법을 숙지하십시오. "))]),n("p",null,[s[6]||(s[6]=a(" 여기에 설명된 메서드의 호출 순서는 ")),c(p,{to:"bot-basics"},{default:l(()=>s[5]||(s[5]=[a("봇 실행 로직")])),_:1}),s[7]||(s[7]=a(" 에서 다룹니다. 이 문서는 사용자 정의 요구에 가장 적합한 메서드를 결정하는 데에도 유용합니다. "))]),s[9]||(s[9]=d(`<div class="admonition note"><p class="admonition-title">참고</p><p> 콜백 메서드는 전략이 이를 사용하는 경우에만 <em>구현</em> 해야 합니다. </p></div><div class="admonition tip"><p class="admonition-title">팁</p><p><code>freqtrade new-strategy --strategy MyAwesomeStrategy --template advanced</code> 를 실행하여 모든 사용 가능한 콜백 메서드가 포함된 전략 템플릿으로 시작하십시오. </p></div><h2 id="storing-information-persistent"> 정보 저장 (영구적) <a class="headerlink" href="#storing-information-persistent" title="영구 링크"> ¶ </a></h2><p>Freqtrade는 특정 거래와 관련된 사용자 정의 정보를 데이터베이스에 저장/검색할 수 있도록 허용합니다.</p><p> 거래 객체를 사용하여 <code>trade.set_custom_data(key=&#39;my_key&#39;, value=my_value)</code> 를 통해 정보를 저장하고 <code>trade.get_custom_data(key=&#39;my_key&#39;)</code> 를 통해 검색할 수 있습니다. 각 데이터 항목은 거래 및 사용자 제공 키(유형: <code>string</code> )와 연결됩니다. 이는 거래 객체를 제공하는 콜백에서만 사용할 수 있음을 의미합니다. </p><p>데이터를 데이터베이스에 저장하려면 Freqtrade가 데이터를 직렬화해야 합니다. 이는 데이터를 JSON 형식의 문자열로 변환하여 수행됩니다. Freqtrade는 검색 시 이 작업을 역으로 수행하려고 시도하므로 전략 관점에서는 관련이 없습니다.</p><div class="highlight"><pre><code><span class="kn">from</span><span class="w"> </span><span class="nn">freqtrade.persistence</span><span class="w"> </span><span class="kn">import</span> <span class="n">Trade</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">timedelta</span>

<span class="k">class</span><span class="w"> </span><span class="nc">AwesomeStrategy</span><span class="p">(</span><span class="n">IStrategy</span><span class="p">):</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">bot_loop_start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">trade</span> <span class="ow">in</span> <span class="n">Trade</span><span class="o">.</span><span class="n">get_open_order_trades</span><span class="p">():</span>
            <span class="n">fills</span> <span class="o">=</span> <span class="n">trade</span><span class="o">.</span><span class="n">select_filled_orders</span><span class="p">(</span><span class="n">trade</span><span class="o">.</span><span class="n">entry_side</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">trade</span><span class="o">.</span><span class="n">pair</span> <span class="o">==</span> <span class="s1">&#39;ETH/USDT&#39;</span><span class="p">:</span>
                <span class="n">trade_entry_type</span> <span class="o">=</span> <span class="n">trade</span><span class="o">.</span><span class="n">get_custom_data</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="s1">&#39;entry_type&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">trade_entry_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">trade_entry_type</span> <span class="o">=</span> <span class="s1">&#39;breakout&#39;</span> <span class="k">if</span> <span class="s1">&#39;entry_1&#39;</span> <span class="ow">in</span> <span class="n">trade</span><span class="o">.</span><span class="n">enter_tag</span> <span class="k">else</span> <span class="s1">&#39;dip&#39;</span>
                <span class="k">elif</span> <span class="n">fills</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">trade_entry_type</span> <span class="o">=</span> <span class="s1">&#39;buy_up&#39;</span>
                <span class="n">trade</span><span class="o">.</span><span class="n">set_custom_data</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="s1">&#39;entry_type&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">trade_entry_type</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">bot_loop_start</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">adjust_entry_price</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trade</span><span class="p">:</span> <span class="n">Trade</span><span class="p">,</span> <span class="n">order</span><span class="p">:</span> <span class="n">Order</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">pair</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                           <span class="n">current_time</span><span class="p">:</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">proposed_rate</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">current_order_rate</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                           <span class="n">entry_tag</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">side</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="c1"># BTC/USDT 거래 쌍의 경우 진입 트리거 후 10분 동안 SMA200을 가격 목표로 사용하여 제한 주문을 사용하고 따릅니다.</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">pair</span> <span class="o">==</span> <span class="s1">&#39;BTC/USDT&#39;</span> 
            <span class="ow">and</span> <span class="n">entry_tag</span> <span class="o">==</span> <span class="s1">&#39;long_sma200&#39;</span> 
            <span class="ow">and</span> <span class="n">side</span> <span class="o">==</span> <span class="s1">&#39;long&#39;</span> 
            <span class="ow">and</span> <span class="p">(</span><span class="n">current_time</span> <span class="o">-</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">minutes</span><span class="o">=</span><span class="mi">10</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">trade</span><span class="o">.</span><span class="n">open_date_utc</span> 
            <span class="ow">and</span> <span class="n">order</span><span class="o">.</span><span class="n">filled</span> <span class="o">==</span> <span class="mf">0.0</span>
        <span class="p">):</span>
            <span class="n">dataframe</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dp</span><span class="o">.</span><span class="n">get_analyzed_dataframe</span><span class="p">(</span><span class="n">pair</span><span class="o">=</span><span class="n">pair</span><span class="p">,</span> <span class="n">timeframe</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">timeframe</span><span class="p">)</span>
            <span class="n">current_candle</span> <span class="o">=</span> <span class="n">dataframe</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="c1"># 진입 조정에 대한 정보 저장</span>
            <span class="n">existing_count</span> <span class="o">=</span> <span class="n">trade</span><span class="o">.</span><span class="n">get_custom_data</span><span class="p">(</span><span class="s1">&#39;num_entry_adjustments&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">existing_count</span><span class="p">:</span>
                <span class="n">existing_count</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">existing_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">trade</span><span class="o">.</span><span class="n">set_custom_data</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="s1">&#39;num_entry_adjustments&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">existing_count</span><span class="p">)</span>

            <span class="c1"># 주문 가격 조정</span>
            <span class="k">return</span> <span class="n">current_candle</span><span class="p">[</span><span class="s1">&#39;sma_200&#39;</span><span class="p">]</span>

        <span class="c1"># 기본값: 기존 주문 유지</span>
        <span class="k">return</span> <span class="n">current_order_rate</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">custom_exit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pair</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">trade</span><span class="p">:</span> <span class="n">Trade</span><span class="p">,</span> <span class="n">current_time</span><span class="p">:</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">current_rate</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">current_profit</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="n">entry_adjustment_count</span> <span class="o">=</span> <span class="n">trade</span><span class="o">.</span><span class="n">get_custom_data</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="s1">&#39;num_entry_adjustments&#39;</span><span class="p">)</span>
        <span class="n">trade_entry_type</span> <span class="o">=</span> <span class="n">trade</span><span class="o">.</span><span class="n">get_custom_data</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="s1">&#39;entry_type&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">entry_adjustment_count</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">current_profit</span> <span class="o">&gt;</span> <span class="mf">0.01</span> <span class="ow">and</span> <span class="p">(</span><span class="n">current_time</span> <span class="o">-</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">minutes</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">trade</span><span class="o">.</span><span class="n">open_date_utc</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;exit_1&#39;</span>
        <span class="k">else</span>
            <span class="k">if</span> <span class="n">entry_adjustment_count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="k">if</span> <span class="n">current_profit</span> <span class="o">&gt;</span> <span class="mf">0.05</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;exit_2&#39;</span>
            <span class="k">if</span> <span class="n">trade_entry_type</span> <span class="o">==</span> <span class="s1">&#39;breakout&#39;</span> <span class="ow">and</span> <span class="n">current_profit</span> <span class="o">&gt;</span> <span class="mf">0.1</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;exit_3&#39;</span>

        <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span>
</code></pre></div><p>위의 예는 간단한 예입니다. 진입 조정과 같은 거래 데이터를 검색하는 더 간단한 방법이 있습니다.</p><div class="admonition note"><p class="admonition-title">참고</p><p> 간단한 데이터 유형 <code>[bool, int, float, str]</code> 을 사용하여 저장해야 하는 데이터를 직렬화할 때 문제가 없도록 하는 것이 좋습니다. 많은 양의 데이터를 저장하면 데이터베이스가 커지고(결과적으로 느려짐) 의도하지 않은 부작용이 발생할 수 있습니다. </p></div><div class="admonition warning"><p class="admonition-title">직렬화할 수 없는 데이터</p><p> 제공된 데이터를 직렬화할 수 없는 경우 경고가 기록되고 지정된 <code>key</code> 에 대한 항목에 <code>None</code> 데이터가 포함됩니다. </p></div><details class="note"><summary>모든 속성</summary><p> 사용자 정의 데이터는 거래 객체(아래에서 <code>trade</code> 로 가정)를 통해 다음 접근자를 갖습니다: </p><ul><li><code>trade.get_custom_data(key=&#39;something&#39;, default=0)</code> - 제공된 유형으로 실제 값을 반환합니다. </li><li><code>trade.get_custom_data_entry(key=&#39;something&#39;)</code> - 메타데이터를 포함한 항목을 반환합니다. 값은 <code>.value</code> 속성을 통해 액세스할 수 있습니다. </li><li><code>trade.set_custom_data(key=&#39;something&#39;, value={&#39;some&#39;: &#39;value&#39;})</code> - 이 거래에 대한 해당 키를 설정하거나 업데이트합니다. 값은 직렬화 가능해야 하며 저장된 데이터를 상대적으로 작게 유지하는 것이 좋습니다. </li></ul><p>&quot;값&quot;은 설정 및 수신 시 모든 유형일 수 있지만 JSON 직렬화 가능해야 합니다.</p></details><h2 id="storing-information-non-persistent"> 정보 저장 (비영구적) <a class="headerlink" href="#storing-information-non-persistent" title="영구 링크"> ¶ </a></h2><div class="admonition warning"><p class="admonition-title">사용 중단됨</p><p> 이 정보 저장 방법은 사용 중단되었으며 비영구적 저장소 사용을 권장하지 않습니다. <br> 대신 <a href="#storing-information-persistent">영구 저장소</a> 를 사용하십시오. </p><p>따라서 내용이 축소되었습니다.</p></div><details class="abstract"><summary>정보 저장</summary><p>정보 저장은 전략 클래스 내에 새 사전을 생성하여 수행할 수 있습니다.</p><p> 변수 이름은 임의로 선택할 수 있지만 미리 정의된 전략 변수와의 이름 충돌을 피하기 위해 <code>custom_</code> 접두사를 붙여야 합니다. </p><div class="highlight"><pre><code><span class="k">class</span><span class="w"> </span><span class="nc">AwesomeStrategy</span><span class="p">(</span><span class="n">IStrategy</span><span class="p">):</span>
    <span class="c1"># 사용자 정의 사전 생성</span>
    <span class="n">custom_info</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">populate_indicators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">metadata</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="c1"># 항목이 이미 있는지 확인</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;pair&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_info</span><span class="p">:</span>
            <span class="c1"># 이 거래 쌍에 대한 빈 항목 생성</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">custom_info</span><span class="p">[</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;pair&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="s2">&quot;crosstime&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_info</span><span class="p">[</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;pair&quot;</span><span class="p">]]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">custom_info</span><span class="p">[</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;pair&quot;</span><span class="p">]][</span><span class="s2">&quot;crosstime&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">custom_info</span><span class="p">[</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;pair&quot;</span><span class="p">]][</span><span class="s2">&quot;crosstime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div><div class="admonition warning"><p class="admonition-title">경고</p><p>데이터는 봇 재시작(또는 구성 재로드) 후에도 유지되지 않습니다. 또한 데이터 양이 많아지면 봇이 많은 메모리를 소비하기 시작하고 결국 메모리가 부족하여 충돌할 수 있습니다.</p></div><div class="admonition note"><p class="admonition-title">참고</p><p>데이터가 거래 쌍별로 특정한 경우 사전의 키 중 하나로 거래 쌍을 사용해야 합니다.</p></div></details><h2 id="dataframe-access"> 데이터프레임 접근 <a class="headerlink" href="#dataframe-access" title="영구 링크"> ¶ </a></h2><p>데이터프레임은 데이터 제공자에서 쿼리하여 다양한 전략 함수에서 액세스할 수 있습니다.</p><div class="highlight"><pre><code><span class="kn">from</span><span class="w"> </span><span class="nn">freqtrade.exchange</span><span class="w"> </span><span class="kn">import</span> <span class="n">timeframe_to_prev_date</span>

<span class="k">class</span><span class="w"> </span><span class="nc">AwesomeStrategy</span><span class="p">(</span><span class="n">IStrategy</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">confirm_trade_exit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pair</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">trade</span><span class="p">:</span> <span class="s1">&#39;Trade&#39;</span><span class="p">,</span> <span class="n">order_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                           <span class="n">rate</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">time_in_force</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">exit_reason</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                           <span class="n">current_time</span><span class="p">:</span> <span class="s1">&#39;datetime&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># 거래 쌍 데이터프레임 가져오기.</span>
        <span class="n">dataframe</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dp</span><span class="o">.</span><span class="n">get_analyzed_dataframe</span><span class="p">(</span><span class="n">pair</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeframe</span><span class="p">)</span>

        <span class="c1"># 마지막 사용 가능한 캔들 가져오기. 현재 시간은 현재 완료되지 않은 캔들을 가리키므로 최신 캔들을 찾는 데 사용하지 마십시오.</span>
        <span class="n">last_candle</span> <span class="o">=</span> <span class="n">dataframe</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="c1"># &lt;...&gt;</span>

        <span class="c1"># 시뮬레이션/실시간 실행에서는 거래 오픈 날짜가 캔들 오픈 날짜와 일치하지 않으므로 반올림해야 합니다.</span>
        <span class="n">trade_date</span> <span class="o">=</span> <span class="n">timeframe_to_prev_date</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timeframe</span><span class="p">,</span> <span class="n">trade</span><span class="o">.</span><span class="n">open_date_utc</span><span class="p">)</span>
        <span class="c1"># 거래 캔들 찾기.</span>
        <span class="n">trade_candle</span> <span class="o">=</span> <span class="n">dataframe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">trade_date</span><span class="p">]</span>
        <span class="c1"># 거래가 막 열렸기 때문에 거래 캔들이 비어 있을 수 있습니다.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">trade_candle</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="n">trade_candle</span> <span class="o">=</span> <span class="n">trade_candle</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="c1"># &lt;...&gt;</span>
</code></pre></div><div class="admonition warning"><p class="admonition-title">.iloc[-1] 사용</p><p><code>.iloc[-1]</code> 을 사용할 수 있습니다. <code>get_analyzed_dataframe()</code> 는 백테스팅이 볼 수 있는 캔들만 반환하기 때문입니다. 이는 <code>populate_*</code> 메서드에서는 작동하지 않으므로 해당 영역에서 <code>.iloc[]</code> 을 사용하지 마십시오. 또한, 이는 2021.5 버전부터 작동합니다. </p></div><hr><h2 id="enter-tag"> 진입 태그 <a class="headerlink" href="#enter-tag" title="영구 링크"> ¶ </a></h2><p>진입 태그는 거래가 열린 이유를 식별하는 데 사용됩니다. 이는 거래가 열린 후에도 거래 객체에서 사용할 수 있으며, 거래가 열린 이유에 따라 다른 청산 로직을 구현하는 데 사용할 수 있습니다.</p><p> 진입 태그는 <code>populate_entry_trend</code> 메서드에서 설정됩니다. 예: </p><div class="highlight"><pre><code><span class="k">def</span><span class="w"> </span><span class="nf">populate_entry_trend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">metadata</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
    <span class="n">dataframe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
        <span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;rsi&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">),</span>
        <span class="s1">&#39;enter_long&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">dataframe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
        <span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;rsi&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">),</span>
        <span class="s1">&#39;enter_tag&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;rsi_below_30&#39;</span>

    <span class="k">return</span> <span class="n">dataframe</span>
</code></pre></div><p> 진입 태그는 거래 객체에서 <code>trade.enter_tag</code> 를 통해 액세스할 수 있습니다. </p><div class="admonition note"><p class="admonition-title">참고</p><p>진입 태그는 문자열이어야 하며, 거래가 열린 이유를 식별하는 데 사용됩니다. 이는 거래가 열린 후에도 거래 객체에서 사용할 수 있으며, 거래가 열린 이유에 따라 다른 청산 로직을 구현하는 데 사용할 수 있습니다.</p></div><div class="admonition warning"><p class="admonition-title">경고</p><p>진입 태그는 거래가 열린 후에도 변경할 수 없습니다. 이는 거래가 열린 이유를 식별하는 데 사용되므로 변경하면 안 됩니다.</p></div>`,26))])}const k=e(i,[["render",_]]);export{k as default};
