import{r as o,o as r,c,b as t,d as a,e,w as n,a as p}from"./index-f254d819.js";const l={class:"md-content__inner md-typeset"},i={class:"admonition warning"},h={__name:"TradeObject",setup(_){return(u,s)=>{const d=o("router-link");return r(),c("article",l,[s[9]||(s[9]=t("h1",{id:"trade-object"},[a(" 거래 객체 "),t("a",{class:"headerlink",href:"#trade-object",title:"영구 링크"}," ¶ ")],-1)),s[10]||(s[10]=t("h2",{id:"trade"},[a(" 거래 "),t("a",{class:"headerlink",href:"#trade",title:"영구 링크"}," ¶ ")],-1)),s[11]||(s[11]=t("p",null,[a(" freqtrade가 진입하는 포지션은 "),t("code",null," Trade "),a(" 객체에 저장되며, 데이터베이스에 영구적으로 기록됩니다. 이는 freqtrade의 핵심 개념으로, 문서의 여러 섹션에서 자주 언급되며, 대부분 이 위치를 참조합니다. ")],-1)),t("p",null,[s[1]||(s[1]=a(" 이 객체는 여러 ")),e(d,{to:"strategy-callbacks"},{default:n(()=>s[0]||(s[0]=[a(" 전략 콜백 ")])),_:1}),s[2]||(s[2]=a(" 에서 전략에 전달됩니다. 전략에 전달된 객체는 직접 수정할 수 없으며, 콜백 결과에 따라 간접적으로 수정될 수 있습니다. "))]),s[12]||(s[12]=p('<h2 id="trade-available-attributes"> 거래 - 사용 가능한 속성 <a class="headerlink" href="#trade-available-attributes" title="영구 링크"> ¶ </a></h2><p> 각 개별 거래에 대해 사용할 수 있는 속성/프로퍼티는 다음과 같으며, <code> trade.&lt;property&gt; </code> (예: <code> trade.pair </code> ) 형식으로 사용할 수 있습니다. </p><table><thead><tr><th>속성</th><th>데이터 유형</th><th>설명</th></tr></thead><tbody><tr><td><code> pair </code></td><td>문자열</td><td>이 거래의 거래쌍.</td></tr><tr><td><code> is_open </code></td><td>불리언</td><td>현재 거래가 열려 있는지, 아니면 종료되었는지 여부.</td></tr><tr><td><code> open_rate </code></td><td>실수</td><td>이 거래가 진입한 비율 (거래 조정 시 평균 진입 비율).</td></tr><tr><td><code> close_rate </code></td><td>실수</td><td>종료 비율 - is_open = False일 때만 설정됩니다.</td></tr><tr><td><code> stake_amount </code></td><td>실수</td><td>스테이크(또는 견적) 통화의 금액.</td></tr><tr><td><code> amount </code></td><td>실수</td><td>현재 보유 중인 자산/기본 통화의 금액. 초기 주문이 체결되기 전까지는 0.0입니다.</td></tr><tr><td><code> open_date </code></td><td>날짜시간</td><td> 거래가 열린 타임스탬프 <strong><code> open_date_utc </code> 를 대신 사용하세요. </strong></td></tr><tr><td><code> open_date_utc </code></td><td>날짜시간</td><td>UTC 기준으로 거래가 열린 타임스탬프.</td></tr><tr><td><code> close_date </code></td><td>날짜시간</td><td> 거래가 종료된 타임스탬프 <strong><code> close_date_utc </code> 를 대신 사용하세요. </strong></td></tr><tr><td><code> close_date_utc </code></td><td>날짜시간</td><td>UTC 기준으로 거래가 종료된 타임스탬프.</td></tr><tr><td><code> close_profit </code></td><td>실수</td><td> 거래 종료 시점의 상대적 수익. <code> 0.01 </code> == 1% </td></tr><tr><td><code> close_profit_abs </code></td><td>실수</td><td>거래 종료 시점의 절대 수익 (스테이크 통화 기준).</td></tr><tr><td><code> leverage </code></td><td>실수</td><td>이 거래에 사용된 레버리지 - 현물 시장에서는 기본값이 1.0입니다.</td></tr><tr><td><code> enter_tag </code></td><td>문자열</td><td> 데이터프레임의 <code> enter_tag </code> 열을 통해 진입 시 제공된 태그. </td></tr><tr><td><code> is_short </code></td><td>불리언</td><td>숏 거래인 경우 True, 그렇지 않으면 False.</td></tr><tr><td><code> orders </code></td><td>Order[]</td><td>이 거래에 연결된 주문 객체 목록 (체결 및 취소된 주문 포함).</td></tr><tr><td><code> date_last_filled_utc </code></td><td>날짜시간</td><td>마지막으로 체결된 주문 시간.</td></tr><tr><td><code> entry_side </code></td><td>&quot;buy&quot; / &quot;sell&quot;</td><td>거래가 진입한 주문 방향.</td></tr><tr><td><code> exit_side </code></td><td>&quot;buy&quot; / &quot;sell&quot;</td><td>거래 종료/포지션 감소를 초래하는 주문 방향.</td></tr><tr><td><code> trade_direction </code></td><td>&quot;long&quot; / &quot;short&quot;</td><td>텍스트로 된 거래 방향 - 롱 또는 숏.</td></tr><tr><td><code> nr_of_successful_entries </code></td><td>정수</td><td>성공적으로 체결된 진입 주문 수.</td></tr><tr><td><code> nr_of_successful_exits </code></td><td>정수</td><td>성공적으로 체결된 종료 주문 수.</td></tr></tbody></table><h2 id="class-methods"> 클래스 메서드 <a class="headerlink" href="#class-methods" title="영구 링크"> ¶ </a></h2><p> 다음은 일반 정보를 반환하며, 보통 데이터베이스에 대한 명시적 쿼리를 수행하는 클래스 메서드입니다. <code> Trade.&lt;method&gt; </code> 형식으로 사용할 수 있습니다. 예: <code> open_trades = Trade.get_open_trade_count() </code></p>',5)),t("div",i,[s[8]||(s[8]=t("p",{class:"admonition-title"},"백테스팅/하이퍼옵트",-1)),t("p",null,[s[4]||(s[4]=a(" 대부분의 메서드는 백테스팅/하이퍼옵트와 라이브/드라이 모드에서 작동합니다. 백테스팅 중에는 ")),e(d,{to:"strategy-callbacks"},{default:n(()=>s[3]||(s[3]=[a(" 전략 콜백 ")])),_:1}),s[5]||(s[5]=a(" 에서만 사용이 제한됩니다. ")),s[6]||(s[6]=t("code",null," populate_*() ",-1)),s[7]||(s[7]=a(" 메서드에서의 사용은 지원되지 않으며 잘못된 결과를 초래할 수 있습니다. "))])]),s[13]||(s[13]=p(`<h3 id="get_trades_proxy"> get_trades_proxy <a class="headerlink" href="#get_trades_proxy" title="영구 링크"> ¶ </a></h3><p> 전략이 기존 거래(열린 거래 또는 닫힌 거래)에 대한 정보를 필요로 할 때는 <code> Trade.get_trades_proxy() </code> 를 사용하는 것이 가장 좋습니다. </p><p>사용 예:</p><div class="highlight"><pre><code><span class="kn">from</span><span class="w"> </span><span class="nn">freqtrade.persistence</span><span class="w"> </span><span class="kn">import</span> <span class="n">Trade</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">timedelta</span>

<span class="c1"># ...</span>
<span class="n">trade_hist</span> <span class="o">=</span> <span class="n">Trade</span><span class="o">.</span><span class="n">get_trades_proxy</span><span class="p">(</span><span class="n">pair</span><span class="o">=</span><span class="s1">&#39;ETH/USDT&#39;</span><span class="p">,</span> <span class="n">is_open</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">open_date</span><span class="o">=</span><span class="n">current_date</span> <span class="o">-</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
</code></pre></div><p><code> get_trades_proxy() </code> 는 다음 키워드 인수를 지원합니다. 모든 인수는 선택 사항이며, 인수를 제공하지 않고 호출하면 데이터베이스의 모든 거래 목록을 반환합니다. </p><ul><li><code> pair </code> 예: <code> pair=&#39;ETH/USDT&#39; </code></li><li><code> is_open </code> 예: <code> is_open=False </code></li><li><code> open_date </code> 예: <code> open_date=current_date - timedelta(days=2) </code></li><li><code> close_date </code> 예: <code> close_date=current_date - timedelta(days=5) </code></li></ul><h3 id="get_open_trade_count"> get_open_trade_count <a class="headerlink" href="#get_open_trade_count" title="영구 링크"> ¶ </a></h3><p>현재 열려 있는 거래 수를 가져옵니다.</p><div class="highlight"><pre><code><span class="kn">from</span><span class="w"> </span><span class="nn">freqtrade.persistence</span><span class="w"> </span><span class="kn">import</span> <span class="n">Trade</span>
<span class="c1"># ...</span>
<span class="n">open_trades</span> <span class="o">=</span> <span class="n">Trade</span><span class="o">.</span><span class="n">get_open_trade_count</span><span class="p">()</span>
</code></pre></div><h3 id="get_total_closed_profit"> get_total_closed_profit <a class="headerlink" href="#get_total_closed_profit" title="영구 링크"> ¶ </a></h3><p> 봇이 지금까지 생성한 총 수익을 가져옵니다. 모든 종료된 거래에 대해 <code> close_profit_abs </code> 를 집계합니다. </p><div class="highlight"><pre><code><span class="kn">from</span><span class="w"> </span><span class="nn">freqtrade.persistence</span><span class="w"> </span><span class="kn">import</span> <span class="n">Trade</span>

<span class="c1"># ...</span>
<span class="n">profit</span> <span class="o">=</span> <span class="n">Trade</span><span class="o">.</span><span class="n">get_total_closed_profit</span><span class="p">()</span>
</code></pre></div><h3 id="total_open_trades_stakes"> total_open_trades_stakes <a class="headerlink" href="#total_open_trades_stakes" title="영구 링크"> ¶ </a></h3><p>현재 거래 중인 총 스테이크 금액을 가져옵니다.</p><div class="highlight"><pre><code><span class="kn">from</span><span class="w"> </span><span class="nn">freqtrade.persistence</span><span class="w"> </span><span class="kn">import</span> <span class="n">Trade</span>

<span class="c1"># ...</span>
<span class="n">profit</span> <span class="o">=</span> <span class="n">Trade</span><span class="o">.</span><span class="n">total_open_trades_stakes</span><span class="p">()</span>
</code></pre></div><h3 id="get_overall_performance"> get_overall_performance <a class="headerlink" href="#get_overall_performance" title="영구 링크"> ¶ </a></h3><p> 전체 성과를 가져옵니다 - <code> /performance </code> 텔레그램 명령과 유사합니다. </p><div class="highlight"><pre><code><span class="kn">from</span><span class="w"> </span><span class="nn">freqtrade.persistence</span><span class="w"> </span><span class="kn">import</span> <span class="n">Trade</span>

<span class="c1"># ...</span>
<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;runmode&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;live&#39;</span><span class="p">,</span> <span class="s1">&#39;dry_run&#39;</span><span class="p">):</span>
    <span class="n">performance</span> <span class="o">=</span> <span class="n">Trade</span><span class="o">.</span><span class="n">get_overall_performance</span><span class="p">()</span>
</code></pre></div><p>샘플 반환 값: ETH/BTC는 5번의 거래를 했으며, 총 수익은 1.5% (비율 0.015)입니다.</p><div class="highlight"><pre><code><span class="p">{</span><span class="nt">&quot;pair&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;ETH/BTC&quot;</span><span class="p">,</span><span class="w"> </span><span class="nt">&quot;profit&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">0.015</span><span class="p">,</span><span class="w"> </span><span class="nt">&quot;count&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">5</span><span class="p">}</span>
</code></pre></div><h2 id="order-object"> 주문 객체 <a class="headerlink" href="#order-object" title="영구 링크"> ¶ </a></h2><p><code> Order </code> 객체는 거래소의 주문(또는 드라이런 모드에서의 시뮬레이션된 주문)을 나타냅니다. <code> Order </code> 객체는 항상 해당 <a href="#trade-object"><code> Trade </code></a> 와 연결되며, 거래의 맥락에서만 의미가 있습니다. </p><h3 id="order-available-attributes"> 주문 - 사용 가능한 속성 <a class="headerlink" href="#order-available-attributes" title="영구 링크"> ¶ </a></h3><p>주문 객체는 일반적으로 거래에 연결됩니다. 여기의 대부분의 속성은 거래소 응답에 따라 None일 수 있습니다.</p><table><thead><tr><th>속성</th><th>데이터 유형</th><th>설명</th></tr></thead><tbody><tr><td><code> trade </code></td><td>Trade</td><td>이 주문이 연결된 거래 객체</td></tr><tr><td><code> ft_pair </code></td><td>문자열</td><td>이 주문의 거래쌍</td></tr><tr><td><code> ft_is_open </code></td><td>불리언</td><td>주문이 체결되었는지 여부</td></tr><tr><td><code> order_type </code></td><td>문자열</td><td>거래소에서 정의한 주문 유형 - 보통 시장가, 지정가 또는 손절매</td></tr><tr><td><code> status </code></td><td>문자열</td><td>ccxt에서 정의한 상태. 보통 open, closed, expired 또는 canceled</td></tr><tr><td><code> side </code></td><td>문자열</td><td>매수 또는 매도</td></tr><tr><td><code> price </code></td><td>실수</td><td>주문이 체결된 가격</td></tr><tr><td><code> average </code></td><td>실수</td><td>주문이 체결된 평균 가격</td></tr><tr><td><code> amount </code></td><td>실수</td><td>기본 통화의 금액</td></tr><tr><td><code> filled </code></td><td>실수</td><td>체결된 금액 (기본 통화 기준)</td></tr><tr><td><code> remaining </code></td><td>실수</td><td>남은 금액</td></tr><tr><td><code> cost </code></td><td>실수</td><td> 주문의 비용 - 보통 average * filled ( <em> 선물의 경우 거래소에 따라 레버리지 포함 여부와 계약 단위가 다를 수 있습니다. </em> ) </td></tr><tr><td><code> stake_amount </code></td><td>실수</td><td> 이 주문에 사용된 스테이크 금액. <em> 2023.7에 추가됨. </em></td></tr><tr><td><code> stake_amount_filled </code></td><td>실수</td><td> 이 주문에 사용된 체결된 스테이크 금액. <em> 2024.11에 추가됨. </em></td></tr><tr><td><code> order_date </code></td><td>날짜시간</td><td> 주문 생성 날짜 <strong><code> order_date_utc </code> 를 대신 사용하세요. </strong></td></tr><tr><td><code> order_date_utc </code></td><td>날짜시간</td><td>주문 생성 날짜 (UTC 기준)</td></tr><tr><td><code> order_fill_date </code></td><td>날짜시간</td><td> 주문 체결 날짜 <strong><code> order_fill_utc </code> 를 대신 사용하세요. </strong></td></tr><tr><td><code> order_fill_date_utc </code></td><td>날짜시간</td><td>주문 체결 날짜</td></tr></tbody></table>`,25))])}}};export{h as default};
