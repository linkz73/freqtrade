import{r,o,c as d,b as n,d as a,e as l,w as t,a as e}from"./index-1f8801f6.js";const i={class:"md-content__inner md-typeset"},u={class:"admonition warning"},f={class:"hint"},k={__name:"Strategy101",setup(m){return(g,s)=>{const p=r("router-link");return o(),d("article",i,[s[63]||(s[63]=n("h1",{id:"freqtrade-strategies-101-a-quick-start-for-strategy-development"},[a(" Freqtrade 전략 101: 전략 개발 시작하기 "),n("a",{class:"headerlink",href:"#freqtrade-strategies-101-a-quick-start-for-strategy-development",title:"영구 링크"}," ¶ ")],-1)),n("p",null,[s[1]||(s[1]=a(" 이 빠른 시작 가이드를 시작하기 전에 거래의 기본 개념을 이해하고 있어야 하며, ")),l(p,{to:"bot-basics"},{default:t(()=>s[0]||(s[0]=[a("Freqtrade 기본")])),_:1}),s[2]||(s[2]=a(" 페이지를 먼저 읽어보시기 바랍니다. "))]),s[64]||(s[64]=e(`<h2 id="required-knowledge"> 필수 지식 <a class="headerlink" href="#required-knowledge" title="영구 링크"> ¶ </a></h2><p>Freqtrade에서 전략은 암호화폐 <code>자산</code>을 매매하는 로직을 정의하는 Python 클래스입니다.</p><p>자산은 <code>거래 쌍</code>으로 정의되며, 이는 거래하고자 하는 <code>코인</code>과 거래의 기준이 되는 <code>스테이크</code> 통화로 구성됩니다.</p><p>거래소에서는 데이터를 <code>캔들</code> 형태로 제공하며, 각 캔들은 여섯 가지 값을 포함합니다: <code>날짜</code>, <code>시가</code>, <code>고가</code>, <code>저가</code>, <code>종가</code>, <code>거래량</code>.</p><p><code>기술적 분석</code> 함수는 캔들 데이터를 다양한 계산 및 통계 공식을 사용하여 분석하고, <code>지표</code>라는 2차 값을 생성합니다.</p><p>지표는 자산 거래 쌍의 캔들에서 분석되어 <code>신호</code>를 생성합니다.</p><p>신호는 암호화폐 <code>거래소</code>에서 <code>주문</code>, 즉 <code>거래</code>로 전환됩니다.</p><p>Freqtrade는 <code>롱</code> 및 <code>숏</code> 거래를 모두 지원하므로, 우리는 <code>매수</code>와 <code>매도</code> 대신 <code>진입</code>과 <code>청산</code>이라는 용어를 사용합니다.</p><ul><li><strong>롱</strong>: 스테이크를 기반으로 코인을 매수합니다. 예를 들어, USDT를 스테이크로 사용하여 BTC를 매수하고, 더 높은 가격에 매도하여 이익을 얻습니다. 롱 거래에서는 코인 가치가 스테이크 대비 상승할 때 이익이 발생합니다.</li><li><strong>숏</strong>: 거래소에서 자본을 코인 형태로 빌리고, 나중에 코인의 스테이크 가치를 상환합니다. 숏 거래에서는 코인 가치가 스테이크 대비 하락할 때 이익이 발생합니다.</li></ul><p>Freqtrade는 특정 거래소에서 현물 및 선물 시장을 지원하지만, 간단히 하기 위해 현물(롱) 거래에만 초점을 맞춥니다.</p><h2 id="structure-of-a-basic-strategy"> 기본 전략의 구조 <a class="headerlink" href="#structure-of-a-basic-strategy" title="영구 링크"> ¶ </a></h2><h3 id="main-dataframe"> 주요 데이터프레임 <a class="headerlink" href="#main-dataframe" title="영구 링크"> ¶ </a></h3><p>Freqtrade 전략은 <code>데이터프레임</code>이라는 행과 열로 구성된 표 형식의 데이터 구조를 사용하여 거래 진입 및 청산 신호를 생성합니다.</p><p>구성된 거래 쌍 목록의 각 거래 쌍은 자체 데이터프레임을 가지고 있습니다. 데이터프레임은 <code>날짜</code> 열로 인덱싱됩니다. 예: <code>2024-06-31 12:00</code>.</p><p>다음 5개의 열은 <code>시가</code>, <code>고가</code>, <code>저가</code>, <code>종가</code>, <code>거래량</code>(OHLCV) 데이터를 나타냅니다.</p><h3 id="populate-indicator-values"> 지표 값 설정 <a class="headerlink" href="#populate-indicator-values" title="영구 링크"> ¶ </a></h3><p><code>populate_indicators</code> 함수는 데이터프레임에 기술적 분석 지표들의 값을 추가하는 역할을 합니다.</p><p>일반적으로 사용되는 지표에는 RSI(상대 강도 지수), 볼린저 밴드, MFI(자금 흐름 지수), 이동 평균, ATR(평균 진정 범위) 등이 있습니다.</p><p>열은 기술적 분석 함수를 호출하여 데이터프레임에 추가됩니다. 예: ta-lib의 RSI 함수 <code>ta.RSI()</code>를 호출하고 이를 열 이름 <code>rsi</code>에 할당합니다.</p><div class="highlight"><pre><code><span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;rsi&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">RSI</span><span class="p">(</span><span class="n">dataframe</span><span class="p">)</span>
</code></pre></div><details class="hint"><summary>기술적 분석 라이브러리</summary><p>다양한 라이브러리는 지표 값을 생성하는 방식이 다릅니다. 각 라이브러리의 문서를 확인하여 전략에 통합하는 방법을 이해하십시오. 또한 아이디어를 얻기 위해 <a href="https://github.com/freqtrade/freqtrade-strategies">Freqtrade 예제 전략</a>을 확인할 수 있습니다.</p></details><h3 id="populate-entry-signals"> 진입 신호 설정 <a class="headerlink" href="#populate-entry-signals" title="영구 링크"> ¶ </a></h3><p><code>populate_entry_trend</code> 함수는 거래 진입을 위한 조건을 정의합니다.</p><p>데이터프레임에 <code>enter_long</code> 열이 추가되며, 이 열의 값이 <code>1</code>일 때 Freqtrade는 이를 진입 신호로 인식합니다.</p><details class="hint"><summary>숏 거래</summary><p>숏 거래에 진입하려면 <code>enter_short</code> 열을 사용하십시오.</p></details><h3 id="populate-exit-signals"> 청산 신호 설정 <a class="headerlink" href="#populate-exit-signals" title="영구 링크"> ¶ </a></h3><p><code>populate_exit_trend</code> 함수는 청산 신호에 대한 조건을 정의합니다.</p><p>데이터프레임 열 <code>exit_long</code>이 데이터프레임에 추가되며, 이 열에 <code>1</code> 값이 있을 때 Freqtrade는 청산 신호로 인식합니다.</p><details class="hint"><summary>숏 거래</summary><p>숏 거래를 청산하려면 <code>exit_short</code> 열을 사용하십시오.</p></details><h2 id="a-simple-strategy"> 간단한 전략 <a class="headerlink" href="#a-simple-strategy" title="영구 링크"> ¶ </a></h2><p>다음은 Freqtrade 전략의 최소 예제입니다:</p><div class="highlight"><pre><code><span class="kn">from</span><span class="w"> </span><span class="nn">freqtrade.strategy</span><span class="w"> </span><span class="kn">import</span> <span class="n">IStrategy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="kn">import</span> <span class="n">DataFrame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">talib.abstract</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ta</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MyStrategy</span><span class="p">(</span><span class="n">IStrategy</span><span class="p">):</span>

    <span class="n">timeframe</span> <span class="o">=</span> <span class="s1">&#39;15m&#39;</span>

    <span class="c1"># 초기 손절매를 -10%로 설정</span>
    <span class="n">stoploss</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.10</span>

    <span class="c1"># 수익이 1% 이상일 때 언제든지 수익성 있는 포지션을 종료</span>
    <span class="n">minimal_roi</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;0&quot;</span><span class="p">:</span> <span class="mf">0.01</span><span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">populate_indicators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">metadata</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="c1"># 기술적 분석 지표 값 생성</span>
        <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;rsi&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">RSI</span><span class="p">(</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">timeperiod</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dataframe</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">populate_entry_trend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">metadata</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="c1"># 지표 값을 기반으로 진입 신호 생성</span>
        <span class="n">dataframe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
            <span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;rsi&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">),</span>
            <span class="s1">&#39;enter_long&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">dataframe</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">populate_exit_trend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">metadata</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="c1"># 지표 값을 기반으로 청산 신호 생성</span>
        <span class="n">dataframe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
            <span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;rsi&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">70</span><span class="p">),</span>
            <span class="s1">&#39;exit_long&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">dataframe</span>
</code></pre></div><h2 id="making-trades"> 거래 실행 <a class="headerlink" href="#making-trades" title="영구 링크"> ¶ </a></h2><p>진입 또는 청산 열에 <code>1</code> 값이 있어 신호가 발생하면 Freqtrade는 <code>거래</code> 또는 <code>포지션</code>을 생성하려고 시도합니다.</p><p>새로운 거래 포지션은 각각 하나의 <code>슬롯</code>을 사용합니다. 슬롯은 동시에 보유할 수 있는 최대 거래 수를 의미합니다.</p>`,35)),n("p",null,[s[4]||(s[4]=a("슬롯 수는 ")),s[5]||(s[5]=n("code",null,"max_open_trades",-1)),s[6]||(s[6]=a()),l(p,{to:"configuration"},{default:t(()=>s[3]||(s[3]=[a("구성")])),_:1}),s[7]||(s[7]=a(" 옵션에 의해 정의됩니다."))]),s[65]||(s[65]=n("p",null,"그러나 신호를 생성해도 항상 거래 주문이 생성되지 않는 다양한 시나리오가 있을 수 있습니다. 이러한 시나리오에는 다음이 포함됩니다:",-1)),n("ul",null,[s[19]||(s[19]=n("li",null,"자산을 매수할 충분한 스테이크가 남아 있지 않거나, 자산을 매도할 지갑에 자금이 부족한 경우(수수료 포함)",-1)),s[20]||(s[20]=n("li",null,[a("새로운 거래를 열 수 있는 남은 슬롯이 충분하지 않은 경우(열려 있는 포지션 수가 "),n("code",null,"max_open_trades"),a(" 옵션과 동일한 경우)")],-1)),n("li",null,[s[9]||(s[9]=a("거래 쌍에 대해 이미 열린 거래가 있는 경우(Freqtrade는 포지션을 중첩할 수 없지만, ")),l(p,{to:"strategy-callbacks"},{default:t(()=>s[8]||(s[8]=[a("기존 포지션을 조정할 수 있습니다")])),_:1}),s[10]||(s[10]=a(")"))]),n("li",null,[s[12]||(s[12]=a("같은 캔들에서 진입 신호와 청산 신호가 모두 있는 경우, 이는 ")),l(p,{to:"strategy-customization"},{default:t(()=>s[11]||(s[11]=[a("충돌")])),_:1}),s[13]||(s[13]=a("로 간주되어 주문이 발생하지 않습니다."))]),n("li",null,[s[16]||(s[16]=a("전략이 관련 ")),l(p,{to:"strategy-callbacks"},{default:t(()=>s[14]||(s[14]=[a("진입")])),_:1}),s[17]||(s[17]=a(" 또는 ")),l(p,{to:"strategy-callbacks"},{default:t(()=>s[15]||(s[15]=[a("청산")])),_:1}),s[18]||(s[18]=a(" 콜백을 사용하여 거래 주문을 적극적으로 거부하는 경우"))])]),n("p",null,[s[22]||(s[22]=a("자세한 내용은 ")),l(p,{to:"strategy-customization"},{default:t(()=>s[21]||(s[21]=[a("전략 커스터마이제이션")])),_:1}),s[23]||(s[23]=a(" 문서를 참조하십시오."))]),s[66]||(s[66]=n("h2",{id:"backtesting-and-forward-testing"},[a(" 백테스팅 및 포워드 테스팅 "),n("a",{class:"headerlink",href:"#backtesting-and-forward-testing",title:"영구 링크"}," ¶ ")],-1)),s[67]||(s[67]=n("p",null,'전략 개발은 인간의 "직감"을 컴퓨터 제어("알고") 전략으로 전환하는 것이 항상 간단하지 않기 때문에 긴장되고 좌절감을 줄 수 있는 과정입니다.',-1)),s[68]||(s[68]=n("p",null,"따라서 전략이 의도한 대로 작동하는지 확인하기 위해 테스트해야 합니다.",-1)),s[69]||(s[69]=n("p",null,"Freqtrade에는 두 가지 테스트 모드가 있습니다:",-1)),n("ul",null,[n("li",null,[s[26]||(s[26]=n("strong",null,"백테스팅",-1)),s[27]||(s[27]=a(": 거래소에서 ")),l(p,{to:"data-download"},{default:t(()=>s[24]||(s[24]=[a("다운로드한")])),_:1}),s[28]||(s[28]=a(" 과거 데이터를 사용하여 백테스팅은 전략의 성능을 평가하는 빠른 방법입니다. 그러나 결과를 왜곡하여 전략이 실제보다 훨씬 더 수익성이 높아 보이게 만들기 쉽습니다. 자세한 내용은 ")),l(p,{to:"backtesting"},{default:t(()=>s[25]||(s[25]=[a("백테스팅 문서")])),_:1}),s[29]||(s[29]=a("를 참조하십시오."))]),s[30]||(s[30]=n("li",null,[n("strong",null,"시뮬레이션"),a(": 종종 "),n("em",null,"포워드 테스팅"),a("이라고 불리며, 시뮬레이션은 거래소의 실시간 데이터를 사용합니다. 그러나 거래를 유발할 수 있는 신호는 Freqtrade에 의해 정상적으로 추적되지만, 거래소 자체에서 거래가 열리지 않습니다. 포워드 테스팅은 실시간으로 실행되므로 결과를 얻는 데 시간이 더 오래 걸리지만 백테스트보다 "),n("strong",null,"잠재적"),a(" 성능의 훨씬 더 신뢰할 수 있는 지표입니다.")],-1))]),n("p",null,[s[32]||(s[32]=a("시뮬레이션은 ")),l(p,{to:"configuration"},{default:t(()=>s[31]||(s[31]=[a("구성")])),_:1}),s[33]||(s[33]=a("에서 ")),s[34]||(s[34]=n("code",null,"dry_run",-1)),s[35]||(s[35]=a("을 true로 설정하여 활성화됩니다."))]),n("div",u,[s[41]||(s[41]=n("p",{class:"admonition-title"},"백테스트는 매우 부정확할 수 있습니다",-1)),n("p",null,[s[38]||(s[38]=a("백테스트 결과가 현실과 일치하지 않는 이유는 많습니다. ")),l(p,{to:"backtesting"},{default:t(()=>s[36]||(s[36]=[a("백테스팅 가정")])),_:1}),s[39]||(s[39]=a(" 및 ")),l(p,{to:"strategy-customization"},{default:t(()=>s[37]||(s[37]=[a("일반적인 전략 실수")])),_:1}),s[40]||(s[40]=a(" 문서를 확인하십시오. Freqtrade 전략을 나열하고 순위를 매기는 일부 웹사이트는 인상적인 백테스트 결과를 보여줍니다. 이러한 결과가 달성 가능하거나 현실적이라고 가정하지 마십시오."))])]),n("details",f,[s[47]||(s[47]=n("summary",null,"유용한 명령어",-1)),n("p",null,[s[44]||(s[44]=a("Freqtrade에는 전략의 기본적인 결함을 확인하기 위한 두 가지 유용한 명령어가 포함되어 있습니다: ")),l(p,{to:"lookahead-analysis"},{default:t(()=>s[42]||(s[42]=[a("lookahead-analysis")])),_:1}),s[45]||(s[45]=a(" 및 ")),l(p,{to:"recursive-analysis"},{default:t(()=>s[43]||(s[43]=[a("recursive-analysis")])),_:1}),s[46]||(s[46]=a("."))])]),s[70]||(s[70]=e('<h3 id="assessing-backtesting-and-dry-run-results"> 백테스팅 및 시뮬레이션 결과 평가 <a class="headerlink" href="#assessing-backtesting-and-dry-run-results" title="영구 링크"> ¶ </a></h3><p>백테스팅 후 항상 시뮬레이션을 실행하여 백테스팅과 시뮬레이션 결과가 충분히 유사한지 확인하십시오.</p><p>유의미한 차이가 있는 경우, 진입 및 청산 신호가 두 모드 간에 일관되고 동일한 캔들에 나타나는지 확인하십시오. 그러나 시뮬레이션과 백테스트 간에는 항상 차이가 있을 것입니다:</p><ul><li>백테스팅은 모든 주문이 체결된다고 가정합니다. 시뮬레이션에서는 지정가 주문을 사용하거나 거래소에 거래량이 없는 경우 체결되지 않을 수 있습니다.</li><li>캔들 종료 시 진입 신호가 발생하면, 백테스팅은 다음 캔들의 시가로 거래가 진입한다고 가정합니다(전략에 사용자 정의 가격 콜백이 없는 경우). 시뮬레이션에서는 신호와 거래가 열리는 사이에 지연이 발생할 수 있습니다. 이는 새로운 캔들이 주요 시간 프레임에 들어올 때, 예를 들어 5분마다, Freqtrade가 모든 거래 쌍 데이터프레임을 분석하는 데 시간이 걸리기 때문입니다. 따라서 Freqtrade는 캔들 시가 후 몇 초(이상적으로는 가능한 한 짧은 지연) 후에 거래를 열려고 시도합니다.</li><li>시뮬레이션에서 진입 가격이 백테스팅과 일치하지 않으면, 이로 인해 수익 계산도 달라집니다. 따라서 ROI, 손절매, 트레일링 손절매 및 콜백 종료가 동일하지 않은 것이 정상입니다.</li><li>새로운 캔들이 들어오고 신호가 발생하고 거래가 열리는 사이의 계산 &quot;지연&quot;이 클수록 가격 예측 불가능성이 커집니다. 거래 쌍 목록에 있는 거래 쌍 수에 대한 데이터를 합리적인 시간 내에 처리할 수 있을 만큼 컴퓨터가 강력한지 확인하십시오. Freqtrade는 로그에 중요한 데이터 처리 지연이 있는 경우 경고합니다.</li></ul><h2 id="controlling-or-monitoring-a-running-bot"> 실행 중인 봇 제어 또는 모니터링 <a class="headerlink" href="#controlling-or-monitoring-a-running-bot" title="영구 링크"> ¶ </a></h2><p>봇이 시뮬레이션 또는 실시간 모드에서 실행 중일 때, Freqtrade에는 실행 중인 봇을 제어하거나 모니터링할 수 있는 다섯 가지 메커니즘이 있습니다:</p>',6)),n("ul",null,[n("li",null,[n("strong",null,[l(p,{to:"freq-ui"},{default:t(()=>s[48]||(s[48]=[a("FreqUI")])),_:1})]),s[49]||(s[49]=a(" : 시작하기 가장 쉬운 방법으로, FreqUI는 봇의 현재 활동을 확인하고 제어할 수 있는 웹 인터페이스입니다. "))]),n("li",null,[n("strong",null,[l(p,{to:"telegram-usage"},{default:t(()=>s[50]||(s[50]=[a("Telegram")])),_:1})]),s[51]||(s[51]=a(" : 모바일 장치에서 Telegram 통합을 통해 봇 활동에 대한 알림을 받고 특정 측면을 제어할 수 있습니다. "))]),s[56]||(s[56]=n("li",null,[n("strong",null,[n("a",{href:"https://github.com/freqtrade/ftui"},"FTUI")]),a(" : FTUI는 Freqtrade의 터미널(명령줄) 인터페이스로, 실행 중인 봇을 모니터링할 수 있습니다. ")],-1)),n("li",null,[n("strong",null,[l(p,{to:"rest-api"},{default:t(()=>s[52]||(s[52]=[a("REST API")])),_:1})]),s[53]||(s[53]=a(" : REST API를 통해 프로그래머는 Freqtrade 봇과 상호 작용하는 도구를 개발할 수 있습니다. "))]),n("li",null,[n("strong",null,[l(p,{to:"webhook-config"},{default:t(()=>s[54]||(s[54]=[a("웹훅")])),_:1})]),s[55]||(s[55]=a(" : Freqtrade는 웹훅을 통해 다른 서비스(예: Discord)에 정보를 보낼 수 있습니다. "))])]),s[71]||(s[71]=e('<h3 id="logs"> 로그 <a class="headerlink" href="#logs" title="영구 링크"> ¶ </a></h3><p>Freqtrade는 발생하는 일을 이해하는 데 도움이 되는 광범위한 디버깅 로그를 생성합니다. 봇 로그에서 볼 수 있는 정보 및 오류 메시지에 익숙해지십시오.</p><h2 id="final-thoughts"> 마지막 생각 <a class="headerlink" href="#final-thoughts" title="영구 링크"> ¶ </a></h2><p>알고리즘 거래는 어렵고, 여러 시나리오에서 수익성 있게 전략을 작동시키기 위해 시간과 노력이 필요하기 때문에 대부분의 공개 전략은 좋은 성과를 내지 못합니다.</p><p>따라서 공개 전략을 사용하고 백테스트를 통해 성능을 평가하는 것은 종종 문제가 됩니다. 그러나 Freqtrade는 결정을 내리고 실사를 수행하는 데 유용한 방법을 제공합니다.</p><p>수익성을 달성하는 방법은 여러 가지가 있으며, 성과가 저조한 전략을 수정할 수 있는 단일 팁, 트릭 또는 구성 옵션은 없습니다.</p><p>Freqtrade는 대규모의 도움이 되는 커뮤니티가 있는 오픈 소스 플랫폼입니다. 전략에 대해 다른 사람들과 논의하려면 <a href="https://discord.gg/p7nuUNVfP7">디스코드 채널</a>을 방문하십시오!</p><p>항상 잃을 수 있는 금액만 투자하십시오.</p><h2 id="conclusion"> 결론 <a class="headerlink" href="#conclusion" title="영구 링크"> ¶ </a></h2><p>Freqtrade에서 전략을 개발하는 것은 기술 지표를 기반으로 진입 및 청산 신호를 정의하는 것을 포함합니다. 위에서 설명한 구조와 방법을 따르면 자신만의 거래 전략을 만들고 테스트할 수 있습니다.</p>',10)),n("p",null,[s[58]||(s[58]=a("자주 묻는 질문과 답변은 ")),l(p,{to:"faq"},{default:t(()=>s[57]||(s[57]=[a("FAQ")])),_:1}),s[59]||(s[59]=a("에서 확인할 수 있습니다."))]),n("p",null,[s[61]||(s[61]=a("계속하려면 ")),l(p,{to:"strategy-customization"},{default:t(()=>s[60]||(s[60]=[a("Freqtrade 전략 커스터마이제이션 문서")])),_:1}),s[62]||(s[62]=a("를 참조하십시오."))])])}}};export{k as default};
