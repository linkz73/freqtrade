import{r as t,o,c as i,a as n,b as e,d as a,e as l,w as c}from"./index-f254d819.js";const d={class:"md-content__inner md-typeset"},m={__name:"Developer",setup(r){return(h,s)=>{const p=t("router-link");return o(),i("article",d,[s[6]||(s[6]=n('<h1 id="development-help"> 개발 도움말 <a class="headerlink" href="#development-help" title="영구 링크"> ¶ </a></h1><p>이 페이지는 Freqtrade의 개발자, 코드베이스 또는 문서에 기여하고자 하는 사람들, 또는 실행 중인 애플리케이션의 소스 코드를 이해하고자 하는 사람들을 위한 것입니다.</p><p> 모든 기여, 버그 보고, 버그 수정, 문서 개선, 기능 향상 및 아이디어를 환영합니다. 우리는 <a href="https://github.com/freqtrade/freqtrade/issues"> GitHub에서 이슈를 추적 </a> 하며, 질문을 할 수 있는 <a href="https://discord.gg/p7nuUNVfP7"> Discord 개발 채널 </a> 도 운영하고 있습니다. </p><h2 id="documentation"> 문서화 <a class="headerlink" href="#documentation" title="영구 링크"> ¶ </a></h2>',4)),e("p",null,[s[1]||(s[1]=a(" 문서는 ")),l(p,{to:"/"},{default:c(()=>s[0]||(s[0]=[a(" https://freqtrade.io ")])),_:1}),s[2]||(s[2]=a(" 에서 확인할 수 있으며, 새로운 기능 PR에는 반드시 문서가 포함되어야 합니다. "))]),s[7]||(s[7]=n(`<p> 문서에 사용할 수 있는 특별한 필드(예: 주의 상자 등)는 <a href="https://squidfunk.github.io/mkdocs-material/reference/admonitions/"> 여기 </a> 에서 확인할 수 있습니다. </p><p>로컬에서 문서를 테스트하려면 다음 명령어를 사용하세요.</p><div class="highlight"><pre><code>pip<span class="w"> </span>install<span class="w"> </span>-r<span class="w"> </span>docs/requirements-docs.txt
mkdocs<span class="w"> </span>serve
</code></pre></div><p>이 명령어는 로컬 서버(보통 포트 8000)를 실행하여 문서가 원하는 대로 표시되는지 확인할 수 있습니다.</p><h2 id="developer-setup"> 개발자 설정 <a class="headerlink" href="#developer-setup" title="영구 링크"> ¶ </a></h2><p> 개발 환경을 설정하려면 제공된 <a href="#devcontainer-setup"> DevContainer </a> 를 사용하거나 <code> setup.sh </code> 스크립트를 실행하고 &quot;개발 의존성을 설치하시겠습니까? [y/N]&quot; 질문에 &quot;y&quot;로 답하세요. 또는 (시스템이 setup.sh 스크립트를 지원하지 않는 경우) 수동 설치 과정을 따르고 <code> pip3 install -r requirements-dev.txt </code> 명령어를 실행한 후 <code> pip3 install -e .[all] </code> 명령어를 실행하세요. </p><p> 이 과정은 <code> pytest </code> , <code> ruff </code> , <code> mypy </code> , <code> coveralls </code> 등 개발에 필요한 모든 도구를 설치합니다. </p><p> 그런 다음 <code> pre-commit install </code> 명령어를 실행하여 Git 훅 스크립트를 설치하세요. 이를 통해 변경 사항이 커밋되기 전에 로컬에서 검증됩니다. 이는 기본적인 포맷팅 검사가 로컬에서 수행되므로 CI 대기 시간을 줄이는 데 도움이 됩니다. </p><p> Pull Request를 열기 전에 <a href="https://github.com/freqtrade/freqtrade/blob/develop/CONTRIBUTING.md"> 기여 가이드라인 </a> 을 숙지하시기 바랍니다. </p><h3 id="devcontainer-setup"> Devcontainer 설정 <a class="headerlink" href="#devcontainer-setup" title="영구 링크"> ¶ </a></h3><p> 가장 빠르고 쉬운 시작 방법은 <a href="https://code.visualstudio.com/"> VSCode </a> 와 원격 컨테이너 확장을 사용하는 것입니다. 이를 통해 개발자는 로컬 머신에 Freqtrade 특정 종속성을 설치하지 않고도 모든 필요한 종속성을 갖춘 상태로 봇을 시작할 수 있습니다. </p><h4 id="devcontainer-dependencies"> Devcontainer 종속성 <a class="headerlink" href="#devcontainer-dependencies" title="영구 링크"> ¶ </a></h4><ul><li><a href="https://code.visualstudio.com/"> VSCode </a></li><li><a href="https://docs.docker.com/install/"> docker </a></li><li><a href="https://code.visualstudio.com/docs/remote"> 원격 컨테이너 확장 문서 </a></li></ul><p> 원격 컨테이너 확장에 대한 자세한 내용은 <a href="https://code.visualstudio.com/docs/remote"> 문서 </a> 를 참조하세요. </p><h3 id="tests"> 테스트 <a class="headerlink" href="#tests" title="영구 링크"> ¶ </a></h3><p>새로운 코드는 기본적인 단위 테스트로 커버되어야 합니다. 기능의 복잡성에 따라 리뷰어는 더 심층적인 단위 테스트를 요청할 수 있습니다. 필요한 경우 Freqtrade 팀이 좋은 테스트 작성에 대한 지침을 제공할 수 있습니다 (그러나 테스트를 대신 작성해 줄 것으로 기대하지 마세요).</p><h4 id="how-to-run-tests"> 테스트 실행 방법 <a class="headerlink" href="#how-to-run-tests" title="영구 링크"> ¶ </a></h4><p> 루트 폴더에서 <code> pytest </code> 를 사용하여 모든 사용 가능한 테스트 케이스를 실행하고 로컬 환경이 올바르게 설정되었는지 확인하세요. </p><div class="admonition note"><p class="admonition-title">기능 브랜치</p><p> 테스트는 <code> develop </code> 및 <code> stable </code> 브랜치에서 통과해야 합니다. 다른 브랜치는 아직 테스트가 작동하지 않는 작업 중일 수 있습니다. </p></div><h4 id="checking-log-content-in-tests"> 테스트에서 로그 내용 확인 <a class="headerlink" href="#checking-log-content-in-tests" title="영구 링크"> ¶ </a></h4><p> Freqtrade는 테스트에서 로그 내용을 확인하기 위해 두 가지 주요 방법, <code> log_has() </code> 와 <code> log_has_re() </code> (동적 로그 메시지의 경우 정규식을 사용하여 확인)를 사용합니다. 이들은 <code> conftest.py </code> 에서 사용할 수 있으며, 모든 테스트 모듈에서 가져올 수 있습니다. </p><p>샘플 확인은 다음과 같습니다:</p><div class="highlight"><pre><code><span class="kn">from</span><span class="w"> </span><span class="nn">tests.conftest</span><span class="w"> </span><span class="kn">import</span> <span class="n">log_has</span><span class="p">,</span> <span class="n">log_has_re</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_method_to_test</span><span class="p">(</span><span class="n">caplog</span><span class="p">):</span>
    <span class="n">method_to_test</span><span class="p">()</span>

    <span class="k">assert</span> <span class="n">log_has</span><span class="p">(</span><span class="s2">&quot;This event happened&quot;</span><span class="p">,</span> <span class="n">caplog</span><span class="p">)</span>
    <span class="c1"># Check regex with trailing number ...</span>
    <span class="k">assert</span> <span class="n">log_has_re</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;This dynamic event happened and produced \\d+&quot;</span><span class="p">,</span> <span class="n">caplog</span><span class="p">)</span>
</code></pre></div><h3 id="debug-configuration"> 디버그 구성 <a class="headerlink" href="#debug-configuration" title="영구 링크"> ¶ </a></h3><p> Freqtrade를 디버그하려면 Python 확장이 포함된 VSCode를 사용하는 것이 좋습니다. 다음 실행 구성을 사용하세요 ( <code> .vscode/launch.json </code> 에 위치). 세부 사항은 설정에 따라 다를 수 있지만, 시작하는 데 도움이 될 것입니다. </p><div class="highlight"><pre><code><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;freqtrade trade&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;debugpy&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;request&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;launch&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;module&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;freqtrade&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;console&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;integratedTerminal&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;args&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">        </span><span class="s2">&quot;trade&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="c1">// Optional:</span>
<span class="w">        </span><span class="c1">// &quot;--userdir&quot;, &quot;user_data&quot;,</span>
<span class="w">        </span><span class="s2">&quot;--strategy&quot;</span><span class="p">,</span><span class="w"> </span>
<span class="w">        </span><span class="s2">&quot;MyAwesomeStrategy&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">]</span>
<span class="p">},</span>
</code></pre></div><p> 명령줄 인수는 <code> &quot;args&quot; </code> 배열에 추가할 수 있습니다. 이 방법은 전략을 디버그하는 데도 사용할 수 있으며, 전략 내에서 중단점을 설정할 수 있습니다. </p><p> Pycharm에서도 유사한 설정을 사용할 수 있으며, 모듈 이름으로 <code> freqtrade </code> 를 사용하고 명령줄 인수를 &quot;매개변수&quot;로 설정합니다. </p><details class="tip"><summary>올바른 venv 사용</summary><p>가상 환경을 사용할 때(사용해야 함), 편집기가 올바른 가상 환경을 사용하고 있는지 확인하여 문제나 &quot;알 수 없는 가져오기&quot; 오류를 방지하세요.</p><h4 id="vscode"> Vscode <a class="headerlink" href="#vscode" title="영구 링크"> ¶ </a></h4><p>VSCode에서 &quot;Python: Select Interpreter&quot; 명령을 사용하여 올바른 환경을 선택할 수 있습니다. 확장이 감지한 환경을 보여줍니다. 환경이 감지되지 않은 경우 경로를 수동으로 선택할 수도 있습니다.</p><h4 id="pycharm"> Pycharm <a class="headerlink" href="#pycharm" title="영구 링크"> ¶ </a></h4><p>Pycharm에서는 &quot;실행/디버그 구성&quot; 창에서 적절한 환경을 선택할 수 있습니다.</p></details><div class="admonition note"><p class="admonition-title">시작 디렉토리</p><p>이 설정은 저장소를 체크아웃하고 편집기를 저장소 루트 레벨에서 시작한 것으로 가정합니다(따라서 pyproject.toml이 저장소의 최상위 레벨에 있어야 합니다).</p></div><h2 id="errorhandling"> 오류 처리 <a class="headerlink" href="#errorhandling" title="영구 링크"> ¶ </a></h2><p> Freqtrade 예외는 모두 <code> FreqtradeException </code> 에서 상속됩니다. 이 일반적인 오류 클래스는 직접 사용해서는 안 됩니다. 대신 여러 가지 특수한 하위 예외가 존재합니다. </p><p>아래는 예외 상속 계층 구조의 개요입니다:</p><div class="highlight"><pre><code>+ FreqtradeException
|
+---+ OperationalException
|   |
|   +---+ ConfigurationError
|
+---+ DependencyException
|   |
|   +---+ PricingError
|   |
|   +---+ ExchangeError
|       |
|       +---+ TemporaryError
|       |
|       +---+ DDosProtection
|       |
|       +---+ InvalidOrderException
|           |
|           +---+ RetryableOrderError
|           |
|           +---+ InsufficientFundsError
|
+---+ StrategyError
</code></pre></div><hr><h2 id="plugins"> 플러그인 <a class="headerlink" href="#plugins" title="영구 링크"> ¶ </a></h2><h3 id="pairlists"> 페어리스트 <a class="headerlink" href="#pairlists" title="영구 링크"> ¶ </a></h3><p>새로운 페어 선택 알고리즘에 대한 멋진 아이디어가 있습니까? 훌륭합니다. 아마도 이 아이디어를 업스트림에 기여하고 싶을 것입니다.</p><p>동기가 무엇이든 간에, 새로운 페어리스트 핸들러를 개발하는 데 도움이 될 것입니다.</p><p> 먼저 <a href="https://github.com/freqtrade/freqtrade/blob/develop/freqtrade/plugins/pairlist/VolumePairList.py"> VolumePairList </a> 핸들러를 살펴보고, 이 파일을 새로운 페어리스트 핸들러의 이름으로 복사하세요. </p><p>이것은 간단한 핸들러이지만, 시작하는 데 좋은 예가 됩니다.</p><p>다음으로 핸들러의 클래스 이름을 수정하세요(이름을 모듈 파일 이름과 일치시키는 것이 좋습니다).</p><p> 기본 클래스는 거래소의 인스턴스( <code> self._exchange </code> ), 페어리스트 관리자( <code> self._pairlistmanager </code> ), 주요 구성( <code> self._config </code> ), 페어리스트 전용 구성( <code> self._pairlistconfig </code> ) 및 페어리스트 목록 내의 절대 위치를 제공합니다. </p><div class="highlight"><pre><code>        <span class="bp">self</span><span class="o">.</span><span class="n">_exchange</span> <span class="o">=</span> <span class="n">exchange</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pairlistmanager</span> <span class="o">=</span> <span class="n">pairlistmanager</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_config</span> <span class="o">=</span> <span class="n">config</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pairlistconfig</span> <span class="o">=</span> <span class="n">pairlistconfig</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pairlist_pos</span> <span class="o">=</span> <span class="n">pairlist_pos</span>
</code></pre></div><div class="admonition tip"><p class="admonition-title">팁</p><p> 페어리스트를 <code> constants.py </code> 의 <code> AVAILABLE_PAIRLISTS </code> 변수에 등록하는 것을 잊지 마세요. 그렇지 않으면 선택할 수 없습니다. </p></div><p>이제 작업이 필요한 메서드를 살펴보겠습니다:</p><h4 id="pairlist-configuration"> 페어리스트 구성 <a class="headerlink" href="#pairlist-configuration" title="영구 링크"> ¶ </a></h4><p> 페어리스트 핸들러 체인의 구성은 봇 구성 파일의 <code> &quot;pairlists&quot; </code> 요소에서 수행됩니다. 이는 체인의 각 페어리스트 핸들러에 대한 구성 매개변수 배열입니다. </p><p> 관례에 따라 <code> &quot;number_assets&quot; </code> 는 페어리스트에 유지할 최대 페어 수를 지정하는 데 사용됩니다. 일관된 사용자 경험을 위해 이를 따르세요. </p><p> 필요에 따라 추가 매개변수를 구성할 수 있습니다. 예를 들어, <code> VolumePairList </code> 는 정렬 값을 지정하기 위해 <code> &quot;sort_key&quot; </code> 를 사용하지만, 훌륭한 알고리즘이 성공적이고 동적이 되기 위해 필요한 모든 것을 지정할 수 있습니다. </p><h4 id="short_desc"> short_desc <a class="headerlink" href="#short_desc" title="영구 링크"> ¶ </a></h4><p>Telegram 메시지에 사용되는 설명을 반환합니다.</p><p> 이 설명에는 페어리스트 핸들러의 이름과 자산 수를 포함하는 짧은 설명이 포함되어야 합니다. 다음 형식을 따르세요: <code> &quot;PairlistName - top/bottom X pairs&quot; </code> . </p><h4 id="gen_pairlist"> gen_pairlist <a class="headerlink" href="#gen_pairlist" title="영구 링크"> ¶ </a></h4><p> 페어리스트 핸들러가 체인의 선도 페어리스트 핸들러로 사용될 수 있는 경우 이 메서드를 재정의하여 초기 페어리스트를 정의합니다. 이 페어리스트는 체인의 모든 페어리스트 핸들러에 의해 처리됩니다. 예로는 <code> StaticPairList </code> 와 <code> VolumePairList </code> 가 있습니다. </p><p>이 메서드는 봇의 각 반복 시 호출됩니다(페어리스트 핸들러가 첫 번째 위치에 있는 경우에만). 따라서 계산/네트워크가 무거운 계산에 대해 캐싱을 구현하는 것을 고려하세요.</p><p>반환된 결과 페어리스트를 반환해야 합니다(그런 다음 페어리스트 핸들러 체인에 전달될 수 있음).</p><p> 유효성 검사는 선택 사항이며, 기본 클래스는 <code> verify_blacklist(pairlist) </code> 및 <code> _whitelist_for_active_markets(pairlist) </code> 를 사용하여 기본 필터링을 수행합니다. 결과를 특정 페어 수로 제한하는 경우 이 메서드를 사용하여 최종 결과가 예상보다 짧지 않도록 하세요. </p><h4 id="filter_pairlist"> filter_pairlist <a class="headerlink" href="#filter_pairlist" title="영구 링크"> ¶ </a></h4><p>이 메서드는 페어리스트 관리자가 체인의 각 페어리스트 핸들러에 대해 호출합니다.</p><p>이 메서드는 봇의 각 반복 시 호출됩니다. 따라서 계산/네트워크가 무거운 계산에 대해 캐싱을 구현하는 것을 고려하세요.</p><p> 이 메서드는 페어리스트(이전 페어리스트의 결과일 수 있음)와 <code> tickers </code> (사전 가져온 <code> get_tickers() </code> 버전)를 전달받습니다. </p><p> 기본 클래스의 기본 구현은 단순히 페어리스트의 각 페어에 대해 <code> _validate_pair() </code> 메서드를 호출하지만, 이를 재정의할 수 있습니다. 따라서 페어리스트 핸들러에서 <code> _validate_pair() </code> 를 구현하거나 <code> filter_pairlist() </code> 를 재정의하여 다른 작업을 수행해야 합니다. </p><p>재정의된 경우, 결과 페어리스트를 반환해야 합니다(그런 다음 체인의 다음 페어리스트 핸들러에 전달될 수 있음).</p><p> 유효성 검사는 선택 사항이며, 기본 클래스는 <code> verify_blacklist(pairlist) </code> 및 <code> _whitelist_for_active_markets(pairlist) </code> 를 사용하여 기본 필터를 수행합니다. 결과를 특정 페어 수로 제한하는 경우 이 메서드를 사용하여 최종 결과가 예상보다 짧지 않도록 하세요. </p><p><code> VolumePairList </code> 에서는 다양한 정렬 방법을 구현하고, 예상 페어 수만 반환되도록 조기 유효성 검사를 수행합니다. </p><h5 id="sample"> 샘플 <a class="headerlink" href="#sample" title="영구 링크"> ¶ </a></h5><div class="highlight"><pre><code>    <span class="k">def</span><span class="w"> </span><span class="nf">filter_pairlist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pairlist</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">tickers</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="c1"># Generate dynamic whitelist</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_pairlist</span><span class="p">(</span><span class="n">pairlist</span><span class="p">,</span> <span class="n">tickers</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pairs</span>
</code></pre></div><h3 id="protections"> 보호 <a class="headerlink" href="#protections" title="영구 링크"> ¶ </a></h3>`,69)),e("p",null,[s[4]||(s[4]=a(" 보호에 대해 이해하려면 ")),l(p,{to:"plugins"},{default:c(()=>s[3]||(s[3]=[a(" 보호 문서 ")])),_:1}),s[5]||(s[5]=a(" 를 읽어보세요. 이 가이드는 새로운 보호 기능을 개발하려는 개발자를 위한 것입니다. "))]),s[8]||(s[8]=n(`<p> 어떤 보호 기능도 datetime을 직접 사용해서는 안 되며, 날짜 계산을 위해 제공된 <code> date_now </code> 변수를 사용해야 합니다. 이를 통해 보호 기능을 백테스트할 수 있습니다. </p><div class="admonition tip"><p class="admonition-title">새로운 보호 기능 작성</p><p>기존 보호 기능 중 하나를 복사하여 좋은 예를 얻는 것이 좋습니다.</p></div><h4 id="implementation-of-a-new-protection"> 새로운 보호 기능 구현 <a class="headerlink" href="#implementation-of-a-new-protection" title="영구 링크"> ¶ </a></h4><p> 모든 보호 기능 구현은 <code> IProtection </code> 을 부모 클래스로 가져야 합니다. 따라서 다음 메서드를 구현해야 합니다: </p><ul><li><code> short_desc() </code></li><li><code> global_stop() </code></li><li><code> stop_per_pair() </code> . </li></ul><p><code> global_stop() </code> 및 <code> stop_per_pair() </code> 는 ProtectionReturn 객체를 반환해야 합니다. 이 객체는 다음으로 구성됩니다: </p><ul><li>잠금 페어 - boolean</li><li>잠금 해제 시간 - datetime - 페어가 잠금 해제될 시간(다음 새로운 캔들로 반올림됨)</li><li>이유 - 문자열, 로깅 및 데이터베이스 저장에 사용됨</li><li>잠금 측면 - long, short 또는 &#39;*&#39;.</li></ul><p><code> until </code> 부분은 제공된 <code> calculate_lock_end() </code> 메서드를 사용하여 계산해야 합니다. </p><p> 모든 보호 기능은 페어(또는 모든 페어)를 잠그는 기간을 정의하기 위해 <code> &quot;stop_duration&quot; </code> / <code> &quot;stop_duration_candles&quot; </code> 를 사용해야 합니다. 이 내용은 각 보호 기능에 <code> self._stop_duration </code> 으로 제공됩니다. </p><p> 보호 기능이 조회 기간이 필요한 경우, <code> &quot;lookback_period&quot; </code> / <code> &quot;lockback_period_candles&quot; </code> 를 사용하여 모든 보호 기능을 정렬하세요. </p><h4 id="global-vs-local-stops"> 전역 대 로컬 중지 <a class="headerlink" href="#global-vs-local-stops" title="영구 링크"> ¶ </a></h4><p>보호 기능은 제한된 시간 동안 거래를 중지하는 두 가지 방법을 가질 수 있습니다:</p><ul><li>페어별(로컬)</li><li>모든 페어에 대해(전역)</li></ul><h5 id="protections-per-pair"> 보호 기능 - 페어별 <a class="headerlink" href="#protections-per-pair" title="영구 링크"> ¶ </a></h5><p> 페어별 접근 방식을 구현하는 보호 기능은 <code> has_local_stop=True </code> 로 설정해야 합니다. <code> stop_per_pair() </code> 메서드는 거래가 종료될 때마다(종료 주문 완료) 호출됩니다. </p><h5 id="protections-global-protection"> 보호 기능 - 전역 보호 <a class="headerlink" href="#protections-global-protection" title="영구 링크"> ¶ </a></h5><p> 이러한 보호 기능은 모든 페어에 대해 평가를 수행해야 하며, 결과적으로 모든 페어의 거래를 잠그는 전역 페어 잠금을 수행합니다. 전역 보호 기능은 전역 중지에 대해 평가되도록 <code> has_global_stop=True </code> 로 설정해야 합니다. <code> global_stop() </code> 메서드는 거래가 종료될 때마다(종료 주문 완료) 호출됩니다. </p><h5 id="protections-calculating-lock-end-time"> 보호 기능 - 잠금 종료 시간 계산 <a class="headerlink" href="#protections-calculating-lock-end-time" title="영구 링크"> ¶ </a></h5><p>보호 기능은 고려하는 마지막 거래를 기준으로 잠금 종료 시간을 계산해야 합니다. 이렇게 하면 조회 기간이 실제 잠금 기간보다 길 경우 다시 잠기는 것을 방지할 수 있습니다.</p><p><code> IProtection </code> 부모 클래스는 <code> calculate_lock_end() </code> 에서 이를 위한 도우미 메서드를 제공합니다. </p><hr><h2 id="implement-a-new-exchange-wip"> 새로운 거래소 구현 (작업 중) <a class="headerlink" href="#implement-a-new-exchange-wip" title="영구 링크"> ¶ </a></h2><div class="admonition note"><p class="admonition-title">참고</p><p>이 섹션은 작업 중이며, Freqtrade에서 새로운 거래소를 테스트하는 방법에 대한 완전한 가이드가 아닙니다.</p></div><div class="admonition note"><p class="admonition-title">참고</p><p> 아래 테스트를 실행하기 전에 최신 버전의 CCXT를 사용하고 있는지 확인하세요. 가상 환경이 활성화된 상태에서 <code> pip install -U ccxt </code> 명령어를 실행하여 최신 버전의 ccxt를 얻을 수 있습니다. 네이티브 도커는 이러한 테스트를 지원하지 않지만, 사용 가능한 dev-container는 필요한 모든 작업과 필요한 변경 사항을 지원합니다. </p></div><p>CCXT에서 지원하는 대부분의 거래소는 기본적으로 작동해야 합니다.</p><p> 거래소의 공개 엔드포인트를 빠르게 테스트하려면 <code> tests/exchange_online/conftest.py </code> 에 거래소 구성을 추가하고 <code> pytest --longrun tests/exchange_online/test_ccxt_compat.py </code> 명령어로 이러한 테스트를 실행하세요. 이러한 테스트를 성공적으로 완료하면 좋은 출발점이 됩니다(사실 필수 사항입니다). 그러나 이는 공개 엔드포인트만 테스트하며, 주문 생성과 같은 비공개 엔드포인트는 테스트하지 않습니다. </p><p> 또한 <code> freqtrade download-data </code> 명령어를 사용하여 확장된 시간 범위(여러 달)에 대해 데이터를 다운로드하고 데이터가 올바르게 다운로드되었는지 확인하세요(구멍이 없고, 지정된 시간 범위가 실제로 다운로드되었는지 확인). </p><p>이러한 테스트는 거래소가 지원되거나 커뮤니티에서 테스트된 것으로 나열되기 위한 전제 조건입니다(홈페이지에 나열됨). 아래는 거래소를 더 나은(기능이 완전한) 상태로 만들기 위한 &quot;추가&quot; 작업이지만, 두 가지 범주 중 하나에 속하기 위해 절대적으로 필요한 것은 아닙니다.</p><p>추가 테스트 / 완료해야 할 단계:</p><ul><li><code> fetch_ohlcv() </code> 에서 제공하는 데이터를 확인하고, 필요한 경우 이 거래소에 대해 <code> ohlcv_candle_limit </code> 을 조정하세요. </li><li>L2 주문서 제한 범위(API 문서)를 확인하고, 필요한 경우 설정하세요.</li><li>잔액이 올바르게 표시되는지 확인하세요(*)</li><li>시장 주문을 생성하세요(*)</li><li>지정가 주문을 생성하세요(*)</li><li>주문을 취소하세요(*)</li><li> 거래를 완료하세요(진입 + 종료)(*) <ul><li>거래소와 봇 간의 결과 계산을 비교하세요.</li><li>수수료가 올바르게 적용되었는지 확인하세요(거래소와 데이터베이스를 비교).</li></ul></li></ul><p>(*) API 키와 거래소의 잔액이 필요합니다.</p><h3 id="stoploss-on-exchange"> 거래소에서의 손절매 <a class="headerlink" href="#stoploss-on-exchange" title="영구 링크"> ¶ </a></h3><p>새로운 거래소가 API를 통해 거래소에서의 손절매 주문을 지원하는지 확인하세요.</p><p> CCXT는 아직 거래소에서의 손절매에 대한 통합을 제공하지 않으므로, 거래소별 매개변수를 직접 구현해야 합니다. 이 작업의 예로 <code> binance.py </code> 를 참조하세요. 거래소의 API 문서를 통해 이를 수행하는 방법을 찾아야 합니다. <a href="https://github.com/ccxt/ccxt/issues"> CCXT 이슈 </a> 도 유용한 도움을 제공할 수 있으며, 다른 사람들이 프로젝트를 위해 유사한 작업을 구현했을 수 있습니다. </p><h3 id="incomplete-candles"> 불완전한 캔들 <a class="headerlink" href="#incomplete-candles" title="영구 링크"> ¶ </a></h3><p> 캔들(OHLCV) 데이터를 가져오는 동안 거래소에 따라 불완전한 캔들을 얻을 수 있습니다. 이를 설명하기 위해 일일 캔들( <code> &quot;1d&quot; </code> )을 사용하여 간단하게 유지하겠습니다. API( <code> ct.fetch_ohlcv() </code> )를 사용하여 시간 프레임을 쿼리하고 마지막 항목의 날짜를 확인합니다. 이 항목이 변경되거나 &quot;불완전한&quot; 캔들의 날짜를 표시하면 이를 삭제해야 합니다. 불완전한 캔들은 지표가 완전한 캔들만 전달된다고 가정하고 많은 잘못된 매수 신호를 생성하기 때문에 문제가 됩니다. 기본적으로 마지막 캔들을 불완전한 것으로 가정하고 삭제합니다. </p><p>새로운 거래소가 어떻게 동작하는지 확인하려면 다음 스니펫을 사용할 수 있습니다:</p><div class="highlight"><pre><code><span class="kn">import</span><span class="w"> </span><span class="nn">ccxt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timezone</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">freqtrade.data.converter</span><span class="w"> </span><span class="kn">import</span> <span class="n">ohlcv_to_dataframe</span>
<span class="n">ct</span> <span class="o">=</span> <span class="n">ccxt</span><span class="o">.</span><span class="n">binance</span><span class="p">()</span>  <span class="c1"># Use the exchange you&#39;re testing</span>
<span class="n">timeframe</span> <span class="o">=</span> <span class="s2">&quot;1d&quot;</span>
<span class="n">pair</span> <span class="o">=</span> <span class="s2">&quot;BTC/USDT&quot;</span>  <span class="c1"># Make sure to use a pair that exists on that exchange!</span>
<span class="n">raw</span> <span class="o">=</span> <span class="n">ct</span><span class="o">.</span><span class="n">fetch_ohlcv</span><span class="p">(</span><span class="n">pair</span><span class="p">,</span> <span class="n">timeframe</span><span class="o">=</span><span class="n">timeframe</span><span class="p">)</span>

<span class="c1"># convert to dataframe</span>
<span class="n">df1</span> <span class="o">=</span> <span class="n">ohlcv_to_dataframe</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span> <span class="n">timeframe</span><span class="p">,</span> <span class="n">pair</span><span class="o">=</span><span class="n">pair</span><span class="p">,</span> <span class="n">drop_incomplete</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">df1</span><span class="o">.</span><span class="n">tail</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">(</span><span class="n">timezone</span><span class="o">.</span><span class="n">utc</span><span class="p">))</span>
</code></pre></div><div class="highlight"><pre><code><span class="go">                         date      open      high       low     close  volume  </span>
<span class="go">499 2019-06-08 00:00:00+00:00  0.000007  0.000007  0.000007  0.000007   26264344.0  </span>
<span class="go">2019-06-09 12:30:27.873327</span>
</code></pre></div><p> 출력은 거래소에서 마지막 항목과 현재 UTC 날짜를 보여줍니다. 날짜가 동일한 날을 표시하면 마지막 캔들은 불완전한 것으로 간주하고 삭제해야 합니다( <code> &quot;ohlcv_partial_candle&quot; </code> 설정을 변경하지 않음 / True로 유지). 그렇지 않으면 <code> &quot;ohlcv_partial_candle&quot; </code> 을 <code> False </code> 로 설정하여 캔들을 삭제하지 않도록 설정합니다(위의 예에서 보여줌). 또 다른 방법은 이 명령을 여러 번 연속으로 실행하고 볼륨이 변경되는지(날짜는 동일하게 유지) 관찰하는 것입니다. </p><h3 id="update-binance-cached-leverage-tiers"> 바이낸스 캐시된 레버리지 티어 업데이트 <a class="headerlink" href="#update-binance-cached-leverage-tiers" title="영구 링크"> ¶ </a></h3><p>레버리지 티어 업데이트는 정기적으로 수행해야 하며, 선물이 활성화된 인증된 계정이 필요합니다.</p><div class="highlight"><pre><code><span class="kn">import</span><span class="w"> </span><span class="nn">ccxt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>

<span class="n">exchange</span> <span class="o">=</span> <span class="n">ccxt</span><span class="o">.</span><span class="n">binance</span><span class="p">({</span>
    <span class="s1">&#39;apiKey&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;apikey&gt;&#39;</span><span class="p">,</span>
    <span class="s1">&#39;secret&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;secret&gt;&#39;</span><span class="p">,</span>
    <span class="s1">&#39;options&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;defaultType&#39;</span><span class="p">:</span> <span class="s1">&#39;swap&#39;</span><span class="p">}</span>
    <span class="p">})</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">exchange</span><span class="o">.</span><span class="n">load_markets</span><span class="p">()</span>

<span class="n">lev_tiers</span> <span class="o">=</span> <span class="n">exchange</span><span class="o">.</span><span class="n">fetch_leverage_tiers</span><span class="p">()</span>

<span class="c1"># Assumes this is running in the root of the repository.</span>
<span class="n">file</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s1">&#39;freqtrade/exchange/binance_leverage_tiers.json&#39;</span><span class="p">)</span>
<span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">lev_tiers</span><span class="o">.</span><span class="n">items</span><span class="p">())),</span> <span class="n">file</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">),</span> <span class="n">indent</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div><p>이 파일은 업스트림에 기여하여 다른 사람들이 이 혜택을 누릴 수 있도록 해야 합니다.</p><h2 id="updating-example-notebooks"> 예제 노트북 업데이트 <a class="headerlink" href="#updating-example-notebooks" title="영구 링크"> ¶ </a></h2><p>예제 노트북을 문서와 일치시키기 위해 예제 노트북을 업데이트한 후 다음 명령어를 실행해야 합니다.</p><div class="highlight"><pre><code>jupyter<span class="w"> </span>nbconvert<span class="w"> </span>--ClearOutputPreprocessor.enabled<span class="o">=</span>True<span class="w"> </span>--inplace<span class="w"> </span>freqtrade/templates/strategy_analysis_example.ipynb
jupyter<span class="w"> </span>nbconvert<span class="w"> </span>--ClearOutputPreprocessor.enabled<span class="o">=</span>True<span class="w"> </span>--to<span class="w"> </span>markdown<span class="w"> </span>freqtrade/templates/strategy_analysis_example.ipynb<span class="w"> </span>--stdout<span class="w"> </span>&gt;<span class="w"> </span>docs/strategy_analysis_example.md
</code></pre></div><h2 id="continuous-integration"> 지속적 통합 <a class="headerlink" href="#continuous-integration" title="영구 링크"> ¶ </a></h2><p>이 문서는 CI 파이프라인에 대한 몇 가지 결정을 문서화합니다.</p><ul><li>CI는 모든 OS 변형, Linux(ubuntu), macOS 및 Windows에서 실행됩니다.</li><li> 도커 이미지는 <code> stable </code> 및 <code> develop </code> 브랜치에 대해 빌드되며, 동일한 태그를 통해 여러 플랫폼을 지원하는 다중 아키텍처 빌드로 빌드됩니다. </li><li> 도커 이미지는 플롯 종속성을 포함하는 <code> stable_plot </code> 및 <code> develop_plot </code> 로도 제공됩니다. </li><li> 도커 이미지에는 이 이미지가 기반한 커밋을 포함하는 <code> /freqtrade/freqtrade_commit </code> 파일이 포함되어 있습니다. </li><li>전체 도커 이미지 재빌드는 일정에 따라 주 1회 실행됩니다.</li><li>배포는 ubuntu에서 실행됩니다.</li><li>ta-lib 바이너리는 외부 가용성 관련 실패를 방지하기 위해 build_helpers 디렉토리에 포함되어 있습니다.</li><li> 모든 테스트는 <code> stable </code> 또는 <code> develop </code> 에 병합되기 전에 통과해야 합니다. </li></ul><h2 id="creating-a-release"> 릴리스 생성 <a class="headerlink" href="#creating-a-release" title="영구 링크"> ¶ </a></h2><p>이 문서의 일부는 유지 관리자를 대상으로 하며, 릴리스를 생성하는 방법을 보여줍니다.</p><h3 id="create-release-branch"> 릴리스 브랜치 생성 <a class="headerlink" href="#create-release-branch" title="영구 링크"> ¶ </a></h3><div class="admonition note"><p class="admonition-title">참고</p><p><code> stable </code> 브랜치가 최신 상태인지 확인하세요! </p></div><p>먼저 약 일주일 된 커밋을 선택하세요(최신 추가 사항을 릴리스에 포함하지 않음).</p><div class="highlight"><pre><code><span class="c1"># create new branch</span>
git<span class="w"> </span>checkout<span class="w"> </span>-b<span class="w"> </span>new_release<span class="w"> </span>&lt;commitid&gt;
</code></pre></div><p>이 커밋과 현재 상태 사이에 중요한 버그 수정이 있는지 확인하고, 필요한 경우 이를 체리픽하세요.</p><ul><li>릴리스 브랜치(stable)를 이 브랜치에 병합합니다.</li><li><code> freqtrade/__init__.py </code> 를 편집하고 현재 날짜와 일치하는 버전을 추가합니다(예: <code> 2019.7 </code> 은 2019년 7월을 의미). 소수 버전은 해당 월에 두 번째 릴리스가 필요한 경우 <code> 2019.7.1 </code> 이 될 수 있습니다. 버전 번호는 pypi에 푸시할 때 실패를 방지하기 위해 PEP0440에서 허용된 버전을 따라야 합니다. </li><li>이 부분을 커밋합니다.</li><li> 해당 브랜치를 원격으로 푸시하고 <strong> stable 브랜치 </strong> 에 대한 PR을 생성합니다. </li><li> 다음 패턴을 따르는 다음 버전으로 개발 버전을 업데이트합니다: <code> 2019.8-dev </code> . </li></ul><h3 id="create-changelog-from-git-commits"> Git 커밋에서 변경 로그 생성 <a class="headerlink" href="#create-changelog-from-git-commits" title="영구 링크"> ¶ </a></h3><div class="highlight"><pre><code><span class="c1"># Needs to be done before merging / pulling that branch.</span>
git<span class="w"> </span>log<span class="w"> </span>--oneline<span class="w"> </span>--no-decorate<span class="w"> </span>--no-merges<span class="w"> </span>stable..new_release
</code></pre></div><p>릴리스 로그를 짧게 유지하려면 전체 git 변경 로그를 접을 수 있는 세부 섹션에 래핑하는 것이 좋습니다.</p><div class="highlight"><pre><code>&lt;details&gt;
&lt;summary&gt;Expand full changelog&lt;/summary&gt;

... Full git changelog

&lt;/details&gt;
</code></pre></div><h3 id="frequi-release"> FreqUI 릴리스 <a class="headerlink" href="#frequi-release" title="영구 링크"> ¶ </a></h3><p>FreqUI가 크게 업데이트된 경우 릴리스 브랜치를 병합하기 전에 릴리스를 생성해야 합니다. 릴리스를 병합하기 전에 FreqUI CI가 완료되고 통과했는지 확인하세요.</p><h3 id="create-github-release-tag"> Github 릴리스 / 태그 생성 <a class="headerlink" href="#create-github-release-tag" title="영구 링크"> ¶ </a></h3><p>stable에 대한 PR이 병합된 후(병합 직후가 가장 좋음):</p><ul><li>Github UI(릴리스 하위 섹션)에서 &quot;Draft a new release&quot; 버튼을 사용합니다.</li><li>태그로 버전 번호를 사용합니다.</li><li>참조로 &quot;stable&quot;을 사용합니다(이 단계는 위의 PR이 병합된 후에 수행됨).</li><li>릴리스 주석으로 위의 변경 로그를 사용합니다(코드 블록으로).</li><li>새 릴리스에 대한 아래 스니펫을 사용합니다.</li></ul><details class="tip"><summary>릴리스 템플릿</summary><div class="highlight"><pre><code>## 주요 변경 사항

- ...

### 업데이트 방법

항상 그렇듯이 다음 명령어 중 하나를 사용하여 봇을 업데이트할 수 있습니다:

#### docker-compose

\`\`\`bash
docker-compose pull
docker-compose up -d
\`\`\`

#### setup 스크립트를 통한 설치

\`\`\`
# Deactivate venv and run 
./setup.sh --update
\`\`\`

#### 일반 네이티브 설치

\`\`\`
git pull
pip install -U -r requirements.txt
\`\`\`

&lt;details&gt;
&lt;summary&gt;전체 변경 로그 확장&lt;/summary&gt;

\`\`\`
&lt;여기에 변경 로그를 붙여넣으세요&gt;
\`\`\`

&lt;/details&gt;
</code></pre></div></details><h2 id="releases"> 릴리스 <a class="headerlink" href="#releases" title="영구 링크"> ¶ </a></h2><h3 id="pypi"> pypi <a class="headerlink" href="#pypi" title="영구 링크"> ¶ </a></h3><div class="admonition warning"><p class="admonition-title">수동 릴리스</p><p> 이 프로세스는 Github Actions의 일부로 자동화되었습니다. <br> 수동 pypi 푸시는 필요하지 않습니다. </p></div><details class="example"><summary>수동 릴리스</summary><p>수동으로 pypi 릴리스를 생성하려면 다음 명령어를 실행하세요:</p><p> 추가 요구 사항: <code> wheel </code> , <code> twine </code> (업로드용), 적절한 권한이 있는 pypi 계정. </p><div class="highlight"><pre><code>pip<span class="w"> </span>install<span class="w"> </span>-U<span class="w"> </span>build
python<span class="w"> </span>-m<span class="w"> </span>build<span class="w"> </span>--sdist<span class="w"> </span>--wheel

<span class="c1"># For pypi test (to check if some change to the installation did work)</span>
twine<span class="w"> </span>upload<span class="w"> </span>--repository-url<span class="w"> </span>https://test.pypi.org/legacy/<span class="w"> </span>dist/*

<span class="c1"># For production:</span>
twine<span class="w"> </span>upload<span class="w"> </span>dist/*
</code></pre></div><p>비 릴리스를 실제 pypi 인스턴스로 푸시하지 마세요.</p></details>`,72))])}}};export{m as default};
