import{r,o as d,c as i,b as a,d as n,e as l,w as c,a as e,u as o}from"./index-ff969378.js";const t="/assets/freqai_pytorch-diagram-724aa522.png";const u={class:"md-content__inner md-typeset"},f={class:"admonition note"},m=["src"],q=["src"],y={__name:"FreqAIConfiguration",setup(g){return(w,s)=>{const p=r("router-link");return d(),i("article",u,[s[108]||(s[108]=a("h1",{id:"configuration"},[n(" 설정 "),a("a",{class:"headerlink",href:"#configuration",title:"영구 링크"}," ¶ ")],-1)),a("p",null,[s[2]||(s[2]=n(" FreqAI는 일반적인 ")),l(p,{to:"configuration"},{default:c(()=>s[0]||(s[0]=[n(" Freqtrade 설정 파일 ")])),_:1}),s[3]||(s[3]=n(" 과 표준 ")),l(p,{to:"strategy-customization"},{default:c(()=>s[1]||(s[1]=[n(" Freqtrade 전략 ")])),_:1}),s[4]||(s[4]=n(" 을 통해 구성됩니다. FreqAI 설정 및 전략 파일의 예는 ")),s[5]||(s[5]=a("code",null," config_examples/config_freqai.example.json ",-1)),s[6]||(s[6]=n(" 와 ")),s[7]||(s[7]=a("code",null," freqtrade/templates/FreqaiExampleStrategy.py ",-1)),s[8]||(s[8]=n(" 에서 각각 확인할 수 있습니다. "))]),s[109]||(s[109]=a("h2",{id:"setting-up-the-configuration-file"},[n(" 설정 파일 구성하기 "),a("a",{class:"headerlink",href:"#setting-up-the-configuration-file",title:"영구 링크"}," ¶ ")],-1)),a("p",null,[l(p,{to:"freqai-parameter-table"},{default:c(()=>s[9]||(s[9]=[n("파라미터 테이블")])),_:1}),s[10]||(s[10]=n("에서 설명된 것처럼 선택할 수 있는 추가 파라미터가 많지만, FreqAI 설정에는 최소한 다음 파라미터가 포함되어야 합니다 (파라미터 값은 예시입니다):"))]),s[110]||(s[110]=e(`<div class="highlight"><pre><code><span class="w">    </span><span class="nt">&quot;freqai&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nt">&quot;enabled&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">        </span><span class="nt">&quot;purge_old_models&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">        </span><span class="nt">&quot;train_period_days&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">30</span><span class="p">,</span>
<span class="w">        </span><span class="nt">&quot;backtest_period_days&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span>
<span class="w">        </span><span class="nt">&quot;identifier&quot;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;unique-id&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="nt">&quot;feature_parameters&quot;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nt">&quot;include_timeframes&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;5m&quot;</span><span class="p">,</span><span class="s2">&quot;15m&quot;</span><span class="p">,</span><span class="s2">&quot;4h&quot;</span><span class="p">],</span>
<span class="w">            </span><span class="nt">&quot;include_corr_pairlist&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">                </span><span class="s2">&quot;ETH/USD&quot;</span><span class="p">,</span>
<span class="w">                </span><span class="s2">&quot;LINK/USD&quot;</span><span class="p">,</span>
<span class="w">                </span><span class="s2">&quot;BNB/USD&quot;</span>
<span class="w">            </span><span class="p">],</span>
<span class="w">            </span><span class="nt">&quot;label_period_candles&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">24</span><span class="p">,</span>
<span class="w">            </span><span class="nt">&quot;include_shifted_candles&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">            </span><span class="nt">&quot;indicator_periods_candles&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">]</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="nt">&quot;data_split_parameters&quot;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nt">&quot;test_size&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">0.25</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div><p>전체 예제 설정은 <code>config_examples/config_freqai.example.json</code>에서 확인할 수 있습니다.</p>`,2)),a("div",f,[s[17]||(s[17]=a("p",{class:"admonition-title"},"참고",-1)),a("p",null,[s[12]||(s[12]=a("code",null,"identifier",-1)),s[13]||(s[13]=n("는 초보자들이 자주 간과하는 중요한 설정입니다. 이는 실행을 구분하기 위한 고유 식별자입니다. 동일한 값을 유지하면 충돌 복구와 더 빠른 백테스팅이 가능합니다. 새로운 실행(새로운 특징, 새로운 모델 등)을 시도할 때는 이 값을 변경하거나 ")),s[14]||(s[14]=a("code",null,"user_data/models/unique-id",-1)),s[15]||(s[15]=n(" 폴더를 삭제해야 합니다. 자세한 내용은 ")),l(p,{to:"freqai-parameter-table"},{default:c(()=>s[11]||(s[11]=[n("파라미터 테이블")])),_:1}),s[16]||(s[16]=n("을 참조하세요."))])]),s[111]||(s[111]=a("h2",{id:"building-a-freqai-strategy"},[n(" FreqAI 전략 구축하기 "),a("a",{class:"headerlink",href:"#building-a-freqai-strategy",title:"영구 링크"}," ¶ ")],-1)),a("p",null,[s[19]||(s[19]=n("FreqAI 전략은 표준 ")),l(p,{to:"strategy-customization"},{default:c(()=>s[18]||(s[18]=[n("Freqtrade 전략")])),_:1}),s[20]||(s[20]=n("에 다음 코드를 포함해야 합니다:"))]),s[112]||(s[112]=e(`<div class="highlight"><pre><code>    <span class="c1"># 사용자는 최대 시작 캔들 수를 정의해야 합니다</span>
    <span class="c1"># (단일 지표에 전달되는 가장 큰 캔들 수)</span>
    <span class="n">startup_candle_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">populate_indicators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">metadata</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>

        <span class="c1"># 모델은 사용자가 \`set_freqai_targets()\`에서 생성한 모든 레이블을 반환합니다</span>
        <span class="c1"># (&amp; 추가된 타겟들), 예측이 수락되어야 하는지 여부에 대한 표시,</span>
        <span class="c1"># 각 학습 기간 동안 사용자가 \`set_freqai_targets()\`에서 생성한</span>
        <span class="c1"># 각 레이블에 대한 타겟 평균/표준편차 값.</span>

        <span class="n">dataframe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">freqai</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dataframe</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">feature_engineering_expand_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Only functional with FreqAI enabled strategies*</span>
<span class="sd">        This function will automatically expand the defined features on the config defined</span>
<span class="sd">        \`indicator_periods_candles\`, \`include_timeframes\`, \`include_shifted_candles\`, and</span>
<span class="sd">        \`include_corr_pairs\`. In other words, a single feature defined in this function</span>
<span class="sd">        will automatically expand to a total of</span>
<span class="sd">        \`indicator_periods_candles\` * \`include_timeframes\` * \`include_shifted_candles\` *</span>
<span class="sd">        \`include_corr_pairs\` numbers of features added to the model.</span>

<span class="sd">        All features must be prepended with \`%\` to be recognized by FreqAI internals.</span>

<span class="sd">        :param df: strategy dataframe which will receive the features</span>
<span class="sd">        :param period: period of the indicator - usage example:</span>
<span class="sd">        dataframe[&quot;%-ema-period&quot;] = ta.EMA(dataframe, timeperiod=period)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">%-r</span><span class="s2">si-period&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">RSI</span><span class="p">(</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">timeperiod</span><span class="o">=</span><span class="n">period</span><span class="p">)</span>
        <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;%-mfi-period&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">MFI</span><span class="p">(</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">timeperiod</span><span class="o">=</span><span class="n">period</span><span class="p">)</span>
        <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">%-a</span><span class="s2">dx-period&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">ADX</span><span class="p">(</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">timeperiod</span><span class="o">=</span><span class="n">period</span><span class="p">)</span>
        <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">%-s</span><span class="s2">ma-period&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">SMA</span><span class="p">(</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">timeperiod</span><span class="o">=</span><span class="n">period</span><span class="p">)</span>
        <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">%-e</span><span class="s2">ma-period&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">EMA</span><span class="p">(</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">timeperiod</span><span class="o">=</span><span class="n">period</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dataframe</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">feature_engineering_expand_basic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Only functional with FreqAI enabled strategies*</span>
<span class="sd">        This function will automatically expand the defined features on the config defined</span>
<span class="sd">        \`include_timeframes\`, \`include_shifted_candles\`, and \`include_corr_pairs\`.</span>
<span class="sd">        In other words, a single feature defined in this function</span>
<span class="sd">        will automatically expand to a total of</span>
<span class="sd">        \`include_timeframes\` * \`include_shifted_candles\` * \`include_corr_pairs\`</span>
<span class="sd">        numbers of features added to the model.</span>

<span class="sd">        Features defined here will *not* be automatically duplicated on user defined</span>
<span class="sd">        \`indicator_periods_candles\`</span>

<span class="sd">        All features must be prepended with \`%\` to be recognized by FreqAI internals.</span>

<span class="sd">        :param df: strategy dataframe which will receive the features</span>
<span class="sd">        dataframe[&quot;%-pct-change&quot;] = dataframe[&quot;close&quot;].pct_change()</span>
<span class="sd">        dataframe[&quot;%-ema-200&quot;] = ta.EMA(dataframe, timeperiod=200)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;%-pct-change&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;close&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">pct_change</span><span class="p">()</span>
        <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">%-r</span><span class="s2">aw_volume&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;volume&quot;</span><span class="p">]</span>
        <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">%-r</span><span class="s2">aw_price&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;close&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">dataframe</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">feature_engineering_standard</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Only functional with FreqAI enabled strategies*</span>
<span class="sd">        This optional function will be called once with the dataframe of the base timeframe.</span>
<span class="sd">        This is the final function to be called, which means that the dataframe entering this</span>
<span class="sd">        function will contain all the features and columns created by all other</span>
<span class="sd">        freqai_feature_engineering_* functions.</span>

<span class="sd">        This function is a good place to do custom exotic feature extractions (e.g. tsfresh).</span>
<span class="sd">        This function is a good place for any feature that should not be auto-expanded upon</span>
<span class="sd">        (e.g. day of the week).</span>

<span class="sd">        All features must be prepended with \`%\` to be recognized by FreqAI internals.</span>

<span class="sd">        :param df: strategy dataframe which will receive the features</span>
<span class="sd">        usage example: dataframe[&quot;%-day_of_week&quot;] = (dataframe[&quot;date&quot;].dt.dayofweek + 1) / 7</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">%-d</span><span class="s2">ay_of_week&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;date&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">dayofweek</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">7</span>
        <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">%-ho</span><span class="s2">ur_of_day&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;date&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">hour</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">25</span>
        <span class="k">return</span> <span class="n">dataframe</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">set_freqai_targets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Only functional with FreqAI enabled strategies*</span>
<span class="sd">        Required function to set the targets for the model.</span>
<span class="sd">        All targets must be prepended with \`&amp;\` to be recognized by the FreqAI internals.</span>

<span class="sd">        :param df: strategy dataframe which will receive the targets</span>
<span class="sd">        usage example: dataframe[&quot;&amp;-target&quot;] = dataframe[&quot;close&quot;].shift(-1) / dataframe[&quot;close&quot;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;&amp;-s_close&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;close&quot;</span><span class="p">]</span>
            <span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">freqai_info</span><span class="p">[</span><span class="s2">&quot;feature_parameters&quot;</span><span class="p">][</span><span class="s2">&quot;label_period_candles&quot;</span><span class="p">])</span>
            <span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">freqai_info</span><span class="p">[</span><span class="s2">&quot;feature_parameters&quot;</span><span class="p">][</span><span class="s2">&quot;label_period_candles&quot;</span><span class="p">])</span>
            <span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="o">/</span> <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;close&quot;</span><span class="p">]</span>
            <span class="o">-</span> <span class="mi">1</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">dataframe</span>
</code></pre></div>`,1)),a("p",null,[s[22]||(s[22]=a("code",null," feature_engineering_*() ",-1)),s[23]||(s[23]=n(" 에서 ")),l(p,{to:"freqai-feature-engineering"},{default:c(()=>s[21]||(s[21]=[n(" 기능 ")])),_:1}),s[24]||(s[24]=n(" 이 추가되는 방식을 주목하세요. 한편 ")),s[25]||(s[25]=a("code",null," set_freqai_targets() ",-1)),s[26]||(s[26]=n(" 는 레이블/타겟을 추가합니다. 전체 예제 전략은 ")),s[27]||(s[27]=a("code",null," templates/FreqaiExampleStrategy.py ",-1)),s[28]||(s[28]=n(" 에서 확인할 수 있습니다. "))]),s[113]||(s[113]=e('<div class="admonition note"><p class="admonition-title">참고</p><p><code> self.freqai.start() </code> 함수는 <code> populate_indicators() </code> 외부에서 호출될 수 없습니다. </p></div><div class="admonition note"><p class="admonition-title">참고</p><p> 기능은 <strong> 반드시 </strong><code> feature_engineering_*() </code> 에서 정의되어야 합니다. <code> populate_indicators() </code> 에서 FreqAI 기능을 정의하면 라이브/드라이 모드에서 알고리즘이 실패합니다. 특정 페어 또는 시간 프레임과 관련이 없는 일반화된 기능을 추가하려면 <code> feature_engineering_standard() </code> 를 사용해야 합니다(예시는 <code> freqtrade/templates/FreqaiExampleStrategy.py </code> 에서 확인할 수 있습니다). </p></div><h2 id="important-dataframe-key-patterns"> 중요한 데이터프레임 키 패턴 <a class="headerlink" href="#important-dataframe-key-patterns" title="영구 링크"> ¶ </a></h2><p> 아래는 일반적인 전략 데이터프레임( <code> df[] </code> ) 내에서 포함/사용할 수 있는 값들입니다: </p>',4)),a("table",null,[s[85]||(s[85]=a("thead",null,[a("tr",null,[a("th",null,"데이터프레임 키"),a("th",null,"설명")])],-1)),a("tbody",null,[s[82]||(s[82]=a("tr",null,[a("td",null,[a("code",null," df['&*'] ")]),a("td",null,[a("code",null," set_freqai_targets() "),n(" 에서 "),a("code",null," & "),n(" 로 시작하는 모든 데이터프레임 열은 FreqAI 내에서 훈련 타겟(레이블)로 처리됩니다(일반적으로 명명 규칙 "),a("code",null," &-s* "),n(" 을 따름). 예를 들어, 40 캔들 후의 종가를 예측하려면 "),a("code",null,` df['&-s_close'] = df['close'].shift(-self.freqai_info["feature_parameters"]["label_period_candles"]) `),n(" 와 같이 설정하고 설정 파일에 "),a("code",null,' "label_period_candles": 40 '),n(" 을 추가합니다. FreqAI는 예측을 수행하고 동일한 키( "),a("code",null," df['&-s_close'] "),n(" )로 결과를 반환하여 "),a("code",null," populate_entry/exit_trend() "),n(" 에서 사용할 수 있게 합니다. "),a("br"),a("strong",null," 데이터 타입: "),n(" 모델의 출력에 따라 다릅니다. ")])],-1)),s[83]||(s[83]=a("tr",null,[a("td",null,[a("code",null," df['&*_std/mean'] ")]),a("td",null,[n(" 훈련 중(또는 "),a("code",null," fit_live_predictions_candles "),n(" 을 사용하여 라이브 추적 시) 정의된 레이블의 표준 편차 및 평균 값. 예측의 희귀성을 이해하는 데 일반적으로 사용됩니다(예측이 훈련 중 얼마나 자주 관찰되었는지 평가하기 위해 "),a("code",null," templates/FreqaiExampleStrategy.py "),n(" 에 설명된 대로 z-점수를 사용). "),a("br"),a("strong",null," 데이터 타입: "),n(" Float. ")])],-1)),a("tr",null,[s[63]||(s[63]=a("td",null,[a("code",null," df['do_predict'] ")],-1)),a("td",null,[s[32]||(s[32]=n(" 이상치 데이터 포인트의 표시. 반환 값은 예측이 신뢰할 수 있는지 여부를 알려주는 -2에서 2 사이의 정수입니다. ")),s[33]||(s[33]=a("code",null," do_predict==1 ",-1)),s[34]||(s[34]=n(" 은 예측이 신뢰할 수 있음을 의미합니다. 입력 데이터 포인트의 비유사성 지수(DI, 자세한 내용은 ")),l(p,{to:"freqai-feature-engineering"},{default:c(()=>s[29]||(s[29]=[n(" 여기 ")])),_:1}),s[35]||(s[35]=n(" 참조)가 설정된 임계값을 초과하면 FreqAI는 ")),s[36]||(s[36]=a("code",null," do_predict ",-1)),s[37]||(s[37]=n(" 에서 1을 빼서 ")),s[38]||(s[38]=a("code",null," do_predict==0 ",-1)),s[39]||(s[39]=n(" 이 됩니다. ")),s[40]||(s[40]=a("code",null," use_SVM_to_remove_outliers ",-1)),s[41]||(s[41]=n(" 가 활성화된 경우, 서포트 벡터 머신(SVM, 자세한 내용은 ")),l(p,{to:"freqai-feature-engineering"},{default:c(()=>s[30]||(s[30]=[n(" 여기 ")])),_:1}),s[42]||(s[42]=n(" 참조)도 훈련 및 예측 데이터에서 이상치를 감지할 수 있습니다. 이 경우 SVM도 ")),s[43]||(s[43]=a("code",null," do_predict ",-1)),s[44]||(s[44]=n(" 에서 1을 뺍니다. 입력 데이터 포인트가 SVM에 의해 이상치로 간주되었지만 DI에 의해 그렇지 않은 경우 또는 그 반대의 경우 결과는 ")),s[45]||(s[45]=a("code",null," do_predict==0 ",-1)),s[46]||(s[46]=n(" 이 됩니다. DI와 SVM 모두 입력 데이터 포인트를 이상치로 간주한 경우 결과는 ")),s[47]||(s[47]=a("code",null," do_predict==-1 ",-1)),s[48]||(s[48]=n(" 이 됩니다. SVM과 마찬가지로 ")),s[49]||(s[49]=a("code",null," use_DBSCAN_to_remove_outliers ",-1)),s[50]||(s[50]=n(" 가 활성화된 경우 DBSCAN(자세한 내용은 ")),l(p,{to:"freqai-feature-engineering"},{default:c(()=>s[31]||(s[31]=[n(" 여기 ")])),_:1}),s[51]||(s[51]=n(" 참조)도 이상치를 감지하고 ")),s[52]||(s[52]=a("code",null," do_predict ",-1)),s[53]||(s[53]=n(" 에서 1을 뺍니다. 따라서 SVM과 DBSCAN이 모두 활성화되고 DI 임계값을 초과한 데이터 포인트를 이상치로 식별한 경우 결과는 ")),s[54]||(s[54]=a("code",null," do_predict==-2 ",-1)),s[55]||(s[55]=n(" 이 됩니다. ")),s[56]||(s[56]=a("code",null," do_predict == 2 ",-1)),s[57]||(s[57]=n(" 인 경우는 모델이 ")),s[58]||(s[58]=a("code",null," expired_hours ",-1)),s[59]||(s[59]=n(" 를 초과하여 만료된 경우입니다. ")),s[60]||(s[60]=a("br",null,null,-1)),s[61]||(s[61]=a("strong",null," 데이터 타입: ",-1)),s[62]||(s[62]=n(" -2에서 2 사이의 정수. "))])]),a("tr",null,[s[70]||(s[70]=a("td",null,[a("code",null," df['DI_values'] ")],-1)),a("td",null,[s[65]||(s[65]=n(" 비유사성 지수(DI) 값은 예측에 대한 FreqAI의 신뢰 수준을 나타내는 지표입니다. 낮은 DI는 예측이 훈련 데이터에 가깝다는 것을 의미하며, 즉 예측 신뢰도가 높음을 의미합니다. DI에 대한 자세한 내용은 ")),l(p,{to:"freqai-feature-engineering"},{default:c(()=>s[64]||(s[64]=[n(" 여기 ")])),_:1}),s[66]||(s[66]=n(" 에서 확인할 수 있습니다. ")),s[67]||(s[67]=a("br",null,null,-1)),s[68]||(s[68]=a("strong",null," 데이터 타입: ",-1)),s[69]||(s[69]=n(" Float. "))])]),a("tr",null,[s[81]||(s[81]=a("td",null,[a("code",null," df['%*'] ")],-1)),a("td",null,[s[72]||(s[72]=a("code",null," feature_engineering_*() ",-1)),s[73]||(s[73]=n(" 에서 ")),s[74]||(s[74]=a("code",null," % ",-1)),s[75]||(s[75]=n(" 로 시작하는 모든 데이터프레임 열은 훈련 기능으로 처리됩니다. 예를 들어, ")),s[76]||(s[76]=a("code",null," templates/FreqaiExampleStrategy.py ",-1)),s[77]||(s[77]=n(" 에서와 같이 훈련 기능 세트에 RSI를 포함하려면 ")),s[78]||(s[78]=a("code",null," df['%-rsi'] ",-1)),s[79]||(s[79]=n(" 로 설정할 수 있습니다. 자세한 내용은 ")),l(p,{to:"freqai-feature-engineering"},{default:c(()=>s[71]||(s[71]=[n(" 여기 ")])),_:1}),s[80]||(s[80]=e(" 에서 확인할 수 있습니다. <br><strong> 참고: </strong><code> % </code> 로 시작하는 기능의 수는 매우 빠르게 증가할 수 있습니다(예: <code> include_shifted_candles </code> 와 <code> include_timeframes </code> 와 같은 곱셈 기능을 사용하여 수만 개의 기능이 쉽게 생성됨). 이러한 기능은 FreqAI에서 전략으로 반환되는 데이터프레임에서 제거됩니다. 특정 유형의 기능을 플로팅 목적으로 유지하려면 <code> %% </code> 로 시작해야 합니다(자세한 내용은 아래 참조). <br><strong> 데이터 타입: </strong> 사용자가 생성한 기능에 따라 다릅니다. ",14))])]),s[84]||(s[84]=a("tr",null,[a("td",null,[a("code",null," df['%%*'] ")]),a("td",null,[a("code",null," feature_engineering_*() "),n(" 에서 "),a("code",null," %% "),n(" 로 시작하는 모든 데이터프레임 열은 위의 "),a("code",null," % "),n(" 접두사와 동일하게 훈련 기능으로 처리됩니다. 그러나 이 경우 기능은 FreqUI/플롯-데이터프레임 플로팅 및 드라이/라이브/백테스팅 모니터링을 위해 전략으로 반환됩니다. "),a("br"),a("strong",null," 데이터 타입: "),n(" 사용자가 생성한 기능에 따라 다릅니다. "),a("code",null," feature_engineering_expand() "),n(" 에서 생성된 기능은 구성한 확장에 따라 자동으로 FreqAI 명명 스키마를 갖습니다(예: "),a("code",null," include_timeframes "),n(" , "),a("code",null," include_corr_pairlist "),n(" , "),a("code",null," indicators_periods_candles "),n(" , "),a("code",null," include_shifted_candles "),n(" ). 따라서 "),a("code",null," feature_engineering_expand_all() "),n(" 에서 "),a("code",null," %%-rsi "),n(" 를 플로팅하려면 최종 명명 스키마는 다음과 같습니다: "),a("code",null," %%-rsi-period_10_ETH/USDT:USDT_1h "),n(" (기능 "),a("code",null," rsi "),n(" , "),a("code",null," period=10 "),n(" , "),a("code",null," timeframe=1h "),n(" , "),a("code",null," pair=ETH/USDT:USDT "),n(" ). 전체 기능 목록을 보려면 "),a("code",null," self.freqai.start() "),n(" 후 "),a("code",null," populate_indicators() "),n(" 에 "),a("code",null," print(dataframe.columns) "),n(" 를 추가하는 것이 유용합니다. ")])],-1))])]),s[114]||(s[114]=a("h2",{id:"setting-the-startup_candle_count"},[a("code",null," startup_candle_count "),n(" 설정 "),a("a",{class:"headerlink",href:"#setting-the-startup_candle_count",title:"영구 링크"}," ¶ ")],-1)),a("p",null,[s[87]||(s[87]=n(" FreqAI 전략의 ")),s[88]||(s[88]=a("code",null," startup_candle_count ",-1)),s[89]||(s[89]=n(" 는 표준 Freqtrade 전략과 동일한 방식으로 설정해야 합니다(자세한 내용은 ")),l(p,{to:"strategy-customization"},{default:c(()=>s[86]||(s[86]=[n(" 여기 ")])),_:1}),s[90]||(s[90]=n(" 참조). 이 값은 Freqtrade가 ")),s[91]||(s[91]=a("code",null," dataprovider ",-1)),s[92]||(s[92]=n(" 를 호출할 때 충분한 양의 데이터를 제공하여 첫 번째 훈련의 시작 부분에서 NaN을 방지하도록 보장하는 데 사용됩니다. 이 값을 설정하려면 지표 생성 함수(예: TA-Lib 함수)에 전달되는 가장 긴 기간(캔들 단위)을 식별하면 됩니다. 제시된 예제에서는 ")),s[93]||(s[93]=a("code",null," startup_candle_count ",-1)),s[94]||(s[94]=n(" 가 20입니다. "))]),s[115]||(s[115]=e(`<div class="admonition note"><p class="admonition-title">참고</p><p> TA-Lib 함수가 실제로 전달된 <code> period </code> 보다 더 많은 데이터를 필요로 하는 경우가 있습니다. 그렇지 않으면 기능 데이터 세트가 NaN으로 채워집니다. 경험적으로 <code> startup_candle_count </code> 를 2배로 곱하면 항상 NaN이 없는 훈련 데이터 세트가 생성됩니다. 따라서 예상 <code> startup_candle_count </code> 를 2배로 곱하는 것이 가장 안전합니다. 데이터가 깨끗하다는 것을 확인하려면 다음 로그 메시지를 확인하세요: </p><div class="highlight"><pre><code>2022-08-31 15:14:04 - freqtrade.freqai.data_kitchen - INFO - dropped 0 training points due to NaNs in populated dataset 4319.
</code></pre></div></div><h2 id="creating-a-dynamic-target-threshold"> 동적 타겟 임계값 생성 <a class="headerlink" href="#creating-a-dynamic-target-threshold" title="영구 링크"> ¶ </a></h2>`,2)),a("p",null,[s[96]||(s[96]=n(" 거래를 시작하거나 종료할 시점을 결정하는 것은 현재 시장 상황을 반영하여 동적으로 수행할 수 있습니다. FreqAI는 모델 훈련에서 추가 정보를 반환할 수 있습니다(자세한 내용은 ")),l(p,{to:"freqai-feature-engineering"},{default:c(()=>s[95]||(s[95]=[n(" 여기 ")])),_:1}),s[97]||(s[97]=n(" 참조). 예를 들어, ")),s[98]||(s[98]=a("code",null," &*_std/mean ",-1)),s[99]||(s[99]=n(" 반환 값은 ")),s[100]||(s[100]=a("em",null," 가장 최근 훈련 중 ",-1)),s[101]||(s[101]=n(" 타겟/레이블의 통계적 분포를 설명합니다. 주어진 예측을 이러한 값과 비교하면 예측의 희귀성을 알 수 있습니다. ")),s[102]||(s[102]=a("code",null," templates/FreqaiExampleStrategy.py ",-1)),s[103]||(s[103]=n(" 에서는 ")),s[104]||(s[104]=a("code",null," target_roi ",-1)),s[105]||(s[105]=n(" 와 ")),s[106]||(s[106]=a("code",null," sell_roi ",-1)),s[107]||(s[107]=n(" 가 평균에서 1.25 z-점수 떨어진 값으로 정의되어 있어 평균에 가까운 예측이 필터링됩니다. "))]),s[116]||(s[116]=e(`<div class="highlight"><pre><code><span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;target_roi&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;&amp;-s_close_mean&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;&amp;-s_close_std&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1.25</span>
<span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;sell_roi&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;&amp;-s_close_mean&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;&amp;-s_close_std&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1.25</span>
</code></pre></div><p> 동적 타겟을 생성하기 위해 훈련에서 얻은 정보 대신 <em> 역사적 예측 </em> 의 인구를 고려하려면 설정 파일에서 <code> fit_live_predictions_candles </code> 을 사용하여 생성할 역사적 예측 캔들의 수를 설정합니다. </p><div class="highlight"><pre><code><span class="w">    </span><span class="nt">&quot;freqai&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nt">&quot;fit_live_predictions_candles&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">300</span><span class="p">,</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div><p> 이 값을 설정하면 FreqAI는 처음에는 훈련 데이터의 예측을 사용하고 이후에는 생성된 실제 예측 데이터를 도입하기 시작합니다. FreqAI는 이 역사적 데이터를 저장하여 동일한 <code> identifier </code> 로 모델을 중지하고 다시 시작할 때 다시 로드합니다. </p><h2 id="using-different-prediction-models"> 다른 예측 모델 사용 <a class="headerlink" href="#using-different-prediction-models" title="영구 링크"> ¶ </a></h2><p> FreqAI에는 <code> --freqaimodel </code> 플래그를 통해 사용할 수 있는 여러 예측 모델 라이브러리가 포함되어 있습니다. 이러한 라이브러리에는 <code> CatBoost </code> , <code> LightGBM </code> 및 <code> XGBoost </code> 회귀, 분류 및 다중 타겟 모델이 포함되어 있으며 <code> freqai/prediction_models/ </code> 에서 찾을 수 있습니다. </p><p> 회귀 및 분류 모델은 예측하는 타겟이 다릅니다. 회귀 모델은 연속 값을 예측하고, 예를 들어 내일 BTC의 가격이 얼마일지를 예측합니다. 반면 분류 모델은 이산 값을 예측하고, 예를 들어 내일 BTC의 가격이 오를지 내릴지를 예측합니다. 따라서 사용하는 모델 유형에 따라 타겟을 다르게 지정해야 합니다(자세한 내용은 <a href="#setting-model-targets"> 아래 </a> 참조). </p><p>앞서 언급한 모든 모델 라이브러리는 그래디언트 부스팅 결정 트리 알고리즘을 구현합니다. 이들은 모두 앙상블 학습의 원리를 기반으로 작동하며, 여러 간단한 학습자의 예측을 결합하여 더 안정적이고 일반화된 최종 예측을 얻습니다. 이 경우 간단한 학습자는 결정 트리입니다. 그래디언트 부스팅은 각 간단한 학습자가 순차적으로 구축되는 학습 방법을 나타내며, 후속 학습자는 이전 학습자의 오류를 개선하는 데 사용됩니다. 각 모델 라이브러리에 대한 자세한 정보는 해당 문서에서 확인할 수 있습니다:</p><ul><li> CatBoost: <a href="https://catboost.ai/en/docs/"> https://catboost.ai/en/docs/ </a></li><li> LightGBM: <a href="https://lightgbm.readthedocs.io/en/v3.3.2/"> https://lightgbm.readthedocs.io/en/v3.3.2/# </a></li><li> XGBoost: <a href="https://xgboost.readthedocs.io/en/stable/"> https://xgboost.readthedocs.io/en/stable/# </a></li></ul><p> 또한 알고리즘을 설명하고 비교하는 수많은 온라인 기사가 있습니다. 상대적으로 가벼운 예로는 <a href="https://towardsdatascience.com/catboost-vs-lightgbm-vs-xgboost-c80f40662924#:~:text=In%20CatBoost%2C%20symmetric%20trees%2C%20or,the%20same%20depth%20can%20differ."> CatBoost vs. LightGBM vs. XGBoost — Which is the best algorithm? </a> 와 <a href="https://medium.com/riskified-technology/xgboost-lightgbm-or-catboost-which-boosting-algorithm-should-i-use-e7fda7bb36bc"> XGBoost, LightGBM or CatBoost — which boosting algorithm should I use? </a> 가 있습니다. 각 모델의 성능은 응용 프로그램에 따라 크게 달라지므로 보고된 메트릭이 특정 사용 사례에 대해 항상 정확하지 않을 수 있습니다. </p><p> FreqAI에 이미 제공된 모델 외에도 <code> IFreqaiModel </code> 클래스를 사용하여 사용자 정의 예측 모델을 만들 수 있습니다. <code> fit() </code> , <code> train() </code> 및 <code> predict() </code> 를 상속하여 다양한 훈련 절차를 사용자 정의할 수 있습니다. 사용자 정의 FreqAI 모델을 <code> user_data/freqaimodels </code> 에 배치할 수 있으며, freqtrade는 제공된 <code> --freqaimodel </code> 이름에 따라 이를 선택합니다. 이 이름은 사용자 정의 모델의 클래스 이름과 일치해야 합니다. 고유한 이름을 사용하여 기본 제공 모델을 덮어쓰지 않도록 하세요. </p><h3 id="setting-model-targets"> 모델 타겟 설정 <a class="headerlink" href="#setting-model-targets" title="영구 링크"> ¶ </a></h3><h4 id="regressors"> 회귀 모델 <a class="headerlink" href="#regressors" title="영구 링크"> ¶ </a></h4><p> 회귀 모델을 사용하는 경우 연속 값을 가지는 타겟을 지정해야 합니다. FreqAI에는 <code> CatboostRegressor </code> 와 같은 다양한 회귀 모델이 포함되어 있으며 <code> --freqaimodel CatboostRegressor </code> 플래그를 통해 사용할 수 있습니다. 100 캔들 후의 가격을 예측하기 위한 회귀 타겟을 설정하는 예는 다음과 같습니다: </p><div class="highlight"><pre><code><span class="n">df</span><span class="p">[</span><span class="s1">&#39;&amp;s-close_price&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;close&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="o">-</span><span class="mi">100</span><span class="p">)</span>
</code></pre></div><p>여러 타겟을 예측하려면 위와 같은 구문을 사용하여 여러 레이블을 정의해야 합니다.</p><h4 id="classifiers"> 분류 모델 <a class="headerlink" href="#classifiers" title="영구 링크"> ¶ </a></h4><p> 분류 모델을 사용하는 경우 이산 값을 가지는 타겟을 지정해야 합니다. FreqAI에는 <code> CatboostClassifier </code> 와 같은 다양한 분류 모델이 포함되어 있으며 <code> --freqaimodel CatboostClassifier </code> 플래그를 통해 사용할 수 있습니다. 분류기를 사용하는 경우 클래스는 문자열로 설정해야 합니다. 예를 들어, 100 캔들 후의 가격이 오르거나 내릴지를 예측하려면 다음과 같이 설정합니다: </p><div class="highlight"><pre><code><span class="n">df</span><span class="p">[</span><span class="s1">&#39;&amp;s-up_or_down&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;close&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="o">-</span><span class="mi">100</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;close&quot;</span><span class="p">],</span> <span class="s1">&#39;up&#39;</span><span class="p">,</span> <span class="s1">&#39;down&#39;</span><span class="p">)</span>
</code></pre></div><p> 여러 타겟을 예측하려면 모든 레이블을 동일한 레이블 열에 지정해야 합니다. 예를 들어, 가격이 변하지 않은 경우를 정의하기 위해 <code> same </code> 레이블을 추가할 수 있습니다: </p><div class="highlight"><pre><code><span class="n">df</span><span class="p">[</span><span class="s1">&#39;&amp;s-up_or_down&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;close&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="o">-</span><span class="mi">100</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;close&quot;</span><span class="p">],</span> <span class="s1">&#39;up&#39;</span><span class="p">,</span> <span class="s1">&#39;down&#39;</span><span class="p">)</span>
<span class="n">df</span><span class="p">[</span><span class="s1">&#39;&amp;s-up_or_down&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;close&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="o">-</span><span class="mi">100</span><span class="p">)</span> <span class="o">==</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;close&quot;</span><span class="p">],</span> <span class="s1">&#39;same&#39;</span><span class="p">,</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;&amp;s-up_or_down&#39;</span><span class="p">])</span>
</code></pre></div><h2 id="pytorch-module"> PyTorch 모듈 <a class="headerlink" href="#pytorch-module" title="영구 링크"> ¶ </a></h2><h3 id="quick-start"> 빠른 시작 <a class="headerlink" href="#quick-start" title="영구 링크"> ¶ </a></h3><p>PyTorch 모델을 빠르게 실행하는 가장 쉬운 방법은 다음 명령을 사용하는 것입니다(회귀 작업의 경우):</p><div class="highlight"><pre><code>freqtrade<span class="w"> </span>trade<span class="w"> </span>--config<span class="w"> </span>config_examples/config_freqai.example.json<span class="w"> </span>--strategy<span class="w"> </span>FreqaiExampleStrategy<span class="w"> </span>--freqaimodel<span class="w"> </span>PyTorchMLPRegressor<span class="w"> </span>--strategy-path<span class="w"> </span>freqtrade/templates<span class="w"> </span>
</code></pre></div><div class="admonition note"><p class="admonition-title">설치/도커</p><p> PyTorch 모듈은 <code> torch </code> 와 같은 대형 패키지를 필요로 하며, <code> ./setup.sh -i </code> 를 실행할 때 &quot;freqai-rl 또는 PyTorch에 대한 종속성도 설치하시겠습니까(~700mb 추가 공간 필요) [y/N]?&quot;라는 질문에 &quot;y&quot;로 대답하여 명시적으로 요청해야 합니다. 도커를 선호하는 사용자는 <code> _freqaitorch </code> 로 추가된 도커 이미지를 사용해야 합니다. 이를 위해 <code> docker/docker-compose-freqai.yml </code> 에 명시적인 도커 컴포즈 파일을 제공합니다. 이를 <code> docker compose -f docker/docker-compose-freqai.yml run ... </code> 을 통해 사용할 수 있으며, 원본 도커 파일을 대체하도록 복사할 수도 있습니다. 이 도커 컴포즈 파일에는 도커 컨테이너 내에서 GPU 리소스를 활성화하기 위한 (비활성화된) 섹션도 포함되어 있습니다. 이는 시스템에 GPU 리소스가 있는 경우에만 가능합니다. </p></div><h3 id="structure"> 구조 <a class="headerlink" href="#structure" title="영구 링크"> ¶ </a></h3><h4 id="model"> 모델 <a class="headerlink" href="#model" title="영구 링크"> ¶ </a></h4><p> 사용자 정의 <code> IFreqaiModel </code> 파일 내부에 <code> nn.Module </code> 클래스를 정의하여 PyTorch에서 자체 신경망 아키텍처를 구성할 수 있습니다. 그런 다음 해당 클래스를 <code> def train() </code> 함수에서 사용합니다. 다음은 분류 작업을 위한 PyTorch를 사용한 로지스틱 회귀 모델 구현 예제입니다(nn.BCELoss 기준으로 사용해야 함). </p><div class="highlight"><pre><code><span class="k">class</span><span class="w"> </span><span class="nc">LogisticRegression</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="c1"># Define your layers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">input_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activation</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sigmoid</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
        <span class="c1"># Define the forward pass</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MyCoolPyTorchClassifier</span><span class="p">(</span><span class="n">BasePyTorchClassifier</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a custom IFreqaiModel showing how a user might setup their own </span>
<span class="sd">    custom Neural Network architecture for their training.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">data_convertor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PyTorchDataConvertor</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">DefaultPyTorchDataConvertor</span><span class="p">(</span><span class="n">target_tensor_type</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">config</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">freqai_info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;model_training_parameters&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;learning_rate&quot;</span><span class="p">,</span>  <span class="mf">3e-4</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;model_kwargs&quot;</span><span class="p">,</span>  <span class="p">{})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trainer_kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;trainer_kwargs&quot;</span><span class="p">,</span>  <span class="p">{})</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dictionary</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">dk</span><span class="p">:</span> <span class="n">FreqaiDataKitchen</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        User sets up the training and test data to fit their desired model here</span>
<span class="sd">        :param data_dictionary: the dictionary holding all data for train, test,</span>
<span class="sd">            labels, weights</span>
<span class="sd">        :param dk: The datakitchen object for the current coin/model</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">class_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_class_names</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convert_label_column_to_int</span><span class="p">(</span><span class="n">data_dictionary</span><span class="p">,</span> <span class="n">dk</span><span class="p">,</span> <span class="n">class_names</span><span class="p">)</span>
        <span class="n">n_features</span> <span class="o">=</span> <span class="n">data_dictionary</span><span class="p">[</span><span class="s2">&quot;train_features&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">(</span>
            <span class="n">input_dim</span><span class="o">=</span><span class="n">n_features</span>
        <span class="p">)</span>
        <span class="n">model</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="n">optimizer</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">AdamW</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">)</span>
        <span class="n">criterion</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">CrossEntropyLoss</span><span class="p">()</span>
        <span class="n">init_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_init_model</span><span class="p">(</span><span class="n">dk</span><span class="o">.</span><span class="n">pair</span><span class="p">)</span>
        <span class="n">trainer</span> <span class="o">=</span> <span class="n">PyTorchModelTrainer</span><span class="p">(</span>
            <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
            <span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">,</span>
            <span class="n">criterion</span><span class="o">=</span><span class="n">criterion</span><span class="p">,</span>
            <span class="n">model_meta_data</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;class_names&quot;</span><span class="p">:</span> <span class="n">class_names</span><span class="p">},</span>
            <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
            <span class="n">init_model</span><span class="o">=</span><span class="n">init_model</span><span class="p">,</span>
            <span class="n">data_convertor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_convertor</span><span class="p">,</span>
            <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">trainer_kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">trainer</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data_dictionary</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">splits</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">trainer</span>
</code></pre></div><h4 id="trainer"> 트레이너 <a class="headerlink" href="#trainer" title="영구 링크"> ¶ </a></h4><p><code> PyTorchModelTrainer </code> 는 관용적인 PyTorch 훈련 루프를 수행합니다: 모델, 손실 함수 및 옵티마이저를 정의한 다음 적절한 장치(GPU 또는 CPU)로 이동합니다. 루프 내부에서 데이터로더의 배치를 반복하고, 데이터를 장치로 이동하고, 예측 및 손실을 계산하고, 역전파하고, 옵티마이저를 사용하여 모델 매개변수를 업데이트합니다. </p><p> 또한 트레이너는 다음을 담당합니다: - 모델 저장 및 로드 - 데이터를 <code> pandas.DataFrame </code> 에서 <code> torch.Tensor </code> 로 변환. </p><h4 id="integration-with-freqai-module"> FreqAI 모듈과의 통합 <a class="headerlink" href="#integration-with-freqai-module" title="영구 링크"> ¶ </a></h4><p>다음은 FreqAI 모듈과 PyTorch 모델의 통합을 보여주는 다이어그램입니다:</p>`,35)),a("img",{alt:"FreqAI와 PyTorch 통합 다이어그램",src:o(t)},null,8,m),s[117]||(s[117]=e("<p> 모든 freqai 모델과 마찬가지로 PyTorch 모델은 <code> IFreqaiModel </code> 을 상속합니다. <code> IFreqaiModel </code> 은 세 가지 추상 메서드를 선언합니다: <code> train </code> , <code> fit </code> 및 <code> predict </code> . 우리는 이 메서드를 세 가지 계층 구조 수준에서 구현합니다. 위에서 아래로: </p><ol><li><code> BasePyTorchModel </code> - <code> train </code> 메서드를 구현합니다. 모든 <code> BasePyTorch* </code> 는 이를 상속합니다. 일반 데이터 준비(예: 데이터 정규화) 및 <code> fit </code> 메서드 호출을 담당합니다. 자식 클래스에서 사용되는 <code> device </code> 속성을 설정합니다. 부모 클래스에서 사용되는 <code> model_type </code> 속성을 설정합니다. </li><li><code> BasePyTorch* </code> - <code> predict </code> 메서드를 구현합니다. 여기서 <code> * </code> 는 분류기 또는 회귀기와 같은 알고리즘 그룹을 나타냅니다. 데이터 전처리, 예측 및 필요한 경우 후처리를 담당합니다. </li><li><code> PyTorch*Classifier </code> / <code> PyTorch*Regressor </code> - <code> fit </code> 메서드를 구현합니다. 여기서 우리는 트레이너 및 모델 객체를 초기화하는 주요 훈련 흐름을 담당합니다. </li></ol>",2)),a("p",null,[a("img",{alt:"image",src:o(t)},null,8,q)]),s[118]||(s[118]=e(`<h4 id="full-example"> 전체 예제 <a class="headerlink" href="#full-example" title="영구 링크"> ¶ </a></h4><p>MLP(다층 퍼셉트론) 모델, MSELoss 기준 및 AdamW 옵티마이저를 사용하여 PyTorch 회귀기를 구축합니다.</p><div class="highlight"><pre><code><span class="k">class</span><span class="w"> </span><span class="nc">PyTorchMLPRegressor</span><span class="p">(</span><span class="n">BasePyTorchRegressor</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">config</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">freqai_info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;model_training_parameters&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;learning_rate&quot;</span><span class="p">,</span>  <span class="mf">3e-4</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;model_kwargs&quot;</span><span class="p">,</span>  <span class="p">{})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trainer_kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;trainer_kwargs&quot;</span><span class="p">,</span>  <span class="p">{})</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dictionary</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">dk</span><span class="p">:</span> <span class="n">FreqaiDataKitchen</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="n">n_features</span> <span class="o">=</span> <span class="n">data_dictionary</span><span class="p">[</span><span class="s2">&quot;train_features&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">PyTorchMLPModel</span><span class="p">(</span>
            <span class="n">input_dim</span><span class="o">=</span><span class="n">n_features</span><span class="p">,</span>
            <span class="n">output_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">model_kwargs</span>
        <span class="p">)</span>
        <span class="n">model</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="n">optimizer</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">AdamW</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">)</span>
        <span class="n">criterion</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">MSELoss</span><span class="p">()</span>
        <span class="n">init_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_init_model</span><span class="p">(</span><span class="n">dk</span><span class="o">.</span><span class="n">pair</span><span class="p">)</span>
        <span class="n">trainer</span> <span class="o">=</span> <span class="n">PyTorchModelTrainer</span><span class="p">(</span>
            <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
            <span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">,</span>
            <span class="n">criterion</span><span class="o">=</span><span class="n">criterion</span><span class="p">,</span>
            <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
            <span class="n">init_model</span><span class="o">=</span><span class="n">init_model</span><span class="p">,</span>
            <span class="n">target_tensor_type</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">,</span>
            <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">trainer_kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">trainer</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data_dictionary</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">trainer</span>
</code></pre></div><p> 여기서 우리는 <code> PyTorchMLPRegressor </code> 클래스를 생성하여 <code> fit </code> 메서드를 구현합니다. <code> fit </code> 메서드는 훈련 구성 요소를 지정합니다: 모델, 옵티마이저, 기준 및 트레이너. 우리는 회귀 작업에 적합한 <code> predict </code> 메서드를 구현하는 <code> BasePyTorchRegressor </code> 와 <code> train </code> 메서드를 구현하는 <code> BasePyTorchModel </code> 을 상속합니다. </p><details class="note"><summary>분류기를 위한 클래스 이름 설정</summary><p> 분류기를 사용할 때 사용자는 <code> IFreqaiModel.class_names </code> 속성을 재정의하여 클래스 이름(또는 타겟)을 선언해야 합니다. 이는 <code> set_freqai_targets </code> 메서드 내에서 <code> self.freqai.class_names </code> 를 설정하여 수행됩니다. </p><div> 예를 들어, 가격 움직임을 상승 또는 하락으로 예측하는 이진 분류기를 사용하는 경우 클래스 이름을 다음과 같이 설정할 수 있습니다: <div class="highlight"><pre><code><span class="k">def</span><span class="w"> </span><span class="nf">set_freqai_targets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">metadata</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">freqai</span><span class="o">.</span><span class="n">class_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;down&quot;</span><span class="p">,</span> <span class="s2">&quot;up&quot;</span><span class="p">]</span>
    <span class="n">dataframe</span><span class="p">[</span><span class="s1">&#39;&amp;s-up_or_down&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;close&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="o">-</span><span class="mi">100</span><span class="p">)</span> <span class="o">&gt;</span>
                                              <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;close&quot;</span><span class="p">],</span> <span class="s1">&#39;up&#39;</span><span class="p">,</span> <span class="s1">&#39;down&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dataframe</span>
</code></pre></div> 전체 예제를 보려면 <a href="https://github.com/freqtrade/freqtrade/blob/develop/tests/strategy/strats/freqai_test_classifier.py"> 분류기 테스트 전략 클래스 </a> 를 참조할 수 있습니다. </div></details><h4 id="improving-performance-with-torchcompile"><code> torch.compile() </code> 로 성능 향상 <a class="headerlink" href="#improving-performance-with-torchcompile" title="영구 링크"> ¶ </a></h4><p> Torch는 특정 GPU 하드웨어에 대한 성능을 향상시키기 위해 사용할 수 있는 <code> torch.compile() </code> 메서드를 제공합니다. 자세한 내용은 <a href="https://pytorch.org/tutorials/intermediate/torch_compile_tutorial.html"> 여기 </a> 에서 확인할 수 있습니다. 간단히 말해, 모델을 <code> torch.compile() </code> 로 래핑하면 됩니다: </p><div class="highlight"><pre><code>        <span class="n">model</span> <span class="o">=</span> <span class="n">PyTorchMLPModel</span><span class="p">(</span>
            <span class="n">input_dim</span><span class="o">=</span><span class="n">n_features</span><span class="p">,</span>
            <span class="n">output_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">model_kwargs</span>
        <span class="p">)</span>
        <span class="n">model</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
</code></pre></div><p>그런 다음 모델을 정상적으로 사용합니다. 이렇게 하면 즉시 실행이 제거되므로 오류 및 추적이 유익하지 않다는 점을 유의하세요.</p>`,9))])}}};export{y as default};
